{"meta":{"title":"道墟","subtitle":"初九，潜龙勿用","description":null,"author":"道墟","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-29T15:28:54.000Z","updated":"2018-05-30T01:43:46.253Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-30T03:44:46.000Z","updated":"2018-05-30T03:45:39.389Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"tag","date":"2018-05-29T15:29:50.000Z","updated":"2018-05-30T01:43:46.257Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"WMS","slug":"WMS","date":"2018-07-13T03:04:38.000Z","updated":"2018-07-13T03:04:40.017Z","comments":true,"path":"2018/07/13/WMS/","link":"","permalink":"http://yoursite.com/2018/07/13/WMS/","excerpt":"","text":"修改窗口或者屏幕属性relayoutWindow 修改指定窗口的布局参数 参数列表分析 参数 释义 Session session 调用者所在进程的session示例 IWindow client 需要进行relayout的窗口 int seq 状态栏和导航栏可见性相关的 符号 WindowManager.LayoutParams attrs 窗口的新布局属性 根据attrs 重新布局一个窗口 int requestedWidth 客户端需求的宽度 int requestedHeight 客户端需求的高度 int viewVisibility 窗口的可见性 int flags 定义一些布局行为 Rect outFrame 返回给调用者的实例，保存了窗口重新布局后的大小和位置 Rect outOverscanInsets 可以绘制内容的矩形边界 Rect outContentInsets 可视矩形边界到 mframe的像素差 Rect outVisibleInsets Rect outStableInsets Rect outOutsets Configuration outConfig 重新布局后，wms为窗口计算出来的Configuration Surface outSurface 用来接收分配的 Surface 代码解析权限相关检查12345678910111213////Log.i(TAG, \"relayoutWindow\");boolean toBeDisplayed = false;boolean inTouchMode;boolean configChanged;boolean surfaceChanged = false;boolean animating;//权限检查boolean hasStatusBarPermission = mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR) == PackageManager.PERMISSION_GRANTED;long origId = Binder.clearCallingIdentity(); 根据用户传入的参数更新windowState相关属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//下面操作（一直到方法结束）是在锁住mWindowMap情况下完成的。在wms中，几乎所有的操作都是在锁住mWindowMap下完成的。synchronized(mWindowMap) &#123; //获取需要更新的 WindowState WindowState win = windowForClientLocked(session, client, false); if (win == null) &#123; return 0; &#125; WindowStateAnimator winAnimator = win.mWinAnimator; //更新win的宽度和高度为客户端请求的大小 if (viewVisibility != View.GONE &amp;&amp; (win.mRequestedWidth != requestedWidth || win.mRequestedHeight != requestedHeight)) &#123; win.mLayoutNeeded = true; win.mRequestedWidth = requestedWidth; win.mRequestedHeight = requestedHeight; &#125; if (attrs != null) &#123; // attrs.type：TYPE_SYSTEM_OVERLAY 和 TYPE_SECURE_SYSTEM_OVERLAY 类型，attrs.flags 设置为不接受输入事件 // attrs.type：TYPE_STATUS_BAR，mKeyguardHidden 为true 则设置 attrs.flags 清除 FLAG_SHOW_WALLPAPER mPolicy.adjustWindowParamsLw(attrs); &#125; //检查权限，并设置 标示位 mSystemUiVisibility // if they don't have the permission, mask out the status bar bits int systemUiVisibility = 0; if (attrs != null) &#123; systemUiVisibility = (attrs.systemUiVisibility|attrs.subtreeSystemUiVisibility); if ((systemUiVisibility &amp; StatusBarManager.DISABLE_MASK) != 0) &#123; if (!hasStatusBarPermission) &#123; systemUiVisibility &amp;= ~StatusBarManager.DISABLE_MASK; &#125; &#125; &#125; if (attrs != null &amp;&amp; seq == win.mSeq) &#123; win.mSystemUiVisibility = systemUiVisibility; &#125; //判断是否需要延迟销毁 winAnimator.mSurfaceDestroyDeferred = (flags&amp;WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY) != 0; int attrChanges = 0; int flagChanges = 0; if (attrs != null) &#123; if (win.mAttrs.type != attrs.type) &#123; throw new IllegalArgumentException( \"Window type can not be changed after the window is added.\"); &#125; flagChanges = win.mAttrs.flags ^= attrs.flags; attrChanges = win.mAttrs.copyFrom(attrs); if ((attrChanges &amp; (WindowManager.LayoutParams.LAYOUT_CHANGED | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) &#123; win.mLayoutNeeded = true; &#125; &#125; if (DEBUG_LAYOUT) Slog.v(TAG, \"Relayout \" + win + \": viewVisibility=\" + viewVisibility + \" req=\" + requestedWidth + \"x\" + requestedHeight + \" \" + win.mAttrs); win.mEnforceSizeCompat = (win.mAttrs.privateFlags &amp; PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0; //更新透明度信息 if ((attrChanges &amp; WindowManager.LayoutParams.ALPHA_CHANGED) != 0) &#123; winAnimator.mAlpha = attrs.alpha; &#125; final boolean scaledWindow = ((win.mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_SCALED) != 0); if (scaledWindow) &#123; // requested&#123;Width|Height&#125; Surface's physical size // attrs.&#123;width|height&#125; Size on screen win.mHScale = (attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f; win.mVScale = (attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f; &#125; else &#123; win.mHScale = win.mVScale = 1; &#125; boolean imMayMove = (flagChanges &amp; (FLAG_ALT_FOCUSABLE_IM | FLAG_NOT_FOCUSABLE)) != 0; final boolean isDefaultDisplay = win.isDefaultDisplay(); boolean focusMayChange = isDefaultDisplay &amp;&amp; (win.mViewVisibility != viewVisibility || ((flagChanges &amp; FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled)); boolean wallpaperMayMove = win.mViewVisibility != viewVisibility &amp;&amp; (win.mAttrs.flags &amp; FLAG_SHOW_WALLPAPER) != 0; wallpaperMayMove |= (flagChanges &amp; FLAG_SHOW_WALLPAPER) != 0; if ((flagChanges &amp; FLAG_SECURE) != 0 &amp;&amp; winAnimator.mSurfaceControl != null) &#123; winAnimator.mSurfaceControl.setSecure(isSecureLocked(win)); &#125; win.mRelayoutCalled = true; final int oldVisibility = win.mViewVisibility; win.mViewVisibility = viewVisibility; if (DEBUG_SCREEN_ON) &#123; RuntimeException stack = new RuntimeException(); stack.fillInStackTrace(); Slog.i(TAG, \"Relayout \" + win + \": oldVis=\" + oldVisibility + \" newVis=\" + viewVisibility, stack); &#125; 根据window可见性更新或创建Surface及启动动画效果(todo 后续动画系统再研究这边)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; toBeDisplayed = !win.isVisibleLw(); if (win.mExiting) &#123; winAnimator.cancelExitAnimationForNextAnimationLocked(); win.mExiting = false; &#125; if (win.mDestroying) &#123; win.mDestroying = false; mDestroySurface.remove(win); &#125; if (oldVisibility == View.GONE) &#123; winAnimator.mEnterAnimationPending = true; &#125; winAnimator.mEnteringAnimation = true; if (toBeDisplayed) &#123; if ((win.mAttrs.softInputMode &amp; SOFT_INPUT_MASK_ADJUST) == SOFT_INPUT_ADJUST_RESIZE) &#123; win.mLayoutNeeded = true; &#125; if (win.isDrawnLw() &amp;&amp; okToDisplay()) &#123; winAnimator.applyEnterAnimationLocked(); &#125; if ((win.mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) &#123; if (DEBUG_VISIBILITY) Slog.v(TAG, \"Relayout window turning screen on: \" + win); win.mTurnOnScreen = true; &#125; if (win.isConfigChanged()) &#123; if (DEBUG_CONFIGURATION) Slog.i(TAG, \"Window \" + win + \" visible with new config: \" + mCurConfiguration); outConfig.setTo(mCurConfiguration); &#125; &#125; if ((attrChanges&amp;WindowManager.LayoutParams.FORMAT_CHANGED) != 0) &#123; // If the format can be changed in place yaay! // If not, fall back to a surface re-build if (!winAnimator.tryChangeFormatInPlaceLocked()) &#123; winAnimator.destroySurfaceLocked(); toBeDisplayed = true; surfaceChanged = true; &#125; &#125; try &#123; if (!win.mHasSurface) &#123; surfaceChanged = true; &#125; SurfaceControl surfaceControl = winAnimator.createSurfaceLocked(); if (surfaceControl != null) &#123; outSurface.copyFrom(surfaceControl); if (SHOW_TRANSACTIONS) Slog.i(TAG, \" OUT SURFACE \" + outSurface + \": copied\"); &#125; else &#123; // For some reason there isn't a surface. Clear the // caller's object so they see the same state. outSurface.release(); &#125; &#125; catch (Exception e) &#123; mInputMonitor.updateInputWindowsLw(true /*force*/); Slog.w(TAG, \"Exception thrown when creating surface for client \" + client + \" (\" + win.mAttrs.getTitle() + \")\", e); Binder.restoreCallingIdentity(origId); return 0; &#125; if (toBeDisplayed) &#123; focusMayChange = isDefaultDisplay; &#125; if (win.mAttrs.type == TYPE_INPUT_METHOD &amp;&amp; mInputMethodWindow == null) &#123; mInputMethodWindow = win; imMayMove = true; &#125; if (win.mAttrs.type == TYPE_BASE_APPLICATION &amp;&amp; win.mAppToken != null &amp;&amp; win.mAppToken.startingWindow != null) &#123; // Special handling of starting window over the base // window of the app: propagate lock screen flags to it, // to provide the correct semantics while starting. final int mask = WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON; WindowManager.LayoutParams sa = win.mAppToken.startingWindow.mAttrs; sa.flags = (sa.flags&amp;~mask) | (win.mAttrs.flags&amp;mask); &#125;&#125; else &#123; winAnimator.mEnterAnimationPending = false; winAnimator.mEnteringAnimation = false; if (winAnimator.mSurfaceControl != null) &#123; if (DEBUG_VISIBILITY) Slog.i(TAG, \"Relayout invis \" + win + \": mExiting=\" + win.mExiting); // If we are not currently running the exit animation, we // need to see about starting one. if (!win.mExiting) &#123; surfaceChanged = true; // Try starting an animation; if there isn't one, we // can destroy the surface right away. int transit = WindowManagerPolicy.TRANSIT_EXIT; if (win.mAttrs.type == TYPE_APPLICATION_STARTING) &#123; transit = WindowManagerPolicy.TRANSIT_PREVIEW_DONE; &#125; if (win.isWinVisibleLw() &amp;&amp; winAnimator.applyAnimationLocked(transit, false)) &#123; focusMayChange = isDefaultDisplay; win.mExiting = true; &#125; else if (win.mWinAnimator.isAnimating()) &#123; // Currently in a hide animation... turn this into // an exit. win.mExiting = true; &#125; else if (win == mWallpaperTarget) &#123; // If the wallpaper is currently behind this // window, we need to change both of them inside // of a transaction to avoid artifacts. win.mExiting = true; win.mWinAnimator.mAnimating = true; &#125; else &#123; if (mInputMethodWindow == win) &#123; mInputMethodWindow = null; &#125; winAnimator.destroySurfaceLocked(); &#125; //TODO (multidisplay): Magnification is supported only for the default if (mAccessibilityController != null &amp;&amp; win.getDisplayId() == Display.DEFAULT_DISPLAY) &#123; mAccessibilityController.onWindowTransitionLocked(win, transit); &#125; &#125; &#125; outSurface.release(); if (DEBUG_VISIBILITY) Slog.i(TAG, \"Releasing surface in: \" + win);&#125; 更新窗口焦点、壁纸可见性以及屏幕旋转12345678910111213141516171819202122232425262728293031323334if (focusMayChange) &#123; //System.out.println(\"Focus may change: \" + win.mAttrs.getTitle()); if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/)) &#123; imMayMove = false; &#125; //System.out.println(\"Relayout \" + win + \": focus=\" + mCurrentFocus);&#125;//对输入法进行更新// updateFocusedWindowLocked() already assigned layers so we only need to// reassign them at this point if the IM window state gets shuffledif (imMayMove &amp;&amp; (moveInputMethodWindowsIfNeededLocked(false) || toBeDisplayed)) &#123; // Little hack here -- we -should- be able to rely on the // function to return true if the IME has moved and needs // its layer recomputed. However, if the IME was hidden // and isn't actually moved in the list, its layer may be // out of data so we make sure to recompute it. assignLayersLocked(win.getWindowList());&#125;//wallpaperMayMove 表示窗口以 wallpaper作为背景 典型的例子 launcher和homeif (wallpaperMayMove) &#123; getDefaultDisplayContentLocked().pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;&#125;//将窗口所在的 DisplayContent 标记为需要重新布局final DisplayContent displayContent = win.getDisplayContent();if (displayContent != null) &#123; displayContent.layoutNeeded = true;&#125;win.mGivenInsetsPending = (flags&amp;WindowManagerGlobal.RELAYOUT_INSETS_PENDING) != 0;configChanged = updateOrientationFromAppTokensLocked(false); 遍历所有的 DisplayContent 的所有窗口，为它们计算布局尺寸，并将布局尺寸设置给它们的surface12345678910performLayoutAndPlaceSurfacesLocked();if (toBeDisplayed &amp;&amp; win.mIsWallpaper) &#123; DisplayInfo displayInfo = getDefaultDisplayInfoLocked(); updateWallpaperOffsetLocked(win, displayInfo.logicalWidth, displayInfo.logicalHeight, false);&#125;if (win.mAppToken != null) &#123; win.mAppToken.updateReportedVisibilityLocked();&#125; 返回布局结果12345678910111213141516171819202122232425 outFrame.set(win.mCompatFrame); outOverscanInsets.set(win.mOverscanInsets); outContentInsets.set(win.mContentInsets); outVisibleInsets.set(win.mVisibleInsets); outStableInsets.set(win.mStableInsets); outOutsets.set(win.mOutsets); if (localLOGV) Slog.v( TAG, \"Relayout given client \" + client.asBinder() + \", requestedWidth=\" + requestedWidth + \", requestedHeight=\" + requestedHeight + \", viewVisibility=\" + viewVisibility + \"\\nRelayout returning frame=\" + outFrame + \", surface=\" + outSurface); if (localLOGV || DEBUG_FOCUS) Slog.v( TAG, \"Relayout of \" + win + \": focusMayChange=\" + focusMayChange); inTouchMode = mInTouchMode; mInputMonitor.updateInputWindowsLw(true /*force*/); if (DEBUG_LAYOUT) &#123; Slog.v(TAG, \"Relayout complete \" + win + \": outFrame=\" + outFrame.toShortString()); &#125;&#125; 向ams更新Configuration 因为屏幕可能旋转123if (configChanged) &#123; sendNewConfiguration();&#125; 布局子系统performLayoutAndPlaceSurfacesLocked12345678910private final void performLayoutAndPlaceSurfacesLocked() &#123; int loopCount = 6; do &#123; mTraversalScheduled = false; performLayoutAndPlaceSurfacesLockedLoop(); mH.removeMessages(H.DO_TRAVERSAL); loopCount--; &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0); mInnerFields.mWallpaperActionPending = false;&#125; performLayoutAndPlaceSurfacesLocked方法代码很短只有几行，但是在这之前我们需要搞清楚代码里面这个循环条件的含义，首先我们来关注下 mTraversalScheduled 变量，看看这个变量是做什么的： mTraversalScheduled 在循环开始的会将值置成false，当值为true的时候才能继续循环，所以在 performLayoutAndPlaceSurfacesLockedLoop 肯定对值进行了重新赋值，下面我们跟着 performLayoutAndPlaceSurfacesLockedLoop来继续跟踪。 performLayoutAndPlaceSurfacesLockedLoop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private final void performLayoutAndPlaceSurfacesLockedLoop() &#123; if (mInLayout) &#123; if (DEBUG) &#123; throw new RuntimeException(\"Recursive call!\"); &#125; Slog.w(TAG, \"performLayoutAndPlaceSurfacesLocked called while in layout. Callers=\" + Debug.getCallers(3)); return; &#125; if (mWaitingForConfig) &#123; // Our configuration has changed (most likely rotation), but we // don't yet have the complete configuration to report to // applications. Don't do any window layout until we have it. return; &#125; if (!mDisplayReady) &#123; // Not yet initialized, nothing to do. return; &#125; Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, \"wmLayout\"); mInLayout = true; //清理僵尸窗口 boolean recoveringMemory = false; if (!mForceRemoves.isEmpty()) &#123; recoveringMemory = true; // Wait a little bit for things to settle down, and off we go. while (!mForceRemoves.isEmpty()) &#123; WindowState ws = mForceRemoves.remove(0); Slog.i(TAG, \"Force removing: \" + ws); removeWindowInnerLocked(ws); &#125; Slog.w(TAG, \"Due to memory failure, waiting a bit for next layout\"); Object tmp = new Object(); synchronized (tmp) &#123; try &#123; tmp.wait(250); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; try &#123; //主要的布局逻辑 下面会对这个方法进行追踪 performLayoutAndPlaceSurfacesLockedInner(recoveringMemory); mInLayout = false; //needsLayout 前面 relayoutWindow 方法中 对 DispplayContent的mLayoutNeeded字段赋值 if (needsLayout()) &#123; //这边对 mTraversalScheduled 进行了赋值为true，同时也对次数进行了控制 if (++mLayoutRepeatCount &lt; 6) &#123; requestTraversalLocked(); &#125; else &#123; Slog.e(TAG, \"Performed 6 layouts in a row. Skipping\"); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; //通知监听者，窗口布局发生了变化 if (mWindowsChanged &amp;&amp; !mWindowChangeListeners.isEmpty()) &#123; mH.removeMessages(H.REPORT_WINDOWS_CHANGE); mH.sendEmptyMessage(H.REPORT_WINDOWS_CHANGE); &#125; &#125; catch (RuntimeException e) &#123; mInLayout = false; Slog.wtf(TAG, \"Unhandled exception while laying out windows\", e); &#125; Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER); &#125; performLayoutAndPlaceSurfacesLockedInner主要逻辑123456789布局前的预处理遍历所有 DisplayContent &#123; 遍历 DisplaContent 下所有的窗口&#123; 对窗口进行布局 &#125; 对布局结果进行检查，是否有必要重新对 DisplayContent 执行布局； 对 DisplayContent 的布局后处理；&#125;完成布局后的策略处理； 布局前的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// \"Something has changed! Let's make it correct now.\"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory) &#123; if (DEBUG_WINDOW_TRACE) &#123; Slog.v(TAG, \"performLayoutAndPlaceSurfacesLockedInner: entry. Called by \" + Debug.getCallers(3)); &#125; //更新处于焦点状态的窗口 int i; boolean updateInputWindowsNeeded = false; if (mFocusMayChange) &#123; mFocusMayChange = false; updateInputWindowsNeeded = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/); &#125; //将所有处于退出状态的tokens标记为不可见 // Initialize state of exiting tokens. final int numDisplays = mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx); for (i=displayContent.mExitingTokens.size()-1; i&gt;=0; i--) &#123; displayContent.mExitingTokens.get(i).hasVisible = false; &#125; &#125; for (int stackNdx = mStackIdToStack.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; // Initialize state of exiting applications. final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens; for (int tokenNdx = exitingAppTokens.size() - 1; tokenNdx &gt;= 0; --tokenNdx) &#123; exitingAppTokens.get(tokenNdx).hasVisible = false; &#125; &#125; //初始化 mInnerFields 中的状态变量 这些在后面的布局后处理中会使用到 mInnerFields.mHoldScreen = null; mInnerFields.mScreenBrightness = -1; mInnerFields.mButtonBrightness = -1; mInnerFields.mUserActivityTimeout = -1; mInnerFields.mObscureApplicationContentOnSecondaryDisplays = false; //递增布局序号，wns每进行一次布局都会导致序号递增 AppWindowToken 中也保存了一个相应的布局序号，在布局过程中，wms通过对比这两个序号的值以确定 AppWindowToken 的布局状态是否最新。 mTransactionSequence++; //获取手机屏幕的宽高尺寸，这个尺寸将用来布局水印和StrictMode的红色警告框 final DisplayContent defaultDisplay = getDefaultDisplayContentLocked(); final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo(); final int defaultDw = defaultInfo.logicalWidth; final int defaultDh = defaultInfo.logicalHeight; if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG, \"&gt;&gt;&gt; OPEN TRANSACTION performLayoutAndPlaceSurfaces\"); SurfaceControl.openTransaction(); try &#123; //布局水印 if (mWatermark != null) &#123; mWatermark.positionSurface(defaultDw, defaultDh); &#125; //布局StrictMode的红色警告框 if (mStrictModeFlash != null) &#123; mStrictModeFlash.positionSurface(defaultDw, defaultDh); &#125; if (mCircularDisplayMask != null) &#123; mCircularDisplayMask.positionSurface(defaultDw, defaultDh, mRotation); &#125; if (mEmulatorDisplayOverlay != null) &#123; mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mRotation); &#125; 布局 DisplayContent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 boolean focusDisplayed = false; //遍历 DisplayContent 列表 for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx); boolean updateAllDrawn = false; //获取 displayContent 下的 窗口列表 WindowList windows = displayContent.getWindowList(); DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int displayId = displayContent.getDisplayId(); //当前 displayContent 所描述显示屏的逻辑尺寸 final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; //当前显示屏用于显示应用程序的区域尺寸。逻辑尺寸-系统装饰尺寸（状态栏 导航栏） final int innerDw = displayInfo.appWidth; final int innerDh = displayInfo.appHeight; //用来标识是否是默认的 displayContent（也就是手机屏幕），手机屏幕拥有状态栏、导航栏、并应输入事件，而其他屏幕没有这些特性。 final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY); //重置 display 的参数 // Reset for each display. mInnerFields.mDisplayHasContent = false; mInnerFields.mPreferredRefreshRate = 0; mInnerFields.mPreferredModeId = 0; int repeats = 0; do &#123; repeats++; //限制最多尝试次数 if (repeats &gt; 6) &#123; Slog.w(TAG, \"Animation repeat aborted after too many iterations\"); displayContent.layoutNeeded = false; break; &#125; if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats(\"On entry to LockedInner\", displayContent.pendingLayoutChanges); // pendingLayoutChanges 含有 FINISH_LAYOUT_REDO_WALLPAPER 的处理 if ((displayContent.pendingLayoutChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 &amp;&amp; adjustWallpaperWindowsLocked()) &#123; assignLayersLocked(windows); displayContent.layoutNeeded = true; &#125; // pendingLayoutChanges 含有 FINISH_LAYOUT_REDO_CONFIG 的处理 if (isDefaultDisplay &amp;&amp; (displayContent.pendingLayoutChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) &#123; if (DEBUG_LAYOUT) Slog.v(TAG, \"Computing new config from layout\"); if (updateOrientationFromAppTokensLocked(true)) &#123; displayContent.layoutNeeded = true; mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION); &#125; &#125; // pendingLayoutChanges 含有 FINISH_LAYOUT_REDO_LAYOUT 的处理 if ((displayContent.pendingLayoutChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) &#123; displayContent.layoutNeeded = true; &#125; // FIRST LOOP: Perform a layout, if needed. if (repeats &lt; 4) &#123; //完成对 displayContent 的所有窗口的布局工作 下一个章节分析的重点 performLayoutLockedInner(displayContent, repeats == 1, false /*updateInputWindows*/); &#125; else &#123; Slog.w(TAG, \"Layout repeat skipped after too many iterations\"); &#125; //清空 pendingLayoutChanges 字段 // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think // it is animating. displayContent.pendingLayoutChanges = 0; //PhoneWindowManager 来检查布局（结果检查） if (isDefaultDisplay) &#123;//检查内容：状态栏 导航栏可见性是否与顶层窗口的属性冲突，是否需要解除锁屏状态等 mPolicy.beginPostLayoutPolicyLw(dw, dh); for (i = windows.size() - 1; i &gt;= 0; i--) &#123; WindowState w = windows.get(i); if (w.mHasSurface) &#123; mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow); &#125; &#125; //布局结果保存到 pendingLayoutChanges 字段 displayContent.pendingLayoutChanges |= mPolicy.finishPostLayoutPolicyLw(); if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats( \"after finishPostLayoutPolicyLw\", displayContent.pendingLayoutChanges); &#125; //通过 pendingLayoutChanges 来判断是否需要重新检测 &#125; while (displayContent.pendingLayoutChanges != 0); performLayoutLockedInner123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190 public final void performLayoutLockedInner(final DisplayContent displayContent, boolean initial, boolean updateInputWindows) &#123;Log.i(TAG, \"performLayoutLockedInner-&gt;displayContent:\" + displayContent);//if(displayContent.getDisplayId() != 0 &amp;&amp; isShowDualScreen())&#123;// return;//&#125; //layoutNeeded为true才执行布局操作 if (!displayContent.layoutNeeded) &#123; return; &#125; displayContent.layoutNeeded = false; WindowList windows = displayContent.getWindowList(); //获取是否是手机屏幕参数 boolean isDefaultDisplay = displayContent.isDefaultDisplay; //获取屏幕的信息 DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; if (mInputConsumer != null) &#123; mInputConsumer.layout(dw, dh); &#125; final int N = windows.size(); int i; if (DEBUG_LAYOUT) &#123; Slog.v(TAG, \"-------------------------------------\"); Slog.v(TAG, \"performLayout: needed=\" + displayContent.layoutNeeded + \" dw=\" + dw + \" dh=\" + dh); &#125; //通知 PhoneWindowManager 开始布局准备 mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mRotation); if (isDefaultDisplay) &#123; mSystemDecorLayer = mPolicy.getSystemDecorLayerLw(); mScreenRect.set(0, 0, dw, dh); &#125; mPolicy.getContentRectLw(mTmpContentRect); displayContent.resize(mTmpContentRect); int seq = mLayoutSeq+1; if (seq &lt; 0) seq = 0; mLayoutSeq = seq; boolean behindDream = false; //只是第一个非顶级窗口所在的index,用于节省查找时间 // First perform layout of any root windows (not attached // to another window). int topAttached = -1; //对顶级窗口进行布局 for (i = N-1; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); //获取当前窗口是否可见 // Don't do layout of a window if it is not visible, or // soon won't be visible, to avoid wasting time and funky // changes while a window is animating away. final boolean gone = (behindDream &amp;&amp; mPolicy.canBeForceHidden(win, win.mAttrs)) || win.isGoneForLayoutLw(); if (DEBUG_LAYOUT &amp;&amp; !win.mLayoutAttached) &#123; Slog.v(TAG, \"1ST PASS \" + win + \": gone=\" + gone + \" mHaveFrame=\" + win.mHaveFrame + \" mLayoutAttached=\" + win.mLayoutAttached + \" screen changed=\" + win.isConfigChanged()); final AppWindowToken atoken = win.mAppToken; if (gone) Slog.v(TAG, \" GONE: mViewVisibility=\" + win.mViewVisibility + \" mRelayoutCalled=\" + win.mRelayoutCalled + \" hidden=\" + win.mRootToken.hidden + \" hiddenRequested=\" + (atoken != null &amp;&amp; atoken.hiddenRequested) + \" mAttachedHidden=\" + win.mAttachedHidden); else Slog.v(TAG, \" VIS: mViewVisibility=\" + win.mViewVisibility + \" mRelayoutCalled=\" + win.mRelayoutCalled + \" hidden=\" + win.mRootToken.hidden + \" hiddenRequested=\" + (atoken != null &amp;&amp; atoken.hiddenRequested) + \" mAttachedHidden=\" + win.mAttachedHidden); &#125; //不可见则跳过 // If this view is GONE, then skip it -- keep the current // frame, and let the caller know so they can ignore it // if they want. (We do the normal layout for INVISIBLE // windows, since that means \"perform layout as normal, // just don't display\"). if (!gone || !win.mHaveFrame || win.mLayoutNeeded || ((win.isConfigChanged() || win.setInsetsChanged()) &amp;&amp; ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0 || (win.mHasSurface &amp;&amp; win.mAppToken != null &amp;&amp; win.mAppToken.layoutConfigChanges)))) &#123; if (!win.mLayoutAttached) &#123; //这边只对顶级窗口进行布局处理 if (initial) &#123; //Slog.i(TAG, \"Window \" + this + \" clearing mContentChanged - initial\"); win.mContentChanged = false; &#125; if (win.mAttrs.type == TYPE_DREAM) &#123; // Don't layout windows behind a dream, so that if it // does stuff like hide the status bar we won't get a // bad transition when it goes away. behindDream = true; &#125; win.mLayoutNeeded = false; //通知窗体准备布局 win.prelayout(); //mPolicy.layoutWindowLw(win, null); DisplayInfo defaultDisplayInfo = getDefaultDisplayInfoLocked(); //调用 PhoneWindowManager 的 layoutWindowLw 开始布局 mPolicy.layoutWindowLw(win ,null ,defaultDisplayInfo.logicalWidth,defaultDisplayInfo.logicalHeight); //更新窗口的布局版本号 win.mLayoutSeq = seq; if (DEBUG_LAYOUT) Slog.v(TAG, \" LAYOUT: mFrame=\" + win.mFrame + \" mContainingFrame=\" + win.mContainingFrame + \" mDisplayFrame=\" + win.mDisplayFrame); &#125; else &#123; //当前窗口不是顶级窗口，则记录下这个位置，以便于后面快速定位到这里开始（这边只会记录下 第一个遇到的非顶级窗口） if (topAttached &lt; 0) topAttached = i; &#125; &#125; &#125; boolean attachedBehindDream = false; //处理非顶级窗口（这边的处理历程和上面的顶级窗口的类似） // Now perform layout of attached windows, which usually // depend on the position of the window they are attached to. // XXX does not deal with windows that are attached to windows // that are themselves attached. for (i = topAttached; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); if (win.mLayoutAttached) &#123; if (DEBUG_LAYOUT) Slog.v(TAG, \"2ND PASS \" + win + \" mHaveFrame=\" + win.mHaveFrame + \" mViewVisibility=\" + win.mViewVisibility + \" mRelayoutCalled=\" + win.mRelayoutCalled); // If this view is GONE, then skip it -- keep the current // frame, and let the caller know so they can ignore it // if they want. (We do the normal layout for INVISIBLE // windows, since that means \"perform layout as normal, // just don't display\"). if (attachedBehindDream &amp;&amp; mPolicy.canBeForceHidden(win, win.mAttrs)) &#123; continue; &#125; if ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled) || !win.mHaveFrame || win.mLayoutNeeded) &#123; if (initial) &#123; //Slog.i(TAG, \"Window \" + this + \" clearing mContentChanged - initial\"); win.mContentChanged = false; &#125; win.mLayoutNeeded = false; win.prelayout(); //mPolicy.layoutWindowLw(win, win.mAttachedWindow); DisplayInfo defaultDisplayInfo = getDefaultDisplayInfoLocked(); //更新布局 mPolicy.layoutWindowLw(win, win.mAttachedWindow,defaultDisplayInfo.logicalWidth,defaultDisplayInfo.logicalHeight); // mPolicy.layoutWindowLw(win, null, defaultDisplayInfo.logicalWidth,defaultDisplayInfo.logicalHeight); win.mLayoutSeq = seq; if (DEBUG_LAYOUT) Slog.v(TAG, \" LAYOUT: mFrame=\" + win.mFrame + \" mContainingFrame=\" + win.mContainingFrame + \" mDisplayFrame=\" + win.mDisplayFrame); &#125; &#125; else if (win.mAttrs.type == TYPE_DREAM) &#123; // Don't layout windows behind a dream, so that if it // does stuff like hide the status bar we won't get a // bad transition when it goes away. attachedBehindDream = behindDream; &#125; &#125; //布局后窗口的大小和位置可能改变了，所以需要设置需要更新标识 // Window frames may have changed. Tell the input dispatcher about it. mInputMonitor.setUpdateInputWindowsNeededLw(); if (updateInputWindows) &#123; mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; //通知布局完成 mPolicy.finishLayoutLw(); &#125; PhoneWindowManager 的 beginLayoutLw 方法这个方法为布局准备了一些用到的参数，这些参数描述了屏幕上的8个矩形区域，这8个区域构成了 PhoneWindowManager 布局窗口的准绳。 描述整个屏幕的逻辑显示区域 mUnrestrictedScreenLeft mUnrestrictedScreenTop mUnrestrictedScreenWidth mUnrestrictedScreenHeight 描述了屏幕除去导航栏之后的区域，导航栏不可见的时候，跟上面的值是相等的 mRestrictedScreenLeft mRestrictedScreenTop mRestrictedScreenWidth mRestrictedScreenHeight 描述整个屏幕的逻辑显示区域 mStableFullscreenLeft mStableFullscreenTop mStableFullscreenRight mStableFullscreenBottom 描述排除状态栏和导航栏之外的区域。并且不受可见性影响 mStableLeft mStableTop mStableRight mStableBottom StableFull和Stable不直接参与窗口的布局过程。只是为了提供一个不受可见性影响的显示区域大小和位置 Dock区域用来描述可用来放置停靠窗口的区域。停靠指的是显示在屏幕某一侧的半屏窗口。Dock区域主要用途是用来作为输入法窗口的布局容器。 mDockLeft mDockTop mDockRight mDockBottom 描述屏幕中排除状态栏、导航栏、输入法后的显示区域。 mContentLeft mContentTop mContentRight mContentBottom 与 Content 区域一样，大部分情况下，大部分情况下，cur区域与Content区域是相同的。 mCurLeft mCurTop mCurRight mCurBottom cur区域与Content区域和别的区域计算的方法不一样，这两个的区域不是在 beginLayoutLw 中被确定下来。因为这两个区域受输入法窗口尺寸的影响，所以需要在输入法窗口完成布局后，在 offsetInputMethodWindowLw 方法中得到最终的位置。在此之前，它们与Dock区域是一样的。 与Dock区域绝大多数情况是相同的。状态栏和导航栏的可见性发生变化时会有一个淡入淡出的动画效果，这两个区域在这个过程中是不一致的。Dock认为这时候，导航栏和状态栏是可见的，system则认为是不可见的。 mSystemLeft mSystemTop mSystemRight mSystemBottom 上面这些值可以使用dumpsys window来查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677WINDOW MANAGER POLICY STATE (dumpsys window policy) mSafeMode=false mSystemReady=true mSystemBooted=true mLidState=-1 mLidOpenRotation=-1 mCameraLensCoverState=-1 mHdmiPlugged=false mLastSystemUiFlags=0x8600 mResettingSystemUiFlags=0x0 mForceClearedSystemUiFlags=0x0 mWakeGestureEnabledSetting=true mSupportAutoRotation=true mUiMode=1 mDockMode=0 mCarDockRotation=-1 mDeskDockRotation=-1 mUserRotationMode=0 mUserRotation=0 mAllowAllRotations=0 mCurrentAppOrientation=-1 mCarDockEnablesAccelerometer=true mDeskDockEnablesAccelerometer=true mLidKeyboardAccessibility=0 mLidNavigationAccessibility=0 mLidControlsSleep=false mShortPressOnPowerBehavior=1 mLongPressOnPowerBehavior=1 mDoublePressOnPowerBehavior=0 mTriplePressOnPowerBehavior=0 mHasSoftInput=true mAwake=true mScreenOnEarly=true mScreenOnFully=true mKeyguardDrawComplete=true mWindowManagerDrawComplete=true mOrientationSensorEnabled=true mOverscanScreen=(0,0) 1080x1920 mRestrictedOverscanScreen=(0,0) 1080x1794 mUnrestrictedScreen=(0,0) 1080x1920 mRestrictedScreen=(0,0) 1080x1794 mStableFullscreen=(0,0)-(1080,1794) mStable=(0,63)-(1080,1794) mSystem=(0,0)-(1080,1920) mCur=(0,63)-(1080,1794) mContent=(0,63)-(1080,1794) mVoiceContent=(0,63)-(1080,1794) mDock=(0,63)-(1080,1794) mDockLayer=268435456 mStatusBarLayer=161000 mShowingLockscreen=false mShowingDream=false mDreamingLockscreen=false mDreamingSleepToken=null mStatusBar=Window&#123;285e842 u0 StatusBar&#125; isStatusBarKeyguard=false mNavigationBar=Window&#123;7e294a7 u0 NavigationBar&#125; mFocusedWindow=Window&#123;f3be5be u0 com.newland.kotlindagger2/com.newland.kotlindagger2.MainActivity&#125; mFocusedApp=Token&#123;2ecfac5 ActivityRecord&#123;c866d3c u0 com.newland.kotlindagger2/.MainActivity t204&#125;&#125; mTopFullscreenOpaqueWindowState=Window&#123;f3be5be u0 com.newland.kotlindagger2/com.newland.kotlindagger2.MainActivity&#125; mTopFullscreenOpaqueOrDimmingWindowState=Window&#123;f3be5be u0 com.newland.kotlindagger2/com.newland.kotlindagger2.MainActivity&#125; mTopIsFullscreen=false mHideLockScreen=false mForceStatusBar=false mForceStatusBarFromKeyguard=false mDismissKeyguard=0 mWinDismissingKeyguard=null mHomePressed=false mAllowLockscreenWhenOn=false mLockScreenTimeout=60000 mLockScreenTimerActive=false mEndcallBehavior=2 mIncallPowerBehavior=1 mLongPressOnHomeBehavior=0 mLandscapeRotation=1 mSeascapeRotation=3 mPortraitRotation=0 mUpsideDownRotation=2 mDemoHdmiRotation=1 mDemoHdmiRotationLock=false mUndockedHdmiRotation=-1 mKeyMapping.size=0 BarController.StatusBar mState=WINDOW_STATE_SHOWING mTransientBar=TRANSIENT_BAR_NONE BarController.NavigationBar mState=WINDOW_STATE_SHOWING mTransientBar=TRANSIENT_BAR_NONE PolicyControl.sImmersiveStatusFilter=null PolicyControl.sImmersiveNavigationFilter=null PolicyControl.sImmersivePreconfirmationsFilter=null WakeGestureListener mTriggerRequested=false mSensor=null WindowOrientationListener mEnabled=true mCurrentRotation=0 mSensor=&#123;Sensor name=&quot;Goldfish 3-axis Accelerometer&quot;, vendor=&quot;The Android Open Source Project&quot;, version=1, type=1, maxRange=2.8, resolution=2.480159E-4, power=3.0, minDelay=10000&#125; mRate=2 mProposedRotation=0 mPredictedRotation=0 mLastFilteredX=0.0 mLastFilteredY=9.77631 mLastFilteredZ=0.812348 mLastFilteredTimestampNanos=72661454232816 (4.412ms ago) mTiltHistory=&#123;last: 5.0&#125; mFlat=false mSwinging=false mAccelerating=false mOverhead=false mTouched=false mTiltToleranceConfig=[[-25, 70], [-25, 65], [-25, 60], [-25, 65]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation) &#123; final int overscanLeft, overscanTop, overscanRight, overscanBottom; if (isDefaultDisplay) &#123; switch (displayRotation) &#123; case Surface.ROTATION_90: overscanLeft = mOverscanTop; overscanTop = mOverscanRight; overscanRight = mOverscanBottom; overscanBottom = mOverscanLeft; break; case Surface.ROTATION_180: overscanLeft = mOverscanRight; overscanTop = mOverscanBottom; overscanRight = mOverscanLeft; overscanBottom = mOverscanTop; break; case Surface.ROTATION_270: overscanLeft = mOverscanBottom; overscanTop = mOverscanLeft; overscanRight = mOverscanTop; overscanBottom = mOverscanRight; break; default: overscanLeft = mOverscanLeft; overscanTop = mOverscanTop; overscanRight = mOverscanRight; overscanBottom = mOverscanBottom; break; &#125; &#125; else &#123; overscanLeft = 0; overscanTop = 0; overscanRight = 0; overscanBottom = 0; &#125; mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0; mOverscanScreenTop = mRestrictedOverscanScreenTop = 0; mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth; mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight; mSystemLeft = 0; mSystemTop = 0; mSystemRight = displayWidth; mSystemBottom = displayHeight; mUnrestrictedScreenLeft = overscanLeft; mUnrestrictedScreenTop = overscanTop; mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight; mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom; mRestrictedScreenLeft = mUnrestrictedScreenLeft; mRestrictedScreenTop = mUnrestrictedScreenTop; mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth; mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight; mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft; mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop; mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight; mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom; mDockLayer = 0x10000000; mStatusBarLayer = -1; // start with the current dock rect, which will be (0,0,displayWidth,displayHeight) final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; pf.left = df.left = of.left = vf.left = mDockLeft; pf.top = df.top = of.top = vf.top = mDockTop; pf.right = df.right = of.right = vf.right = mDockRight; pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom; dcf.setEmpty(); // Decor frame N/A for system bars. if (isDefaultDisplay) &#123; // For purposes of putting out fake window up to steal focus, we will // drive nav being hidden only by whether it is requested. final int sysui = mLastSystemUiFlags; boolean navVisible = (sysui &amp; View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0; boolean navTranslucent = (sysui &amp; (View.NAVIGATION_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0; boolean immersive = (sysui &amp; View.SYSTEM_UI_FLAG_IMMERSIVE) != 0; boolean immersiveSticky = (sysui &amp; View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0; boolean navAllowedHidden = immersive || immersiveSticky; navTranslucent &amp;= !immersiveSticky; // transient trumps translucent boolean isKeyguardShowing = isStatusBarKeyguard() &amp;&amp; !mHideLockScreen; if (!isKeyguardShowing) &#123; navTranslucent &amp;= areTranslucentBarsAllowed(); &#125; // When the navigation bar isn't visible, we put up a fake // input window to catch all touch events. This way we can // detect when the user presses anywhere to bring back the nav // bar and ensure the application doesn't see the event. if (navVisible || navAllowedHidden) &#123; if (mHideNavFakeWindow != null) &#123; mHideNavFakeWindow.dismiss(); mHideNavFakeWindow = null; &#125; &#125; else if (mHideNavFakeWindow == null) &#123; mHideNavFakeWindow = mWindowManagerFuncs.addFakeWindow( mHandler.getLooper(), mHideNavInputEventReceiverFactory, \"hidden nav\", WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER, 0, 0, false, false, true); &#125; // For purposes of positioning and showing the nav bar, if we have // decided that it can't be hidden (because of the screen aspect ratio), // then take that into account. navVisible |= !canHideNavigationBar(); if((mLastSystemUiFlags &amp; View.SYSTEM_UI_FLAG_SHOW_FULLSCREEN) != 0)&#123; navVisible = false; &#125; boolean updateSysUiVisibility = false; if (mNavigationBar != null) &#123; boolean transientNavBarShowing = mNavigationBarController.isTransientShowing(); // Force the navigation bar to its appropriate place and // size. We need to do this directly, instead of relying on // it to bubble up from the nav bar, because this needs to // change atomically with screen rotations. mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth &lt; displayHeight); if (mNavigationBarOnBottom) &#123; // It's a system nav bar or a portrait screen; nav bar goes on bottom. int top = displayHeight - overscanBottom - mNavigationBarHeightForRotation[displayRotation]; mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom); mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top; if (transientNavBarShowing) &#123; mNavigationBarController.setBarShowingLw(true); &#125; else if (navVisible) &#123; mNavigationBarController.setBarShowingLw(true); mDockBottom = mTmpNavigationFrame.top; mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop; mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop; &#125; else &#123; // We currently want to hide the navigation UI. mNavigationBarController.setBarShowingLw(false); &#125; if (navVisible &amp;&amp; !navTranslucent &amp;&amp; !navAllowedHidden &amp;&amp; !mNavigationBar.isAnimatingLw() &amp;&amp; !mNavigationBarController.wasRecentlyTranslucent()) &#123; // If the opaque nav bar is currently requested to be visible, // and not in the process of animating on or off, then // we can tell the app that it is covered by it. mSystemBottom = mTmpNavigationFrame.top; &#125; &#125; else &#123; // Landscape screen; nav bar goes to the right. int left = displayWidth - overscanRight - mNavigationBarWidthForRotation[displayRotation]; mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight); mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left; if (transientNavBarShowing) &#123; mNavigationBarController.setBarShowingLw(true); &#125; else if (navVisible) &#123; mNavigationBarController.setBarShowingLw(true); mDockRight = mTmpNavigationFrame.left; mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft; mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft; &#125; else &#123; // We currently want to hide the navigation UI. mNavigationBarController.setBarShowingLw(false); &#125; if (navVisible &amp;&amp; !navTranslucent &amp;&amp; !mNavigationBar.isAnimatingLw() &amp;&amp; !mNavigationBarController.wasRecentlyTranslucent()) &#123; // If the nav bar is currently requested to be visible, // and not in the process of animating on or off, then // we can tell the app that it is covered by it. mSystemRight = mTmpNavigationFrame.left; &#125; &#125; // Make sure the content and current rectangles are updated to // account for the restrictions from the navigation bar. mContentTop = mVoiceContentTop = mCurTop = mDockTop; mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom; mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft; mContentRight = mVoiceContentRight = mCurRight = mDockRight; mStatusBarLayer = mNavigationBar.getSurfaceLayer(); // And compute the final frame. mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame); if (DEBUG_LAYOUT) Slog.i(TAG, \"mNavigationBar frame: \" + mTmpNavigationFrame); if (mNavigationBarController.checkHiddenLw()) &#123; updateSysUiVisibility = true; &#125; &#125; if (DEBUG_LAYOUT) Slog.i(TAG, String.format(\"mDock rect: (%d,%d - %d,%d)\", mDockLeft, mDockTop, mDockRight, mDockBottom)); // decide where the status bar goes ahead of time if (mStatusBar != null) &#123; // apply any navigation bar insets pf.left = df.left = of.left = mUnrestrictedScreenLeft; pf.top = df.top = of.top = mUnrestrictedScreenTop; pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft; pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop; vf.left = mStableLeft; vf.top = mStableTop; vf.right = mStableRight; vf.bottom = mStableBottom; mStatusBarLayer = mStatusBar.getSurfaceLayer(); // Let the status bar determine its size. mStatusBar.computeFrameLw(pf, df, vf, vf, vf, dcf, vf); // For layout, the status bar is always at the top with our fixed height. mStableTop = mUnrestrictedScreenTop + mStatusBarHeight; boolean statusBarTransient = (sysui &amp; View.STATUS_BAR_TRANSIENT) != 0; boolean statusBarTranslucent = (sysui &amp; (View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0; if (!isKeyguardShowing) &#123; statusBarTranslucent &amp;= areTranslucentBarsAllowed(); &#125; // If the status bar is hidden, we don't want to cause // windows behind it to scroll. if (mStatusBar.isVisibleLw() &amp;&amp; !statusBarTransient) &#123; // Status bar may go away, so the screen area it occupies // is available to apps but just covering them when the // status bar is visible. mDockTop = mUnrestrictedScreenTop + mStatusBarHeight; mContentTop = mVoiceContentTop = mCurTop = mDockTop; mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom; mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft; mContentRight = mVoiceContentRight = mCurRight = mDockRight; if (DEBUG_LAYOUT) Slog.v(TAG, \"Status bar: \" + String.format( \"dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]\", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom)); &#125; if (mStatusBar.isVisibleLw() &amp;&amp; !mStatusBar.isAnimatingLw() &amp;&amp; !statusBarTransient &amp;&amp; !statusBarTranslucent &amp;&amp; !mStatusBarController.wasRecentlyTranslucent()) &#123; // If the opaque status bar is currently requested to be visible, // and not in the process of animating on or off, then // we can tell the app that it is covered by it. mSystemTop = mUnrestrictedScreenTop + mStatusBarHeight; &#125; if (mStatusBarController.checkHiddenLw()) &#123; updateSysUiVisibility = true; &#125; &#125; if (updateSysUiVisibility) &#123; updateSystemUiVisibilityLw(); &#125; &#125;&#125; PhoneWindowManager 的 layoutWindowLw 方法layoutWindowLw 使用上面那些布局参数来确定一个窗口的位置和尺寸。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** &#123;@inheritDoc&#125; */ @Override public void layoutWindowLw(WindowState win, WindowState attached) &#123; //状态栏和导航栏不再被布局。因为这两个在 beginLayoutLw 方法中计算布局参数时完成 // We've already done the navigation bar and status bar. If the status bar can receive // input, we need to layout it again to accomodate for the IME window. if ((win == mStatusBar &amp;&amp; !canReceiveInput(win)) || win == mNavigationBar) &#123; return; &#125; final WindowManager.LayoutParams attrs = win.getAttrs(); final boolean isDefaultDisplay = win.isDefaultDisplay(); final boolean needsToOffsetInputMethodTarget = isDefaultDisplay &amp;&amp; (win == mLastInputMethodTargetWindow &amp;&amp; mLastInputMethodWindow != null); if (needsToOffsetInputMethodTarget) &#123; if (DEBUG_LAYOUT) Slog.i(TAG, \"Offset ime target window by the last ime window state\"); offsetInputMethodWindowLw(mLastInputMethodWindow); &#125; final int fl = PolicyControl.getWindowFlags(win, attrs); final int sim = attrs.softInputMode; final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null); //提供这四个矩形变量作为缓存，后续的计算中会更新这四个矩形内容 final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect cf = mTmpContentFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; final Rect sf = mTmpStableFrame; //下面是做这些内容的更新...... //将计算好的矩形交给windowstate,有窗口自己计算自己的布局结果 win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf); //完成输入法窗口布局后需要更新 content 和 cur 区域就是在这里完成的 // Dock windows carve out the bottom of the screen, so normal windows // can't appear underneath them. if (attrs.type == TYPE_INPUT_METHOD &amp;&amp; win.isVisibleOrBehindKeyguardLw() &amp;&amp; !win.getGivenInsetsPendingLw()) &#123; setLastInputMethodWindowLw(null, null); offsetInputMethodWindowLw(win); &#125; if (attrs.type == TYPE_VOICE_INTERACTION &amp;&amp; win.isVisibleOrBehindKeyguardLw() &amp;&amp; !win.getGivenInsetsPendingLw()) &#123; offsetVoiceInputWindowLw(win); &#125; &#125; WindowState 的 computeFrameLw 方法该方法的产出 mFrame:描述窗口的位置和尺寸 12345678910111213141516 /** * * @param pf 描述放置窗口的位置和尺寸 LayoutParam 中的x,y,width,height以及gravity等都是相对pf进行计算的。根据窗口类型和flag不同，pf可能是 Restricted Unrestricted Dock Content。 * @param df 用来限定窗口的最终位置。当窗口通过pf完成位置和尺寸的计算后，需要通过df再进行一次校正，必须完成位于df之内。 绝大部分情况和pf保持一致。 * @param of * @param cf cf不会直接影响窗口布局位置和尺寸，但是影响到窗口内容的绘制。cf表示当前屏幕排除所有系统窗口（状态 导航 输入法）后所留下的矩形区域。根据 LayoutParams.softInputMode以及flag取值不同可能是 Content Dock Restricted * @param vf 跟cf一样，表示不被任何系统串口所遮挡的一块矩形区域。根据 LayoutParams.softInputMode 的取值选择与cf保持一致，或者选择cur区域。 * @param dcf * @param sf * @param osf */ @Override public void computeFrameLw(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf, Rect osf) &#123;&#125; 布局后处理动画子系统","categories":[],"tags":[]},{"title":"SELinux","slug":"SELinux","date":"2018-07-05T09:55:37.000Z","updated":"2018-07-05T09:55:37.808Z","comments":true,"path":"2018/07/05/SELinux/","link":"","permalink":"http://yoursite.com/2018/07/05/SELinux/","excerpt":"","text":"SELinux模式三种模式 disabled：关闭状态，不加载任何策略，仅执行默认的DAC permissive：宽容模式，策略会被加载，对象的访问也会被检查，但是对访问的拒绝仅会做记录而不会实际执行 enforcing：强制模式，安全策略会被加载并执行，违反策略的行为也会被记录 查看和修改模式的命令getenforce:查看模式setenforce 0:设置模式，但是设置的模式在重启后会被还原为默认的模式 安全上下文安全上下文是由分号分割的四个域组成的字符串： 用户名：一般与一组或者一类用户相关，比如user_u代表特权用户，admin_u代表管理员 角色 类型 可选的MLS安全范围 下面我们来看下进程的安全上下文信息，执行命令 ps -Z 1234567891011121314151617181920212223242526272829303132u:r:init:s0 root 1 0 /initu:r:kernel:s0 root 2 0 kthreaddu:r:kernel:s0 root 3 2 ksoftirqd/0u:r:kernel:s0 root 5 2 kworker/0:0Hu:r:fingerprintd:s0 system 1369 1 /system/bin/fingerprintdu:r:system_server:s0 system 1633 1362 system_serveru:r:sdcardd:s0 media_rw 1724 1251 /system/bin/sdcardu:r:platform_app:s0:c512,c768 u0_a15 1762 1362 com.android.systemuiu:r:kernel:s0 root 1792 2 kworker/1:1Hu:r:sdcardd:s0 media_rw 1799 1251 /system/bin/sdcardu:r:untrusted_app:s0:c512,c768 u0_a16 1953 1362 com.google.android.googlequicksearchbox:interactoru:r:untrusted_app:s0:c512,c768 u0_a36 1966 1362 com.android.inputmethod.latinu:r:untrusted_app:s0:c512,c768 u0_a8 1986 1362 com.google.android.gms.persistentu:r:radio:s0 radio 2005 1362 com.android.phoneu:r:untrusted_app:s0:c512,c768 u0_a9 2019 1362 com.android.launcher3u:r:untrusted_app:s0:c512,c768 u0_a8 2403 1362 com.google.android.gmsu:r:platform_app:s0:c512,c768 u0_a4 3056 1362 com.android.defcontaineru:r:untrusted_app:s0:c512,c768 u0_a26 3168 1362 com.android.deskclocku:r:untrusted_app:s0:c512,c768 u0_a16 3660 1362 com.google.android.googlequicksearchbox:searchu:r:platform_app:s0:c512,c768 u0_a52 4015 1362 com.android.messagingu:r:kernel:s0 root 6498 2 kworker/2:1u:r:kernel:s0 root 11069 2 kworker/1:0u:r:untrusted_app:s0:c512,c768 u0_a46 11659 1362 com.svox.picou:r:untrusted_app:s0:c512,c768 u0_a8 13011 1362 com.google.process.gappsu:r:untrusted_app:s0:c512,c768 u0_a8 13063 1362 com.google.android.gms.unstableu:r:kernel:s0 root 13770 2 kworker/0:2u:r:kernel:s0 root 13783 2 kworker/1:1u:r:su:s0 root 13791 1307 /system/bin/shu:r:untrusted_app:s0:c512,c768 u0_a22 13800 1362 com.google.android.calendaru:r:untrusted_app:s0:c512,c768 u0_a1 13816 1362 com.android.providers.calendaru:r:su:s0 root 14046 1307 /system/bin/shu:r:untrusted_app:s0:c512,c768 u0_a58 14057 1362 com.newland.kotlindagger2 查看文件的上下文，执行命令 ls -Z1234567891011121314drwxr-xr-x root root u:object_r:system_file:s0 appdrwxr-xr-x root shell u:object_r:system_file:s0 bin-rw-r--r-- root root u:object_r:system_file:s0 build.propdrwxr-xr-x root root u:object_r:system_file:s0 etcdrwxr-xr-x root root u:object_r:system_file:s0 fontsdrwxr-xr-x root root u:object_r:system_file:s0 frameworkdrwxr-xr-x root root u:object_r:system_file:s0 libdrwx------ root root u:object_r:system_file:s0 lost+founddrwxr-xr-x root root u:object_r:system_file:s0 mediadrwxr-xr-x root root u:object_r:system_file:s0 priv-appdrwxr-xr-x root root u:object_r:system_file:s0 ttsdrwxr-xr-x root root u:object_r:system_file:s0 usrdrwxr-xr-x root shell u:object_r:system_file:s0 vendordrwxr-xr-x root shell u:object_r:system_file:s0 xbin 安全规则内核中的安全服务器使用SELinux安全策略，实时拒绝或者允许某些进程对内核对象的访问。策略文件是由一些策略源文件编译得到的二进制文件。策略源文件是由专用的策略语言编写的，包含了： 声明:定义策略实体，比如类型、用户、角色 规则:允许或拒绝对于对象的访问；指定允许的类型转换、指明如何设定默认用户、角色和类型。 #声明 类型声明 属性声明 权限声明 #文件位置 \\external\\sepolicy\\file_contexts 文件安全上下文 \\external\\sepolicy\\property_contexts 系统属性安全上下文 \\external\\sepolicy\\seapp_contexts 用于生成应用进程和文件的安全上下文 /system/etc/security/mac_permissions.xml 将应用签名证书映射成setinfo值","categories":[],"tags":[]},{"title":"android沙箱和权限机制","slug":"android沙箱和权限机制","date":"2018-07-01T10:24:52.000Z","updated":"2018-07-02T06:39:37.294Z","comments":true,"path":"2018/07/01/android沙箱和权限机制/","link":"","permalink":"http://yoursite.com/2018/07/01/android沙箱和权限机制/","excerpt":"","text":"进程隔离android中进程的地址空间是独立的，一个进程不能直接访问另一个进程的地址空间。 应用程序沙箱在每个应用程序的安装阶段，Android自动为每个应用赋予一个独一无二的UID，通常称作appid，应用执行时就在特定进程内以该UID运行。 系统守护进程和应用程序都是在明确的、恒定的UID运行的，很少有守护进程以root用户（UID=0）运行。这些UID是静态定义在 \\system\\core\\include\\private\\android_filesystem_config.h 文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define AID_ROOT 0 /* traditional unix root user */#define AID_SYSTEM 1000 /* system server */#define AID_RADIO 1001 /* telephony subsystem, RIL */#define AID_BLUETOOTH 1002 /* bluetooth subsystem */#define AID_GRAPHICS 1003 /* graphics devices */#define AID_INPUT 1004 /* input devices */#define AID_AUDIO 1005 /* audio devices */#define AID_CAMERA 1006 /* camera devices */#define AID_LOG 1007 /* log devices */#define AID_COMPASS 1008 /* compass device */#define AID_MOUNT 1009 /* mountd socket */#define AID_WIFI 1010 /* wifi subsystem */#define AID_ADB 1011 /* android debug bridge (adbd) */#define AID_INSTALL 1012 /* group for installing packages */#define AID_MEDIA 1013 /* mediaserver process */#define AID_DHCP 1014 /* dhcp client */#define AID_SDCARD_RW 1015 /* external storage write access */#define AID_VPN 1016 /* vpn system */#define AID_KEYSTORE 1017 /* keystore subsystem */#define AID_USB 1018 /* USB devices */#define AID_DRM 1019 /* DRM server */#define AID_MDNSR 1020 /* MulticastDNSResponder (service discovery) */#define AID_GPS 1021 /* GPS daemon */#define AID_UNUSED1 1022 /* deprecated, DO NOT USE */#define AID_MEDIA_RW 1023 /* internal media storage write access */#define AID_MTP 1024 /* MTP USB driver access */#define AID_UNUSED2 1025 /* deprecated, DO NOT USE */#define AID_DRMRPC 1026 /* group for drm rpc */#define AID_NFC 1027 /* nfc subsystem */#define AID_SDCARD_R 1028 /* external storage read access */#define AID_CLAT 1029 /* clat part of nat464 */#define AID_LOOP_RADIO 1030 /* loop radio devices */#define AID_MEDIA_DRM 1031 /* MediaDrm plugins */#define AID_PACKAGE_INFO 1032 /* access to installed package details */#define AID_SDCARD_PICS 1033 /* external storage photos access */#define AID_SDCARD_AV 1034 /* external storage audio/video access */#define AID_SDCARD_ALL 1035 /* access all users external storage */#define AID_LOGD 1036 /* log daemon */#define AID_SHARED_RELRO 1037 /* creator of shared GNU RELRO files */#define AID_SHELL 2000 /* adb and debug shell user */#define AID_CACHE 2001 /* cache access */#define AID_DIAG 2002 /* access to diagnostic resources *//* The range 2900-2999 is reserved for OEM, and must never be * used here */#define AID_OEM_RESERVED_START 2900#define AID_OEM_RESERVED_END 2999/* The 3000 series are intended for use as supplemental group id&apos;s only. * They indicate special Android capabilities that the kernel is aware of. */#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */#define AID_NET_BT 3002 /* bluetooth: create sco, rfcomm or l2cap sockets */#define AID_INET 3003 /* can create AF_INET and AF_INET6 sockets */#define AID_NET_RAW 3004 /* can create raw INET sockets */#define AID_NET_ADMIN 3005 /* can configure interfaces and routing tables. */#define AID_NET_BW_STATS 3006 /* read bandwidth statistics */#define AID_NET_BW_ACCT 3007 /* change bandwidth statistics accounting */#define AID_NET_BT_STACK 3008 /* bluetooth: access config files */#define AID_EVERYBODY 9997 /* shared between all apps in the same profile */#define AID_MISC 9998 /* access to misc storage */#define AID_NOBODY 9999#define AID_APP 10000 /* first app user */#define AID_ISOLATED_START 99000 /* start of uids for fully isolated sandboxed processes */#define AID_ISOLATED_END 99999 /* end of uids for fully isolated sandboxed processes */#define AID_USER 100000 /* offset for uid ranges for each user */#define AID_SHARED_GID_START 50000 /* start of gids for apps in each user to share */#define AID_SHARED_GID_END 59999 /* start of gids for apps in each user to share */ ps 查看 com.daoxu.myapplication 的信息 12USER PID PPID VSIZE RSS WCHAN PC NAMEu0_a62 6399 1362 1274908 36840 SyS_epoll_ b739f2b5 S com.daoxu.myapplication /data/system/package.list 查看 com.daoxu.myapplication 进程信息1com.daoxu.myapplication 10062 1 /data/data/com.daoxu.myapplication default none 系统服务的UID从1000开始。1000是system用户（AID_SYSTEM），具有特殊的权限。 应用程序是从10000开始（AID_APP），在ps中查看用户到的USER信息为 u0_a62 （支持多用户的androifd版本是uY_aXXX的格式，如果不支持多用户的则是app_XXX），XXX表示从AID_APP开始的偏移量（myapplication的为 10062-10000=62），Y则是Android的user ID（主要这边跟uid是不同的，是不同用户的的编号），所以上面ps看到的信息是u0_a62。 权限权限的本质如前面所说的，Android应用程序是沙箱隔离的，默认只能访问程序自己创建的文件和非常有限的系统服务，为了与系统和其他应用交互，Android引入了权限机制。 权限查看可以使用pm list permissons查看当前系统已知的权限列表。通常权限名称以定义它的程序的包名作为前缀，再接上permission字符串。内置的权限都是在android包里面定义的（这个在pkms中用详细的介绍），所以一般都是 android.permission 作为前缀。 1234567891011121314151617181|root@generic_x86:/ # pm list permissions All Permissions:permission:android.permission.REAL_GET_TASKSpermission:android.permission.ACCESS_CACHE_FILESYSTEMpermission:android.permission.REMOTE_AUDIO_PLAYBACKpermission:com.google.android.apps.photos.permission.C2D_MESSAGEpermission:android.permission.INTENT_FILTER_VERIFICATION_AGENTpermission:android.permission.BIND_INCALL_SERVICEpermission:com.google.android.gms.trustagent.framework.model.DATA_CHANGE_NOTIFICATIONpermission:android.permission.WRITE_SETTINGSpermission:android.permission.CONTROL_KEYGUARDpermission:com.google.android.calendar.permission.C2D_MESSAGEpermission:android.permission.CONFIGURE_WIFI_DISPLAYpermission:android.permission.ACCESS_WIMAX_STATEpermission:android.permission.SET_INPUT_CALIBRATIONpermission:android.permission.RECOVERYpermission:android.permission.TEMPORARY_ENABLE_ACCESSIBILITY 权限申请在应用程序的AndroidManifest.xml文件中添加 标签。 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; 权限管理在每个应用程序安装时，系统使用 包管理器服务 ，将权限赋予它们。包管理器维护一个已安装程序包的核心数据库，包括预安装（系统应用）和用户安装的程序包。其中包括如下信息： 安装路径 版本 签名证书 每个包的权限 所有已定义权限的列表。这个包数据库以xml的形式存放在/data/system/packages.xml中，文件会随着应用的安装、升级和卸载进行更新。下面我们跟踪一个包来查看下。 首先我们在程序包里申请了如下三个权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; 在 targetSdkVersion 27 查看文件信息 123456789&lt;package name=&quot;com.daoxu.securityclientdemo&quot; codePath=&quot;/data/app/com.daoxu.securityclientdemo-1&quot; nativeLibraryPath=&quot;/data/app/com.daoxu.securityclientdemo-1/lib&quot; publicFlags=&quot;944291654&quot; privateFlags=&quot;0&quot; ft=&quot;16456479468&quot; it=&quot;1645642beba&quot; ut=&quot;16456479c3e&quot; version=&quot;1&quot; userId=&quot;10065&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;7&quot; /&gt;&lt;/package&gt; 在 targetSdkVersion 22 查看文件信息 1234567891011&lt;package name=&quot;com.daoxu.securityclientdemo&quot; codePath=&quot;/data/app/com.daoxu.securityclientdemo-1&quot; nativeLibraryPath=&quot;/data/app/com.daoxu.securityclientdemo-1/lib&quot; publicFlags=&quot;944291654&quot; privateFlags=&quot;0&quot; ft=&quot;164564de598&quot; it=&quot;164564dec1b&quot; ut=&quot;164564dec1b&quot; version=&quot;1&quot; userId=&quot;10066&quot;&gt; &lt;sigs count=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;7&quot; /&gt;&lt;/package&gt; 从上面的例子我们可以看出在不同的targetSdkVersion版本，给的授权列表是不同的，之所以会这样是因为6.0以后的动态权限机制导致的，这就涉及到了下面我们要讲的权限的保护分级。 权限级别 normal 级别：默认值，低风险权限，无需用户确认。 dangerous 级别：危险级别，需要用户确认才能授权。 signature 级别：只会赋予与申明权限的应用程序使用相同签名的应用权限。一般我们所说的系统权限（这边所谓的系统权限要和 sharedUserId 的system 区别开来不是一个概念）其实就是指的 system 应用所声明的权限，所以应用程序在使用这些权限的时候需要使用系统签名（不需要声明 sharedUserId 也是可以的）。 signatureOrSystem 级别：这个级别的权限可以授权与 “系统应用” 和 与声明权限具有相同签名的应用程序，所以这个算是一个折中的方案。需要注意的是 在4.3 以前 这个 “系统应用” 是泛指在system分区下的应用，而4.3以后是特指 /system/priv-app目录下的应用。 权限的赋予权限的执行会在Android的各个层次上实施。 高层的组件:应用和系统服务，通过包管理器查询应用程序被赋予的是哪些权限 底层的组件：本地的守护进程。通常不通过包管理器，而是依赖进程的UID、GID和补充GID来决定赋予的权限。 系统资源：设备文件、UNIX域套接字和网络套接字，通过内核根据所有者、目标资源的访问权限和访问进程的UID和GID来进行控制。 权限和进程属性每个应用程序在安装时都会被分配一个独一无二的UID，在一个专有的进程中执行（这边说法不严谨，一个应用程序可以是多个进程，即1个UID 可以对应多个PID，就像后面我们会说到的共享UID也是类似的情况）。应用启动的时候，进程的UID和GID由包管理器服务设置为应用程序的UID。如果应用已被赋予额外的权限，就把这些权限映射成一组GID,作为补充GID分配给进程。 内置权限到GID的映射定义在 源码：frameworks\\base\\data\\etc\\platform.xml (机子：/system/etc/permissions/platform.xml）里。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;permission name=&quot;android.permission.NET_TUNNELING&quot; &gt; &lt;group gid=&quot;vpn&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.INTERNET&quot; &gt; &lt;group gid=&quot;inet&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.READ_LOGS&quot; &gt; &lt;group gid=&quot;log&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.WRITE_MEDIA_STORAGE&quot; &gt; &lt;group gid=&quot;media_rw&quot; /&gt; &lt;group gid=&quot;sdcard_rw&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.ACCESS_MTP&quot; &gt; &lt;group gid=&quot;mtp&quot; /&gt;&lt;/permission&gt;&lt;!-- ================================================================== --&gt;&lt;!-- ================================================================== --&gt;&lt;!-- ================================================================== --&gt;&lt;!-- The following tags are assigning high-level permissions to specific user IDs. These are used to allow specific core system users to perform the given operations with the higher-level framework. For example, we give a wide variety of permissions to the shell user since that is the user the adb shell runs under and developers and others should have a fairly open environment in which to interact with the system. --&gt;&lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;media&quot; /&gt;&lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;media&quot; /&gt;&lt;assign-permission name=&quot;android.permission.WAKE_LOCK&quot; uid=&quot;media&quot; /&gt;&lt;assign-permission name=&quot;android.permission.UPDATE_DEVICE_STATS&quot; uid=&quot;media&quot; /&gt;&lt;assign-permission name=&quot;android.permission.UPDATE_APP_OPS_STATS&quot; uid=&quot;media&quot; /&gt;&lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;graphics&quot; /&gt;&lt;!-- This is a list of all the libraries available for application code to link against. --&gt;&lt;library name=&quot;android.test.runner&quot; file=&quot;/system/framework/android.test.runner.jar&quot; /&gt;&lt;library name=&quot;javax.obex&quot; file=&quot;/system/framework/javax.obex.jar&quot; /&gt;&lt;library name=&quot;org.apache.http.legacy&quot; file=&quot;/system/framework/org.apache.http.legacy.jar&quot; /&gt;&lt;!-- These are the standard packages that are white-listed to always have internet access while in power save mode, even if they aren&apos;t in the foreground. --&gt;&lt;allow-in-power-save-except-idle package=&quot;com.android.providers.downloads&quot; /&gt; assign-permission 用于相反的目的。它用于给运行在指定的UID下，没有对应包文件的系统进程赋予更高层次的权限（比如给守护进程，一般是bin文件，是不能像应用程序那样申请权限，就可以在这边申请）。 这边的 group gid 就定义在上面我们介绍的 \\system\\core\\include\\private\\android_filesystem_config.h 文件中。 包管理器在启动的时候会维护一个权限到GID的列表，当包管理器给一个包授权的时候，会检查权限是否有对应的GID。如果有则加入到补充GID列表中。这个补充GID列表会写在上面我们说的 /data/system/package.list 中，在最后一个字段就是这个列表。 使用命令查看服务列表:service list查看权限列表:pm list permissions,-f的话可以显示更加显示的信息","categories":[],"tags":[]},{"title":"日常问题列表","slug":"日常问题列表","date":"2018-06-29T02:00:20.000Z","updated":"2018-06-29T02:16:19.396Z","comments":true,"path":"2018/06/29/日常问题列表/","link":"","permalink":"http://yoursite.com/2018/06/29/日常问题列表/","excerpt":"","text":"权限相关 日常问题:6.0系统下system_server没有写外存储器权限 日常问题:自定义系统权限级签名 AMS相关 日常问题:动态广播无法唤起singtask模式下的activity","categories":[],"tags":[]},{"title":"adj","slug":"adj","date":"2018-06-25T10:06:55.000Z","updated":"2018-07-02T05:56:54.406Z","comments":true,"path":"2018/06/25/adj/","link":"","permalink":"http://yoursite.com/2018/06/25/adj/","excerpt":"","text":"进程的生命周期lowmemorykiller六个档次 CACHED_APP_MAX_ADJ CACHED_APP_MIN_ADJ BACKUP_APP_ADJ PERCEPTIBLE_APP_ADJ VISIBLE_APP_ADJ FOREGROUND_APP_ADJ adj级别 ProcessList.java 中定义的 state级别 ActivityManager.java 中定义的 adj算法核心 updateOomAdjLocked：更新adj，当目标进程为空，或者被杀则返回false；否则返回true; computeOomAdjLocked：计算adj，返回计算后RawAdj值; applyOomAdjLocked：应用adj，当需要杀掉目标进程则返回false；否则返回true。 updateOomAdjLocked实现过程中依次会 computeOomAdjLocked 和 applyOomAdjLocked 触发时机#activity ass：/services/core/java/com/android/server/am/ActivityStackSupervisor as: /services/core/java/com/android/server/am/ActivityStack.java ASS.realStartActivityLocked: 启动Activity AS.resumeTopActivityInnerLocked: 恢复栈顶Activity AS.finishCurrentActivityLocked: 结束当前Activity AS.destroyActivityLocked: 摧毁当前Activity Service /services/core/java/com/android/server/am/ActiveServices.java realStartServiceLocked: 启动服务 bindServiceLocked: 绑定服务(只更新当前app) unbindServiceLocked: 解绑服务 (只更新当前app) bringDownServiceLocked: 结束服务 (只更新当前app) sendServiceArgsLocked: 在bringup或则cleanup服务过程调用 (只更新当前app) broadcast /services/core/java/com/android/server/am/BroadcastQueue.java processNextBroadcast: 处理下一个广播 processCurBroadcastLocked: 处理当前广播 deliverToRegisteredReceiverLocked: 分发已注册的广播 (只更新当前app) ContentProvider /services/core/java/com/android/server/am/ActivityManagerService.java AMS.removeContentProvider: 移除provider AMS.publishContentProviders: 发布provider (只更新当前app) AMS.getContentProviderImpl: 获取provider (只更新当前app) Process /services/core/java/com/android/server/am/ActivityManagerService.java setSystemProcess: 创建并设置系统进程 addAppLocked: 创建persistent进程 attachApplicationLocked: 进程创建后attach到system_server的过程; trimApplications: 清除没有使用app appDiedLocked: 进程死亡 killAllBackgroundProcesses: 杀死所有后台进程.即(ADJ&gt;9或removed=true的普通进程) killPackageProcessesLocked: 以包名的形式 杀掉相关进程; 重要参数ProcessList.java 空进程存活时长： MAX_EMPTY_TIME = 30min (缓存+空)进程个数上限：MAX_CACHED_APPS = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)； 空进程个数上限：MAX_EMPTY_APPS = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16； trim空进程个数上限：TRIM_EMPTY_APPS = computeTrimEmptyApps() = MAX_EMPTY_APPS/2 = 8； trim缓存进程个数上限：TRIM_CACHED_APPS = computeTrimCachedApps() = MAX_CACHED_APPS-MAX_EMPTY_APPS)/3 = 5; TRIM_CRITICAL_THRESHOLD = 3; ActivityManagerService.java mBServiceAppThreshold = SystemProperties.getInt(“ro.sys.fw.bservice_limit”, 5); mMinBServiceAgingTime =SystemProperties.getInt(“ro.sys.fw.bservice_age”, 5000); mProcessLimit = ProcessList.MAX_CACHED_APPS mProcessLimit = emptyProcessLimit(空进程上限) + cachedProcessLimit(缓存进程上限) oldTime = now - ProcessList.MAX_EMPTY_TIME; LRU进程队列长度 = numEmptyProcs(空进程数) + mNumCachedHiddenProcs(cached进程) + mNumNonCachedProcs（非cached进程） emptyFactor = numEmptyProcs/3, 且大于等于1 cachedFactor = mNumCachedHiddenProcs/3, 且大于等于1 方法","categories":[],"tags":[]},{"title":"日常问题:6.0系统下system_server没有写外存储器权限","slug":"日常问题-6-0系统下system-server没有写外存储器权限","date":"2018-06-14T09:42:20.000Z","updated":"2018-06-15T01:34:26.355Z","comments":true,"path":"2018/06/14/日常问题-6-0系统下system-server没有写外存储器权限/","link":"","permalink":"http://yoursite.com/2018/06/14/日常问题-6-0系统下system-server没有写外存储器权限/","excerpt":"","text":"问题描述上篇blog我们讲了怎么添加系统服务来保存日志的解决方案，然后领导很开心的给加了个需求：正常情况下不抓取日志，只有当U盘插入的时候检测到有特定的文件夹的时候才开始写日志到U盘里面去，方便测试人员捕获日志。刚拿到需求的时候想了下很简单，接收下U盘挂载广播就要可以了，确实在4.4上一切顺利，很快就完成任务了，然后今天移植到6.0系统发现无法再U盘上创建和写入文件。下面来追踪下解决的思路。 解决方案先从我们自定义的服务SystemLogService入手，SystemLogService是在SystemServer中初始化的，所以是属于system_server进程，所以初步怀疑是system_server进程没有权限导致的。下面我们来看看system_server进程的相关信息 通过 ps |grep system_server 命令来获取进程号1system 496 212 2023356 131972 0 0000000000 S system_server 进入到 proc 中查看虚拟文件系统查看进程目录1234567891011121314151617181920212223242526272829303132333435363738394041424344## 496 是进程号root@rk3399_m_stbvr:/ # cd proc/496/root@rk3399_m_stbvr:/proc/496 # ls -ladr-xr-xr-x system system 2013-01-18 16:50 attr-r-------- system system 0 2018-06-14 17:59 auxv-r--r--r-- system system 0 2018-06-14 17:59 cgroup--w------- system system 0 2018-06-14 17:59 clear_refs-r--r--r-- system system 0 2013-01-18 16:50 cmdline-rw-r--r-- system system 0 2013-01-18 16:50 comm-r--r--r-- system system 0 2018-06-14 17:59 cpusetlrwxrwxrwx system system 2018-06-14 17:59 cwd -&gt; /-r-------- system system 0 2018-06-14 17:59 environlrwxrwxrwx system system 2018-06-14 17:59 exe -&gt; /system/bin/app_process64dr-x------ system system 2013-01-18 16:50 fddr-x------ system system 2018-06-14 17:59 fdinfo-r-------- system system 0 2018-06-14 17:59 io-r--r--r-- system system 0 2018-06-14 17:59 limits-rw-r--r-- system system 0 2018-06-14 17:59 loginuiddr-x------ system system 2018-06-14 17:59 map_files-r--r--r-- system system 0 2018-06-14 17:59 maps-rw------- system system 0 2018-06-14 17:59 mem-r--r--r-- system system 0 2018-06-14 17:59 mountinfo-r--r--r-- system system 0 2013-01-18 16:50 mounts-r-------- system system 0 2018-06-14 17:59 mountstatsdr-xr-xr-x system system 2013-01-18 16:50 netdr-x--x--x system system 2018-06-14 17:59 ns-r-------- system system 0 2018-06-14 17:59 oom_adj-r--r--r-- system system 0 2018-06-14 17:59 oom_score-r-------- system system 0 2013-01-18 16:50 oom_score_adj-r-------- system system 0 2018-06-14 17:59 pagemap-r-------- system system 0 2018-06-14 17:59 personalitylrwxrwxrwx system system 2018-06-14 17:59 root -&gt; /-rw-r--r-- system system 0 2018-06-14 17:59 sched-r--r--r-- system system 0 2018-06-14 17:59 schedstat-r--r--r-- system system 0 2018-06-14 17:59 sessionid-r--r--r-- system system 0 2018-06-14 17:42 smaps-r-------- system system 0 2018-06-14 17:59 stack-r--r--r-- system system 0 2013-01-18 16:50 stat-r--r--r-- system system 0 2018-06-14 17:59 statm-r--r--r-- system system 0 2018-06-14 17:59 status-r-------- system system 0 2018-06-14 17:59 syscalldr-xr-xr-x system system 2013-01-18 16:50 task-rw-rw-rw- system system 0 2018-06-14 17:59 timerslack_ns-r--r--r-- system system 0 2013-01-18 16:50 wchan 查看status文件123456789101112131415161718192021222324252627282930313233343536373839404142434445root@rk3399_m_stbvr:/proc/496 # cat statusName: system_serverState: S (sleeping)Tgid: 496Ngid: 0Pid: 496PPid: 212TracerPid: 0Uid: 1000 1000 1000 1000Gid: 1000 1000 1000 1000FDSize: 512# 1015 和 1023 原来是没有的，后面修改后才有的Groups: 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1015 1018 1021 1023 1032 3001 3002 3003 3006 3007VmPeak: 2155712 kBVmSize: 2023356 kBVmLck: 0 kBVmPin: 0 kBVmHWM: 133496 kBVmRSS: 131172 kBVmData: 93112 kBVmStk: 8196 kBVmExe: 16 kBVmLib: 101224 kBVmPTE: 676 kBVmPMD: 28 kBVmSwap: 0 kBThreads: 76SigQ: 2/7258SigPnd: 0000000000000000ShdPnd: 0000000000000000SigBlk: 0000000000001204SigIgn: 0000000000000000SigCgt: 00000002000094f8CapInh: 0000000000000000CapPrm: 0000001007813c20CapEff: 0000001007813c20CapBnd: 0000000000000000CapAmb: 0000000000000000Seccomp: 0Cpus_allowed: 3fCpus_allowed_list: 0-5Mems_allowed: 1Mems_allowed_list: 0voluntary_ctxt_switches: 3557nonvoluntary_ctxt_switches: 1410 查看U盘的所属用户组因为这边挂载了两个文件系统，所以都需要查看 /mnt/media_rw/E844-FF7112345678root@rk3399_m_stbvr:/mnt/media_rw/E844-FF71 # ls -la-rwxrwx--- media_rw media_rw 17127363 2013-05-03 16:27 8ch_voices_id_21_ddp.h264-rwxrwx--- media_rw media_rw 34050184 2013-05-03 16:19 8ch_voices_id_21_ddp_DVB_mpeg2_25fps.trpdrwxrwx--- media_rw media_rw 2018-06-11 18:11 Androiddrwxrwx--- media_rw media_rw 2018-06-11 18:06 LOST.DIRdrwxrwx--- media_rw media_rw 2018-06-14 15:55 System Volume Informationdrwxrwx--- media_rw media_rw 2018-06-14 18:10 logcatdrwxrwx--- media_rw media_rw 2018-06-12 18:29 鏈€鏂版祴璇曚娇鐢ㄧ殑鐮佹祦 /storage/E844-FF7112345678root@rk3399_m_stbvr:/storage/E844-FF71 # ls -la-rwxrwx--x root sdcard_rw 17127363 2013-05-03 16:27 8ch_voices_id_21_ddp.h264-rwxrwx--x root sdcard_rw 34050184 2013-05-03 16:19 8ch_voices_id_21_ddp_DVB_mpeg2_25fps.trpdrwxrwx--x root sdcard_rw 2018-06-11 18:11 Androiddrwxrwx--x root sdcard_rw 2018-06-11 18:06 LOST.DIRdrwxrwx--x root sdcard_rw 2018-06-14 15:55 System Volume Informationdrwxrwx--x root sdcard_rw 2018-06-14 18:10 logcatdrwxrwx--x root sdcard_rw 2018-06-12 18:29 鏈€鏂版祴璇曚娇鐢ㄧ殑鐮佹祦 查看所属用户组对应的数值\\system\\core\\include\\private\\android_filesystem_config.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define AID_ROOT 0 /* traditional unix root user */#define AID_SYSTEM 1000 /* system server */#define AID_RADIO 1001 /* telephony subsystem, RIL */#define AID_BLUETOOTH 1002 /* bluetooth subsystem */#define AID_GRAPHICS 1003 /* graphics devices */#define AID_INPUT 1004 /* input devices */#define AID_AUDIO 1005 /* audio devices */#define AID_CAMERA 1006 /* camera devices */#define AID_LOG 1007 /* log devices */#define AID_COMPASS 1008 /* compass device */#define AID_MOUNT 1009 /* mountd socket */#define AID_WIFI 1010 /* wifi subsystem */#define AID_ADB 1011 /* android debug bridge (adbd) */#define AID_INSTALL 1012 /* group for installing packages */#define AID_MEDIA 1013 /* mediaserver process */#define AID_DHCP 1014 /* dhcp client */#define AID_SDCARD_RW 1015 /* external storage write access */#define AID_VPN 1016 /* vpn system */#define AID_KEYSTORE 1017 /* keystore subsystem */#define AID_USB 1018 /* USB devices */#define AID_DRM 1019 /* DRM server */#define AID_MDNSR 1020 /* MulticastDNSResponder (service discovery) */#define AID_GPS 1021 /* GPS daemon */#define AID_UNUSED1 1022 /* deprecated, DO NOT USE */#define AID_MEDIA_RW 1023 /* internal media storage write access */#define AID_MTP 1024 /* MTP USB driver access */#define AID_UNUSED2 1025 /* deprecated, DO NOT USE */#define AID_DRMRPC 1026 /* group for drm rpc */#define AID_NFC 1027 /* nfc subsystem */#define AID_SDCARD_R 1028 /* external storage read access */#define AID_CLAT 1029 /* clat part of nat464 */#define AID_LOOP_RADIO 1030 /* loop radio devices */#define AID_MEDIA_DRM 1031 /* MediaDrm plugins */#define AID_PACKAGE_INFO 1032 /* access to installed package details */#define AID_SDCARD_PICS 1033 /* external storage photos access */#define AID_SDCARD_AV 1034 /* external storage audio/video access */#define AID_SDCARD_ALL 1035 /* access all users external storage */#define AID_LOGD 1036 /* log daemon */#define AID_SHARED_RELRO 1037 /* creator of shared GNU RELRO files */#define AID_SHELL 2000 /* adb and debug shell user */#define AID_CACHE 2001 /* cache access */#define AID_DIAG 2002 /* access to diagnostic resources *//* The range 2900-2999 is reserved for OEM, and must never be * used here */#define AID_OEM_RESERVED_START 2900#define AID_OEM_RESERVED_END 2999/* The 3000 series are intended for use as supplemental group id&apos;s only. * They indicate special Android capabilities that the kernel is aware of. */#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */#define AID_NET_BT 3002 /* bluetooth: create sco, rfcomm or l2cap sockets */#define AID_INET 3003 /* can create AF_INET and AF_INET6 sockets */#define AID_NET_RAW 3004 /* can create raw INET sockets */#define AID_NET_ADMIN 3005 /* can configure interfaces and routing tables. */#define AID_NET_BW_STATS 3006 /* read bandwidth statistics */#define AID_NET_BW_ACCT 3007 /* change bandwidth statistics accounting */#define AID_NET_BT_STACK 3008 /* bluetooth: access config files */#define AID_EVERYBODY 9997 /* shared between all apps in the same profile */#define AID_MISC 9998 /* access to misc storage */#define AID_NOBODY 9999#define AID_APP 10000 /* first app user */#define AID_ISOLATED_START 99000 /* start of uids for fully isolated sandboxed processes */#define AID_ISOLATED_END 99999 /* end of uids for fully isolated sandboxed processes */#define AID_USER 100000 /* offset for uid ranges for each user */#define AID_SHARED_GID_START 50000 /* start of gids for apps in each user to share */#define AID_SHARED_GID_END 59999 /* start of gids for apps in each user to share */ 这边我们可以查找 sdcard_rw 对应的是 AID_SDCARD_RW 1015,media_rw对应的是 AID_MEDIA_RW 1023 修改 system_server 的所属用户组system_server是由ZygoteInit类负责初始化和启动的，frameworks/base/core/java/com/android/internal/os/ZygoteInit.java文件中。在startSystemServer方法中启动sysetm_server时通过 –setgroups 为其设置了所属用户组，代码如下 12345678910/* Hardcoded command line to start the system server */String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1015,1023,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\",&#125;; 在这里添加对应的用户组 总结解决的步骤如下 查看进程当前所属的组 查看需要的用户组 查看对应用户组的值 修改启动参数添加组","categories":[],"tags":[]},{"title":"activity启动过程","slug":"activity启动过程","date":"2018-06-12T15:55:08.000Z","updated":"2018-06-26T01:35:05.034Z","comments":true,"path":"2018/06/12/activity启动过程/","link":"","permalink":"http://yoursite.com/2018/06/12/activity启动过程/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"日常问题:自定义系统权限级签名","slug":"日常问题-自定义系统权限级签名","date":"2018-06-08T07:09:53.000Z","updated":"2018-06-11T07:54:14.923Z","comments":true,"path":"2018/06/08/日常问题-自定义系统权限级签名/","link":"","permalink":"http://yoursite.com/2018/06/08/日常问题-自定义系统权限级签名/","excerpt":"","text":"一.背景知识1.1 android权限分级在android开发中权限主要分为以下四级 normal: 普通的权限，只需要在 AndroidManifest.xml 文件中定义就可以使用。 dangerous: 危险的权限，不仅需要在 AndroidManifest.xml 文件定义，如果apk的目标版本是23以上并且运行在23版本以上的机子上那么需要动态申请权限。 signature: 系统级别签名才能获取的权限。 signature|system: 系统级别签名或者系统应用可以获取的权限。 关于权限定义的源文件位于：frameworks\\base\\core\\res\\AndroidManifest.xml 这边要注意 系统权限应用(signature)和系统应用（system）的区别：系统应用一般是厂商内置的应用，在目录 system/app 、/system/framework/、/vendor/app/下的都是系统应用，系统权限应用是 指在 AndroidManifest.xml 申请了 android:sharedUserId=”android.uid.system” 的应用，而这个是需要系统签名的。这部分的知识在PKMS服务中会详细的介绍。 1.2 系统签名类型android的标准签名key有： testkey: testkey是作为android编译的时候默认的签名key，如果系统中的apk的android.mk中没有设置LOCAL_CERTIFICATE的值，就默认使用testkey media：如果LOCAL_CERTIFICATE := media 就代表使用 media 来签名，这样apk就会跟系统中所有使用android.uid.media共享UID。用这个是该APK是media/download系统中的一环。 platform: 如果LOCAL_CERTIFICATE := platform 就代表使用platform来签名，这样的话这个apk就拥有了和system相同的签名，因为系统级别的签名也是使用的platform来签名 shared：如果LOCAL_CERTIFICATE := shared 就代表使用 shared 来签名，这样apk就会跟系统中所有使用android.uid.shared共享UID。用这个的一般是该APK需要和home/contacts进程共享数据。 在源码的/build/target/product/security里面看到对应的密钥，其中.pk8代表私钥，.pem公钥，一定是成对出现的。 查看.pem公钥方法openssl x509 -in cert.pem(文件名) -noout -text 关于.pk8和.pem在下面会继续详细介绍。 1.3 签名相关知识1.3.1 数据摘要消息摘要算法（Message Digest Algorithm）是一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就被称作原始数据的消息摘要。简单点说就是提取数据的“指纹”。 著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。 消息摘要的主要特点有： 1）无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出。2）一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的消息摘要也必不相同，即使原始数据稍有改变，输出的消息摘要便完全不同。但是，相同的输入必会产生相同的输出。 3）具有不可逆性，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的原始消息。 1.3.2 jarsign和signapk工具这两个都是android系统中使用的签名工具。jarsign是Java本生自带的一个工具，他可以对jar进行签名的。而signapk是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样。 jarsign工具 签名时使用的是 keystore 文件。 signapk工具 签名时使用的是pk8、pem文件。 keystore 文件 和 pk8、pem文件 是可以转化的，在开发具有系统权限的应用的时候我们一般是将pk8、pem文件转化成keystore 文件，然后再在AS中设置调试编译打包使用的keystore 文件，这样就可以像开发普通应用一样去开发具有系统权限的应用，而不是每次打包后再用signapk工具重新签名。 这边补充下：keystore 是Eclipse 打包生成的签名。 而 。jks是Android studio 生成的签名！都是用来打包的，并保证应用的唯一性，它们是可以互相转换的。 因为我们现在常用的是jks文件，可以通过代码获取jks文件的公钥和私钥信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.UnrecoverableKeyException;import java.security.cert.CertificateException;import javax.security.cert.Certificate;public class JKSTesting &#123; public static PublicKey getPublicKey(String keyStoreFile, String storeFilePass, String keyAlias) &#123; // 读取密钥是所要用到的工具类 KeyStore ks; // 公钥类所对应的类 PublicKey pubkey = null; try &#123; // 得到实例对象 ks = KeyStore.getInstance(\"JKS\"); FileInputStream fin; try &#123; // 读取JKS文件 fin = new FileInputStream(keyStoreFile); try &#123; // 读取公钥 ks.load(fin, storeFilePass.toCharArray()); java.security.cert.Certificate cert = ks .getCertificate(keyAlias); pubkey = cert.getPublicKey(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; return pubkey; &#125; /** * 得到私钥 * * @param keyStoreFile * 私钥文件 * @param storeFilePass * 私钥文件的密码 * @param keyAlias * 别名 * @param keyAliasPass * 密码 * @return */ public static PrivateKey getPrivateKey(String keyStoreFile, String storeFilePass, String keyAlias, String keyAliasPass) &#123; KeyStore ks; PrivateKey prikey = null; try &#123; ks = KeyStore.getInstance(\"JKS\"); FileInputStream fin; try &#123; fin = new FileInputStream(keyStoreFile); try &#123; try &#123; ks.load(fin, storeFilePass.toCharArray()); // 先打开文件 prikey = (PrivateKey) ks.getKey(keyAlias, keyAliasPass .toCharArray()); // 通过别名和密码得到私钥 &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; return prikey; &#125; public static void main(String[] args) &#123; PublicKey publicKey; PrivateKey privateKey; publicKey=getPublicKey(\"*******\",\"*******\", \"*******\"); privateKey=getPrivateKey(\"*******\",\"*******\", \"*******\",\"*******\"); System.out.println(\"publicKey\"); System.out.println(publicKey.toString()); System.out.println(\"privateKey\"); System.out.println(privateKey.toString()); &#125;&#125; 1.3.3 签名后生成的文件解压签名后的apk文件，在 META-INF 文件夹中可以看到以下格式的文件 .RSA或者DSA .SF MANIFEST.MF文件 Android中是允许使用多个 keystore 对apk进行签名的，这样在 META-INF 就会生成多对（.RSA和.SF）的文件，以 keystore 文件的 alias 的值为名称。如果是用 signapk工具 进行签名的话就会直接固定命名CERT。 1.3.3.1 MANIFEST.MF文件我们先看下这个文件的内容 1234567891011121314151617181920212223242526272829303132Name: lombok/installer/InstallerGUI$4.SCL.lombokSHA1-Digest: ZSCgYd7ezY8EyCteY5YFVNSzqbg=Name: res/drawable-hdpi-v4/modify_phone_num_step_first.pngSHA1-Digest: 1A/23eA5r36ww5luAwlaK5n42fc=Name: res/drawable-hdpi-v4/right_kuohao_focus.pngSHA1-Digest: fPzTTOc+c1ogDOlHKpeJ0JGDt6U=Name: res/layout/activity_modify_phone.xmlSHA1-Digest: aE+Ctjnxcu/xHp79HhRZ8LvnA/c=Name: res/drawable-1920x1080/item_h_default.pngSHA1-Digest: KA0HpPJUVaKTpTnF5ouiJmRNyXo=Name: lombok/delombok/LombokOptionsFactory$1.SCL.lombokSHA1-Digest: QlP0zlFTJ9scHtfLL3/OZNhA2uw=Name: AndroidManifest.xmlSHA1-Digest: lkuasUmz9QVhBrAh8JEMmyvL65c=Name: lombok/installer/InstallerGUI$9.SCL.lombokSHA1-Digest: ifEHckOynWf1wUlfPH/aoj73utk=Name: lombok/core/LombokConfiguration.SCL.lombokSHA1-Digest: XOaLbgugkPhHqkxGiDFxUvxNJSA=Name: lombok/installer/eclipse/JbdsLocationProvider.SCL.lombokSHA1-Digest: 3M+Q/7s7VwuoOWk1hpUJe8yBJjM=Name: res/drawable-hdpi-v4/user_prog_entry_layer.pngSHA1-Digest: 5oJ0Hv4o+c7PkwJ4MOox2/xZmzU= 文件的内容是逐一遍历apk里面的所有条目，如果是目录就跳过，如果是一个文件，就用SHA1（或者SHA256）消息摘要算法提取出该文件的摘要然后进行BASE64编码后，作为“SHA1-Digest”属性的值写入到MANIFEST.MF文件中的一个块中。该块有一个“Name”属性，其值就是该文件在apk包中的路径。 1.3.3.2 SF文件12345678910111213141516171819Signature-Version: 1.0X-Android-APK-Signed: 2SHA1-Digest-Manifest: oZ0/oKbtbxza48iz2t1zT9MQ/vw=Created-By: 1.0 (Android)Name: res/layout/play_progress_tip_layout.xmlSHA1-Digest: zGKChGzCciVxMBfsf/9QS1jA9f0=Name: res/anim/boot_one_circle.xmlSHA1-Digest: P4oLIBrBAQqjEn2VUDXvvuYXfeI=Name: res/drawable-hdpi-v4/myapp_del_no_focus.pngSHA1-Digest: GEyz0DWb4vzq33MLCBnxtTVbWQE=Name: lombok/eclipse/handlers/HandleLog$LoggingFramework.SCL.lombokSHA1-Digest: LSHMxv3Atl0Z7MCQaPf9yKvhax4=Name: lombok/delombok/DelombokApp$1.SCL.lombokSHA1-Digest: DfUlhS1EZ55lpPpz+vsDIf847No= SF文件记载的内容： 计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下 逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest 1.3.3.3 RSA文件因为RSA文件加密了，所以我们需要用openssl命令才能查看其内容 openssl pkcs7 -inform DER -in CERT.RSA(文件名) -noout -print_certs –text 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Certificate: Data: Version: 3 (0x2) //版本号 Serial Number: 610763924 (0x24678494) //证书序列号 Signature Algorithm: sha256WithRSAEncryption //算法 Issuer: CN=icntv //发行者名称 Validity Not Before: Nov 5 15:43:01 2012 GMT //生效日期 Not After : Oct 12 15:43:01 2112 GMT //终止日期 Subject: CN=icntv //主体名称 //算法 参数 秘钥:主体公钥信息，包含开发者的加密算法以及密钥信息 Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:80:03:44:30:c7:6a:93:e3:3a:94:8e:b6:a8:70: e0:19:eb:00:de:85:a9:b8:57:b9:e5:2e:0a:db:c0: 1b:e4:56:c0:32:7c:f3:54:65:ca:20:02:df:6c:3b: f6:7e:29:71:3d:aa:69:ac:e9:61:17:65:9c:9b:94: 74:40:a2:67:f8:65:26:2c:a0:cf:2a:2e:15:7d:04: c2:c2:44:d7:28:8a:c0:a7:65:ac:e5:eb:c6:67:ce: 74:82:47:0a:af:3f:7d:a9:d8:de:49:39:9e:17:49: b4:f7:86:39:e1:02:25:6b:6e:94:82:95:3b:f2:62: 07:6a:41:33:0b:3a:d2:31:a7:2b:68:c7:73:49:2f: 7b:5c:83:51:05:5b:a4:5d:01:cf:3a:b9:98:f4:a1: 6b:20:85:f9:3f:aa:e7:5e:e6:35:82:43:1e:d2:ed: 90:8c:24:47:22:06:95:ab:8b:fd:12:0f:23:13:74: 07:f4:02:e0:94:71:0e:7b:b8:ae:02:54:84:d6:e3: eb:91:a5:41:7b:6e:c5:26:57:9d:b6:ab:58:f0:e4: c4:d0:a1:9e:23:31:02:ff:60:98:a3:4e:2b:d2:58: 6c:d1:12:a8:95:cb:19:69:0d:76:bc:50:e1:ed:6a: e3:a9:42:9a:b5:76:55:fb:34:41:b3:00:9a:99:cb: 9c:d9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 6D:26:4A:D1:30:4C:15:D6:EE:9B:63:95:AF:C1:63:7F:8B:83:31:68 //算法 参数 已加密的hash值：用CA的私钥对证书的所有域以及这些域的Hash值一起加密 Signature Algorithm: sha256WithRSAEncryption 08:2d:00:a8:6e:ad:67:87:6b:20:31:b0:d3:0f:52:64:cf:23: ab:05:3a:53:8b:30:05:3e:47:0a:5c:19:1a:b0:e9:8d:4b:1d: 2c:f6:41:33:ba:b3:67:0a:77:46:bb:46:57:ef:f9:66:d8:68: 5d:41:be:3c:1d:35:f3:a3:58:4a:f4:f0:7f:87:1b:e4:0c:0c: 84:91:08:23:4c:9f:82:44:da:11:b1:60:b9:db:da:f6:36:58: 25:f6:ae:dc:4c:24:0d:1f:65:05:ee:9c:9c:c5:64:4a:a0:21: 4c:53:5a:3c:3e:c6:ad:67:cb:36:5e:6d:58:85:f5:2f:dd:6d: c8:cc:7b:09:ba:8c:bd:6f:e8:53:d1:88:8d:35:90:48:ba:db: 5b:16:22:31:46:da:aa:91:ba:50:57:a5:38:08:af:05:ae:a1: ec:3d:4f:fe:06:88:c8:60:9d:b9:16:00:7a:74:c8:a1:85:53: dd:b5:0c:b7:09:f3:d4:e5:07:29:12:05:c2:83:84:c3:96:ec: ba:ad:12:ad:1d:cf:52:d3:e3:ce:47:6a:89:4a:b1:39:c3:d2: b7:e0:d5:77:d9:02:e5:17:89:09:00:b3:cb:38:38:ef:97:90: 35:27:41:90:cf:b7:98:34:21:69:bd:64:ad:2b:23:85:97:96: 6b:74:56:9b 1.3.4 为什么android要用这样的方式加密 首先，如果你改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。 其次，如果你对更改的过的文件相应的算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。 最后，如果你还不死心，继续计算MANIFEST.MF的摘要值，相应的更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。 那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。所以，如果要重新打包后的应用程序能再Android设备上安装，必须对其进行重签名。 1.3.5 总结1.3.5.1 概念 数据指纹就是对一个数据源做SHA/MD5算法，这个值是唯一的 签名文件技术就是：数据指纹+RSA算法 证书文件中包含了公钥信息和其他信息 在Android签名之后，其中SF就是签名文件，RSA就是证书文件我们可以使用openssl来查看RSA文件中的证书信息和公钥信息 1.3.5.2 流程 对Apk中的每个文件做一次算法(数据摘要+Base64编码)，保存到MANIFEST.MF文件中 对MANIFEST.MF整个文件做一次算法(数据摘要+Base64编码)，存放到CERT.SF文件的头属性中，在对MANIFEST.MF文件中各个属性块做一次算法(数据摘要+Base64编码)，存到到一个属性块中。 对CERT.SF文件做签名，内容存档到CERT.RSA中 关于签名相关知识因为本人对安全这块涉及很少，所以基本都是引用自blog（https://blog.csdn.net/jiangwei0910410003/article/details/50402000） 的内容 二.问题分析前面我们对相关的知识做了梳理，现在回到我们的需求上来。已知需求为：要求系统级权限应用使用系统签名文件和指定的第三方签名文件都可以完成验证。在之前的PKMS服务的介绍中我们知道在应用安装和开机扫描的时候是需要做签名验证的，我们现在以应用安装为入口对源码进行跟踪。（关于PKMS服务的源码分析blog会在后续更新出来） 下面的代码基于android6.0，设计的代码文件路径如下：frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.javaframeworks/base/core/java/android/content/pm/PackageParser.javalibcore/luni/src/main/java/java/util/jar/StrictJarFile.java 2.1 installPackageLI这边要先声明 installPackageLI 并不是一个应用安装的入口方法，应用的安装涉及到的服务还有 PackageManagerInstallerService 服务，我们可以简单的把应用的安装分为两个步骤：一是拷贝阶段，二是安装阶段。而这个过程的控制则是由 PackageManagerInstallerService 进行控制的，我们这边要介绍的 installPackageLI 方法算是 第二阶段的入口方法（因为本文主要是介绍签名验证，关于应用安装过程会有跳过，毕竟这个不是本文的重点，后续文章会介绍6.0应用安装的过程。） installPackageLI 方法比较长，篇幅原因就不全部拷贝出来了，这边列举下该方法做了哪些东西 解析apk文件 收集应用的签名 检查安装参数是否带有强制替换参数，并做相应的处理 如果该应用已安装则做相应的验证,还需要判断升级的是否是系统应用 检查应用中定义的权限（这部分的判断会比较多,但不是这次分析的重点） 系统应用升级的话会对安装位置做检查不允许安装在sd卡上 执行 replacePackageLI 或者 installNewPackageLI 这边我们的重点在第二点收集应用的签名和第四点中调用的 verifySignaturesLP 方法。首先我们先看看第二点的代码 123456789101112131415161718192021222324252627 final PackageParser.Package pkg; try &#123; pkg = pp.parsePackage(tmpPackageFile, parseFlags); &#125; catch (PackageParserException e) &#123; res.setError(\"Failed parse during installPackageLI\", e); return; &#125; // Mark that we have an install time CPU ABI override. pkg.cpuAbiOverride = args.abiOverride; String pkgName = res.name = pkg.packageName; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) &#123; if ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == 0) &#123; res.setError(INSTALL_FAILED_TEST_ONLY, \"installPackageLI\"); return; &#125; &#125;//收集应用签名 try &#123; pp.collectCertificates(pkg, parseFlags); pp.collectManifestDigest(pkg); &#125; catch (PackageParserException e) &#123; res.setError(\"Failed collect during installPackageLI\", e); return; &#125; 代码很简单,涉及到一个新的类 ackageParser.Package，我们跟踪进 collectCertificates 方法中查看 2.2 collectCertificates12345678910111213public void collectCertificates(Package pkg, int flags) throws PackageParserException &#123; pkg.mCertificates = null; pkg.mSignatures = null; pkg.mSigningKeys = null; collectCertificates(pkg, new File(pkg.baseCodePath), flags); if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) &#123; for (String splitCodePath : pkg.splitCodePaths) &#123; collectCertificates(pkg, new File(splitCodePath), flags); &#125; &#125;&#125; 这边我们重点关注重载方法 collectCertificates 这里面才是真正实现部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private static void collectCertificates(Package pkg, File apkFile, int flags) throws PackageParserException &#123; final String apkPath = apkFile.getAbsolutePath(); StrictJarFile jarFile = null; try &#123; jarFile = new StrictJarFile(apkPath); // Always verify manifest, regardless of source final ZipEntry manifestEntry = jarFile.findEntry(ANDROID_MANIFEST_FILENAME); if (manifestEntry == null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Package \" + apkPath + \" has no manifest\"); &#125; final List&lt;ZipEntry&gt; toVerify = new ArrayList&lt;&gt;(); toVerify.add(manifestEntry); // If we're parsing an untrusted package, verify all contents if ((flags &amp; PARSE_IS_SYSTEM) == 0) &#123; final Iterator&lt;ZipEntry&gt; i = jarFile.iterator(); while (i.hasNext()) &#123; final ZipEntry entry = i.next(); if (entry.isDirectory()) continue; if (entry.getName().startsWith(\"META-INF/\")) continue; if (entry.getName().equals(ANDROID_MANIFEST_FILENAME)) continue; toVerify.add(entry); &#125; &#125; // Verify that entries are signed consistently with the first entry // we encountered. Note that for splits, certificates may have // already been populated during an earlier parse of a base APK. for (ZipEntry entry : toVerify) &#123; final Certificate[][] entryCerts = loadCertificates(jarFile, entry); if (ArrayUtils.isEmpty(entryCerts)) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES, \"Package \" + apkPath + \" has no certificates at entry \" + entry.getName()); &#125; final Signature[] entrySignatures = convertToSignatures(entryCerts); if (pkg.mCertificates == null) &#123; pkg.mCertificates = entryCerts; pkg.mSignatures = entrySignatures; pkg.mSigningKeys = new ArraySet&lt;PublicKey&gt;(); for (int i=0; i &lt; entryCerts.length; i++) &#123; pkg.mSigningKeys.add(entryCerts[i][0].getPublicKey()); &#125; &#125; else &#123; if (!Signature.areExactMatch(pkg.mSignatures, entrySignatures)) &#123; throw new PackageParserException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, \"Package \" + apkPath + \" has mismatched certificates at entry \" + entry.getName()); &#125; &#125; &#125; &#125; catch (GeneralSecurityException e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING, \"Failed to collect certificates from \" + apkPath, e); &#125; catch (IOException | RuntimeException e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES, \"Failed to collect certificates from \" + apkPath, e); &#125; finally &#123; closeQuietly(jarFile); &#125;&#125; 这边我们重点关注这里 123456pkg.mCertificates = entryCerts;pkg.mSignatures = entrySignatures;pkg.mSigningKeys = new ArraySet&lt;PublicKey&gt;();for (int i=0; i &lt; entryCerts.length; i++) &#123; pkg.mSigningKeys.add(entryCerts[i][0].getPublicKey());&#125; 因为我们的需求是增加一个支持系统级权限的签名，所以关于apk和签名校对来保证apk未被篡改不是我们关注的重点，我们关注的重点应该是证书文件（RSA文件）里面的公钥和我们需要比对的公钥是否是一致的。所以前面签名校对我们直接跳过，直接看这边获取到的公钥信息保存在上面代码所示的位置。 关于这个签名信息的获取过程建议查看姜老师的这篇blog：https://blog.csdn.net/jiangwei0910410003/article/details/50443505 现在我们获取到了apk的公钥信息，那么在哪里进行比较呢？这时候我们回到 2.1 中 第四点提到的 verifySignaturesLP 方法我们先来看看这个方法里面都做了什么 2.4 verifySignaturesLP12345678910111213141516171819202122232425262728293031323334353637383940414243 private void verifySignaturesLP(PackageSetting pkgSetting, PackageParser.Package pkg) throws PackageManagerException &#123; if (pkgSetting.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" signatures do not match the \" + \"previously installed version; ignoring!\"); &#125; &#125;//这边是重点了 检查shared uid的签名信息 // Check for shared user signatures if (pkgSetting.sharedUser != null &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, \"Package \" + pkg.packageName + \" has no signatures that match those in shared user \" + pkgSetting.sharedUser.name + \"; ignoring!\"); &#125; &#125; &#125; 如上面代码所示的，在这里会对 shared uid 的apk进行签名认证，那么我们现在思路有了，因为到这里的时候apk的公钥信息已经收集到了，那么只需要在这里多做一个判断：判断公钥信息是否和指定的第三方公钥信息一致就可以了。 verifySignaturesLP 并不止是在 installPackageLI 被调用,在 scanPackageDirtyLI 都也有调用该方法，而 scanPackageDirtyLI 在安装apk和开机扫描apk（例如：installNewPackageLI replaceSystemPackageLI replaceNonSystemPackageLI）的时候都会被调用到，所以我们只需要在这个方法里面添加判断即可全部覆盖到。 三.解决方案方案一12345678910111213141516171819202122232425262728private boolean verifySignaturesLP(PackageSetting pkgSetting, PackageParser.Package pkg) &#123; if (pkgSetting.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match if (compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; Slog.e(TAG, \"Package \" + pkg.packageName + \" signatures do not match the previously installed version; ignoring!\"); mLastScanError = PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE; return false; &#125; &#125; // Check for shared user signatures if (pkgSetting.sharedUser != null &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != null) &#123; if( !isNeedSystemSign || (isNeedPackageSignatures() &amp;&amp; checkPackageSignatures(pkg))) &#123; isNeedSystemSign = true; return true; &#125;else if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; Slog.e(TAG, \"Package \" + pkg.packageName + \" has no signatures that match those in shared user \" + pkgSetting.sharedUser.name + \"; ignoring!\"); mLastScanError = PackageManager.INSTALL_FAILED_SHARED_USER_INCOMPATIBLE; return false; &#125; &#125; return true;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private boolean checkPackageSignatures(PackageParser.Package pkg)&#123; if (DEBUG_INSTALL) Slog.i(TAG, \"checkPackageSignatures(\"+pkg.packageName+\")\"); if(pkg == null) return false; FileInputStream is =null; try&#123; is= new FileInputStream(new File(\"/etc/CERT.RSA\")); &#125;catch(java.io.FileNotFoundException e)&#123; e.printStackTrace(); return false; &#125; byte[] readBuffer=new byte[8192];; try&#123; while (is.read(readBuffer, 0, readBuffer.length) != -1) &#123; // not using &#125; is.close(); &#125;catch(java.io.IOException e)&#123; e.printStackTrace(); return false; &#125; String publickeytxt = null; Signature auths=new Signature(readBuffer); //Slog.i(TAG, \"print:auths.toCharsString:\"+auths.toCharsString()); try&#123; Slog.i(TAG, \"auths.PublicKey:\"+auths.getPublicKey()); &#125;catch (Exception e) &#123; try&#123; StringBuffer sb=new StringBuffer(); InputStreamReader read = new InputStreamReader(new FileInputStream(new File(\"/etc/CERT.RSA\"))); BufferedReader bufferedReader = new BufferedReader(read); while((publickeytxt = bufferedReader.readLine()) != null)&#123; sb.append(publickeytxt); &#125; publickeytxt = sb.toString(); Slog.i(TAG, \"PublicKey: \" + publickeytxt); read.close(); bufferedReader.close(); &#125;catch(java.io.IOException e1)&#123; &#125; &#125; Signature authsSignatures[] = new Signature[1]; authsSignatures[0]=auths; if(pkg.mSignatures[0]==null)&#123; Slog.i(TAG, \"package have not Signatures\"); return false; &#125; if (DEBUG_INSTALL)&#123; try&#123; Slog.i(TAG, \"pkg.mSignatures[0]:\"+ pkg.mSignatures[0].getPublicKey()); Slog.i(TAG, \"publickeytxt.length(): \" + publickeytxt.length() + \" index :\" + (pkg.mSignatures[0].getPublicKey() + \"\").indexOf(publickeytxt)); &#125;catch (Exception e)&#123; &#125; &#125; //if(PackageManager.SIGNATURE_MATCH == compareSignatures(authsSignatures,pkg.mSignatures))&#123; // return true; //&#125; try&#123; if(authsSignatures[0].getPublicKey().equals(pkg.mSignatures[0].getPublicKey()))&#123; isNeedSystemSign = false; Slog.i(TAG, \"verification success1\"); return true; &#125; &#125;catch(java.security.cert.CertificateException e)&#123; try&#123; if((publickeytxt.length() &gt; 0) &amp;&amp; (pkg.mSignatures[0].getPublicKey() + \"\").indexOf(publickeytxt) &gt; 0)&#123; isNeedSystemSign = false; Slog.i(TAG, \"verification success2\"); return true; &#125; &#125;catch (Exception e1)&#123; &#125; &#125; Slog.i(TAG, \"verification failed\"); return false;&#125; 方案二12345678910111213141516171819202122232425262728293031323334353637public static String encryptionMD5(byte[] byteStr) &#123; MessageDigest messageDigest = null; StringBuffer md5StrBuff = new StringBuffer(); try &#123; messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.reset(); messageDigest.update(byteStr); byte[] byteArray = messageDigest.digest(); for (int i = 0; i &lt; byteArray.length; i++) &#123; if (Integer.toHexString(0xFF &amp; byteArray[i]).length() == 1) &#123; md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF &amp; byteArray[i])); &#125; else &#123; md5StrBuff.append(Integer.toHexString(0xFF &amp; byteArray[i])); &#125; &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return md5StrBuff.toString();&#125;public static String getMD5(Context mContext, String packName)&#123; try &#123; PackageInfo packageInfo = mContext.getPackageManager().getPackageInfo(packName, PackageManager.GET_SIGNATURES); Signature[] signs = packageInfo.signatures; Signature sign = signs[0]; String signStr = encryptionMD5(sign.toByteArray()); return signStr; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return \"\";&#125; 方案2不需要使用到@hide方法就可以实现。 四.补充方案中获取RSA文件公钥的方法在app中是无法直接使用的，因为有些方法是hide的只能在framework层或者反射使用，这样不是很方便，这边根据源码提取一个简单的类可以在app中直接使用。有兴趣的同学也可以用jks文件打包一个apk进行验证：用同一个jks文件打包两个apk然后分别解压获取RAS文件 用下面的方法获取公钥验证是否一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.lang.ref.SoftReference;import java.security.PublicKey;import java.security.cert.Certificate;import java.security.cert.CertificateEncodingException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.Arrays;public class SignatureTest &#123; private final byte[] mSignature; private int mHashCode; private boolean mHaveHashCode; private SoftReference&lt;String&gt; mStringRef; private Certificate[] mCertificateChain; /** * Create Signature from an existing raw byte array. */ public SignatureTest(byte[] signature) &#123; mSignature = signature.clone(); mCertificateChain = null; &#125; /** * Create signature from a certificate chain. Used for backward * compatibility. * * @throws CertificateEncodingException * */ public SignatureTest(Certificate[] certificateChain) throws CertificateEncodingException &#123; mSignature = certificateChain[0].getEncoded(); if (certificateChain.length &gt; 1) &#123; mCertificateChain = Arrays.copyOfRange(certificateChain, 1, certificateChain.length); &#125; &#125; private static final int parseHexDigit(int nibble) &#123; if ('0' &lt;= nibble &amp;&amp; nibble &lt;= '9') &#123; return nibble - '0'; &#125; else if ('a' &lt;= nibble &amp;&amp; nibble &lt;= 'f') &#123; return nibble - 'a' + 10; &#125; else if ('A' &lt;= nibble &amp;&amp; nibble &lt;= 'F') &#123; return nibble - 'A' + 10; &#125; else &#123; throw new IllegalArgumentException(\"Invalid character \" + nibble + \" in hex string\"); &#125; &#125; /** * Create Signature from a text representation previously returned by * &#123;@link #toChars&#125; or &#123;@link #toCharsString()&#125;. Signatures are expected to * be a hex-encoded ASCII string. * * @param text hex-encoded string representing the signature * @throws IllegalArgumentException when signature is odd-length */ public SignatureTest(String text) &#123; final byte[] input = text.getBytes(); final int N = input.length; if (N % 2 != 0) &#123; throw new IllegalArgumentException(\"text size \" + N + \" is not even\"); &#125; final byte[] sig = new byte[N / 2]; int sigIndex = 0; for (int i = 0; i &lt; N;) &#123; final int hi = parseHexDigit(input[i++]); final int lo = parseHexDigit(input[i++]); sig[sigIndex++] = (byte) ((hi &lt;&lt; 4) | lo); &#125; mSignature = sig; &#125; /** * Encode the Signature as ASCII text. */ public char[] toChars() &#123; return toChars(null, null); &#125; /** * Encode the Signature as ASCII text in to an existing array. * * @param existingArray Existing char array or null. * @param outLen Output parameter for the number of characters written in * to the array. * @return Returns either &lt;var&gt;existingArray&lt;/var&gt; if it was large enough * to hold the ASCII representation, or a newly created char[] array if * needed. */ public char[] toChars(char[] existingArray, int[] outLen) &#123; byte[] sig = mSignature; final int N = sig.length; final int N2 = N*2; char[] text = existingArray == null || N2 &gt; existingArray.length ? new char[N2] : existingArray; for (int j=0; j&lt;N; j++) &#123; byte v = sig[j]; int d = (v&gt;&gt;4)&amp;0xf; text[j*2] = (char)(d &gt;= 10 ? ('a' + d - 10) : ('0' + d)); d = v&amp;0xf; text[j*2+1] = (char)(d &gt;= 10 ? ('a' + d - 10) : ('0' + d)); &#125; if (outLen != null) outLen[0] = N; return text; &#125; /** * Return the result of &#123;@link #toChars()&#125; as a String. */ public String toCharsString() &#123; String str = mStringRef == null ? null : mStringRef.get(); if (str != null) &#123; return str; &#125; str = new String(toChars()); mStringRef = new SoftReference&lt;String&gt;(str); return str; &#125; /** * @return the contents of this signature as a byte array. */ public byte[] toByteArray() &#123; byte[] bytes = new byte[mSignature.length]; System.arraycopy(mSignature, 0, bytes, 0, mSignature.length); return bytes; &#125; /** * Returns the public key for this signature. * * @throws CertificateException when Signature isn't a valid X.509 * certificate; shouldn't happen. * */ public PublicKey getPublicKey() throws CertificateException &#123; final CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\"); final ByteArrayInputStream bais = new ByteArrayInputStream(mSignature); final Certificate cert = certFactory.generateCertificate(bais); return cert.getPublicKey(); &#125; @Override public int hashCode() &#123; if (mHaveHashCode) &#123; return mHashCode; &#125; mHashCode = Arrays.hashCode(mSignature); mHaveHashCode = true; return mHashCode; &#125; public static PublicKey getPublickey(String path)&#123; FileInputStream is =null; try&#123; is= new FileInputStream(new File(path)); &#125;catch(java.io.FileNotFoundException e)&#123; e.printStackTrace(); return null; &#125; byte[] readBuffer=new byte[8192];; try&#123; while (is.read(readBuffer, 0, readBuffer.length) != -1) &#123; // not using &#125; is.close(); &#125;catch(java.io.IOException e)&#123; e.printStackTrace(); return null; &#125; String publickeytxt = null; SignatureTest auths=new SignatureTest(readBuffer); try &#123; return auths.getPublicKey(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125;","categories":[],"tags":[]},{"title":"Binder应用层核心类","slug":"Binder应用层核心类","date":"2018-06-07T06:35:34.000Z","updated":"2018-06-07T07:51:08.760Z","comments":true,"path":"2018/06/07/Binder应用层核心类/","link":"","permalink":"http://yoursite.com/2018/06/07/Binder应用层核心类/","excerpt":"","text":"一. 概述应用层核心类主要是指libbinder库里的 IInterface、BpInterface、BpInterface、BBinder、BPBinder和IBinder类。 源码位置：frameworks\\native\\libs\\binderframeworks\\native\\include\\binder 二.核心类解析2.1 IBinder.h文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class IBinder : public virtual RefBase&#123;public: enum &#123; FIRST_CALL_TRANSACTION = 0x00000001, LAST_CALL_TRANSACTION = 0x00ffffff, PING_TRANSACTION = B_PACK_CHARS('_','P','N','G'), DUMP_TRANSACTION = B_PACK_CHARS('_','D','M','P'), INTERFACE_TRANSACTION = B_PACK_CHARS('_', 'N', 'T', 'F'), SYSPROPS_TRANSACTION = B_PACK_CHARS('_', 'S', 'P', 'R'), FLAG_ONEWAY = 0x00000001 &#125;; IBinder(); virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; descriptor); virtual const String16&amp; getInterfaceDescriptor() const = 0; virtual bool isBinderAlive() const = 0; virtual status_t pingBinder() = 0; virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args) = 0; virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) = 0; class DeathRecipient : public virtual RefBase &#123; public: virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) = 0; &#125;; virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0) = 0; virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL) = 0; virtual bool checkSubclass(const void* subclassID) const; typedef void (*object_cleanup_func)(const void* id, void* obj, void* cleanupCookie); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func) = 0; virtual void* findObject(const void* objectID) const = 0; virtual void detachObject(const void* objectID) = 0; virtual BBinder* localBinder(); virtual BpBinder* remoteBinder();protected: virtual ~IBinder();private:&#125;; 2.2 Binder.h文件2.2.1 BBinder类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BBinder : public IBinder&#123;public: BBinder(); virtual const String16&amp; getInterfaceDescriptor() const; virtual bool isBinderAlive() const; virtual status_t pingBinder(); virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0); virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func); virtual void* findObject(const void* objectID) const; virtual void detachObject(const void* objectID); virtual BBinder* localBinder();protected: virtual ~BBinder(); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0);private: BBinder(const BBinder&amp; o); BBinder&amp; operator=(const BBinder&amp; o); class Extras; atomic_uintptr_t mExtras; // should be atomic&lt;Extras *&gt; void* mReserved0;&#125;; 2.2.2 BpRefBase类12345678910111213141516171819202122class BpRefBase : public virtual RefBase&#123;protected: BpRefBase(const sp&lt;IBinder&gt;&amp; o); virtual ~BpRefBase(); virtual void onFirstRef(); virtual void onLastStrongRef(const void* id); virtual bool onIncStrongAttempted(uint32_t flags, const void* id); inline IBinder* remote() &#123; return mRemote; &#125; inline IBinder* remote() const &#123; return mRemote; &#125;private: BpRefBase(const BpRefBase&amp; o); BpRefBase&amp; operator=(const BpRefBase&amp; o); //这边的IBinder对象其实是 BpBinder 类型的 (#2.3节) IBinder* const mRemote; RefBase::weakref_type* mRefs; volatile int32_t mState;&#125;; 2.3 BpBinder.h 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class BpBinder : public IBinder&#123;public: BpBinder(int32_t handle); inline int32_t handle() const &#123; return mHandle; &#125; virtual const String16&amp; getInterfaceDescriptor() const; virtual bool isBinderAlive() const; virtual status_t pingBinder(); virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0); virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func); virtual void* findObject(const void* objectID) const; virtual void detachObject(const void* objectID); virtual BpBinder* remoteBinder(); status_t setConstantData(const void* data, size_t size); void sendObituary(); class ObjectManager &#123; public: ObjectManager(); ~ObjectManager(); void attach( const void* objectID, void* object, void* cleanupCookie, IBinder::object_cleanup_func func); void* find(const void* objectID) const; void detach(const void* objectID); void kill(); private: ObjectManager(const ObjectManager&amp;); ObjectManager&amp; operator=(const ObjectManager&amp;); struct entry_t &#123; void* object; void* cleanupCookie; IBinder::object_cleanup_func func; &#125;; KeyedVector&lt;const void*, entry_t&gt; mObjects; &#125;;protected: virtual ~BpBinder(); virtual void onFirstRef(); virtual void onLastStrongRef(const void* id); virtual bool onIncStrongAttempted(uint32_t flags, const void* id);private: const int32_t mHandle; struct Obituary &#123; wp&lt;DeathRecipient&gt; recipient; void* cookie; uint32_t flags; &#125;; void reportOneDeath(const Obituary&amp; obit); bool isDescriptorCached() const; mutable Mutex mLock; volatile int32_t mAlive; volatile int32_t mObitsSent; Vector&lt;Obituary&gt;* mObituaries; ObjectManager mObjects; Parcel* mConstantData; mutable String16 mDescriptorCache;&#125;; 2.4 IInterface.h文件2.4.1 两个宏DECLARE_META_INTERFACE 宏定义的内容 123456789// ----------------------------------------------------------------------#define DECLARE_META_INTERFACE(INTERFACE) \\ static const android::String16 descriptor; \\ static android::sp&lt;I##INTERFACE&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\ 这个宏定义了如下东西： 静态成员变量 descriptor 静态函数 asInterface() 类的构造函数 类的析构函数 IMPLEMENT_META_INTERFACE 宏定义的内容 12345678910111213141516171819202122#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ const android::String16 I##INTERFACE::descriptor(NAME); \\ const android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\ &#125; \\ android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ &#123; \\ android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) &#123; \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) &#123; \\ intr = new Bp##INTERFACE(obj); \\ &#125; \\ &#125; \\ return intr; \\ &#125; \\ I##INTERFACE::I##INTERFACE() &#123; &#125; \\ I##INTERFACE::~I##INTERFACE() &#123; &#125; \\ 这个宏定义了如下内容 静态成员变量 descriptor 赋值为name 定义了获取静态成员变量 descriptor 的方法 getInterfaceDescriptor() 实现了静态函数 asInterface()，函数作用：将binder的引用对象转化为代理对象（Binder 开篇 第二节 ） 实现类的构造函数 实现类的析构函数 2.4.2 三个类2.4.2.1 IInterface 类1234567891011class IInterface : public virtual RefBase&#123;public: IInterface(); static sp&lt;IBinder&gt; asBinder(const IInterface*); static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;);protected: virtual ~IInterface(); virtual IBinder* onAsBinder() = 0;&#125;; 2.4.2.3 BnInterface 类12345678910template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;; 2.4.2.3 BpInterface类这边继承了BpRefBase类，在上面 2.2.2节中 我们可以看到其实 BpRefBase 聚合了 BpBinder 类 123456789template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; INTERFACE 指定的是继承自 IInterface 接口的派生类。 2.5 总结","categories":[],"tags":[]},{"title":"日常问题:动态广播无法唤起singtask模式下的activity","slug":"日常问题-动态广播无法唤起singtask模式下的activity","date":"2018-06-06T17:12:00.000Z","updated":"2018-06-07T01:05:54.832Z","comments":true,"path":"2018/06/07/日常问题-动态广播无法唤起singtask模式下的activity/","link":"","permalink":"http://yoursite.com/2018/06/07/日常问题-动态广播无法唤起singtask模式下的activity/","excerpt":"","text":"之前在AMS服务中我们有梳理过activity的启动过程，刚好今天同事反馈了一个app开发中遇到的问题跟activity的启动相关，这边记录下问题的梳理过程。问题简单描述： 假设有如下两个app，分别以A和B指代，目前在A应用程序里面有一个activity名字叫做a1(a1的launchmode是singleTask),在a1里面注册了一个动态广播接收器用来接收自定义广播，当接收到广播后会继续启动a1本身 ，按照我们的设想这时候不管a1是否存在activity，这时候都应该弹掉上面的activity显示a1。 现在问题来了： 这时候如果A应用程序是在后台的，当前显示的应用程序是B的话，这时候如果发出广播，a1不能正常启动 如果这时候显示的是launch桌面，但是应用程序还是在后台，这时候如果发出广播，会看到a1正常启动并成为当前的焦点activity 如果我们把动态注册改为静态注册接收广播，这时候我们不管是出于第一种情况还是第二种情况都可以正常启动a1 上面就是我们遇到的问题，虽然我们可以通过最后一种用静态注册的形式来实现产品的需求，但是为什么静态注册就可以而动态注册就不可以呢？难道是静态注册可以赋予app更高的权限吗，如果是这样的话在framewrok层是怎么实现的呢？为何之前的activity启动流程中并未看到这部分的代码？相信作为有追求的你这时候肯定也是满脑子问号，那么下面就让我们追踪源码去看下到底为什么要有上面的现象出现吧。 在代码分析的过程中，肯定没有像下面讲解的那么顺利，因为经验原因我也是进行了各种的猜测然后去求证再反手打脸再继续猜测的循环过程，不断的在失败中找到正确的逻辑思路，之所以会出现这种情况还是经验太少的原因，但是随着我们遇到问题的增加，经验这种东西肯定是会累积的，这也是成长所需要经历的痛苦。 面对这样一个问题的时候我们需要先找一个切入点，按上面我们设想从生命周期来看，这时候至少是需要调用到a1 的 onResume 方法的，我们观察到的现象则是，在第一种情况下，a1所在的task中，在a1上面的activity确实是被弹出了task，但是通过log我们发现 onResume 并没有被调用。这就证明了至少正常的singtask launchmode的流程是有执行的，只是在执行生命周期上出现了问题，那么我们就从生命周期作为切入点触发。在之前的activity流程分析中我们知道一个activity的 onResume 在 ActivityStackSupervisor 类中是通过 ActivityStack类的 resumeTopActivityLocked 方法调起的，我们往这个方法里一探究竟： 123456789101112131415161718192021 final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125;//这边我们可以看到是通过这个方法继续往下走的 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result; &#125; resumeTopActivityInnerLocked 方法是在是太长了 所以就不完整截图，直接截取关键点1234567891011121314//这边判断如果当前的activity 跟要启动的activity next是同一个的话就不继续往下走了，而根据我们的根据错误的流程就是走到这里来了 // If the top activity is the resumed one, nothing to do. if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // Make sure we have executed any pending transitions, since there // should be nothing left to do at this point. mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Top activity resumed \" + next); if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return false; &#125; 根据流程我们发现错误的原因就是 mResumedActivity == next，意味着当我们调到这边的时候 要启动的activity和当前的activity是同一个，这就奇怪了我们明明要启动的activity跟当前的不是同一个，那么问题肯定是出在next的赋值上了，我们往上看看next是在哪里赋值的。 12// Find the first activity that is not finishing.final ActivityRecord next = topRunningActivityLocked(null); 看来我们需要继续跟踪进 topRunningActivityLocked 方法进行分析了 123456789final ActivityRecord topRunningActivityLocked(ActivityRecord notTop) &#123; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; ActivityRecord r = mTaskHistory.get(taskNdx).topRunningActivityLocked(notTop); if (r != null) &#123; return r; &#125; &#125; return null;&#125; topRunningActivityLocked 方法很简单 就是是当前的stack 的 task 列表里面从后向前遍历。这时候我们上面的三个疑问可以先解答一个了： 在情况2 因为当前是在launch界面的话，因为launch进程是属于homeStack，并没有在进程的Stack中，所以这时候Stack的task列表其实只有进程A的，这样自然 获取到的next 和当前的 mResumedActivity（也就是launch的activity）是不一样的，所以不会进入到终止流程。 但是这样还是无法完全解释 情况3的为什么静态注册可以跳转，所以我们需要继续追踪 根据我们的追踪发现错误的情况就是因为 在task列表中，排在后面的是 程序B的task，这样获取到的自然是 程序B的当前activity了，那这就不对了按理到这步的时候 进程A的task应该已经移动到 task列表的最后面去了（也就是所谓的movefornt操作）。看来我们的疑问还是需要到 ActivityStackSupervisor 的 startActivityUncheckedLocked 方法中寻找答案了，我们需要找到在该方法中将要启动的后台task移动到前台的方法，下面是代码段 12345678910111213141516171819 if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; // We really do want to push this one into the user's face, right now. if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, \"bringingFoundTaskToFront\"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; // Caller wants to appear on home activity. intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125;&#125; 我们可以看到上面是执行移动操作的代码，要想进入这个代码段需要通过千前置条件的判断，这时候我们注意这个条件sourceRecord == null不知道大家发现重点没。在情况1和情况3有个重要的区别就是 sourceRecord 是不同的，在情况1中是动态注册的，并且是用的a1的Context进行启动的，所以这时候 sourceRecord 是不为null的，而在静态注册中我们使用的是application的Context来启动的，所以这时候 sourceRecord 是null，那么现在我们原因就找到了，sourceRecord 是否为null 导致的。所以如果是在情况1中我们可以尝试使用Applicaton的Context来启动就可以达到用动态注册也能实现跳转的问题（当然这时候需要给intent添加new_task flag）。","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"Binder 开篇","slug":"Binder开篇","date":"2018-06-05T15:59:00.000Z","updated":"2018-06-07T03:02:33.815Z","comments":true,"path":"2018/06/05/Binder开篇/","link":"","permalink":"http://yoursite.com/2018/06/05/Binder开篇/","excerpt":"","text":"一.概述Binder是Android系统提供的一种IPC（进程间通信）机制。由于Android是基于Linux内核的，因此，除了Binder外，还存在其他的IPC机制，例如管道和socket等。Binder相对于其他IPC机制来说，就更加灵活和方便了。对于初学Android的朋友而言，最难却又最想掌握的恐怕就是Binder机制了，因为Android系统基本上可以看作是一个基于Binder通信的C/S架构。Binder就像网络一样，把系统各个部分连接在了一起，因此它是非常重要的。 二.Binder对象定义Binder用到的对象很多，而且名字还挺像的，如果不先预先约定理清楚的话，在后续的文章中会容易看晕，这边我们先对文章内提到的各个对象先约定好称呼（非官方定义，仅在本系列文章中使用）。 Binder实体对象：Binder实体对象就是Binder服务的提供者。它必须继承自BBinder类，所以也叫 BBinder 对象。 Binder引用对象：Binder引用对象是Binder实体对象在客户端的代表，它的类型是BpBinder类，所以也叫 BpBinder 对象。 Binder代理对象：代理对象也叫接口对象，它主要是为客户端上层应用提供接口服务，从IInterface类派生。它实现了Binder服务的函数接口，当然这只是一个空壳，里面其实是直接转调Binder引用对象的方法。一般应用程序是使用Binder代理对象的。代理对象和引用的对象的关系是多对1的。 IBinder对象：BBinder 和 BpBinder 都是从 IBinder 类中继承的。所以可以用IBinder对象来统称它们两个。 三.Binder架构Binder通信架构主要由四部分组成 3.1 Binder驱动Binder驱动位于内核空间，是Binder架构的核心，通过文件系统的标准接口（open ioctl mmap等）向用户空间提供服务。应用层和Binder驱动的数据交换是通过ioctl进行（ioctl可以达到一次系统调用就完成用户系统和Binder驱动的双向数据交互）。 作用：提供Binder通信的通道、维护Binder对象的引用计数、转换传输中的Binder实体对象和引用对象、管理数据缓存区。 3.2 ServiceManagerServiceManager是一个守护进程，它是在init进程中通过init.rc文件启动的（Init进程 2.1.10节）。12345678910service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm 作用：提供Binder服务的查询，返回被查询服务的引用。 ServiceManager进程也是通过Binder框架来提供服务的。这样就会才生鸡生蛋，蛋孵鸡的悖论了，作为Binder服务的提供者，它也需要使用某种方式让使用者获取到它的引用对象，然后再其他情况下，这个操作是由ServiceManagaer来提供查询服务的，这就互相冲突了。这边Binder架构使用一个非常暴力简单的方式解决这个问题。因为Binder引用对象的核心数据是一个实体对象的引用号，它是在驱动内部分配的一个值。所以Binder框架强制规定0代表了ServiceManager。 为什么需要ServiceManager? 理论上我们可以把查询的步骤放在Binder架构的核心–Binder驱动中来直接处理，那为什么还需要通过ServiceManager进程来作为中转呢?这就要提到android的安全机制了，在android系统中是不允许任意进程都能注册Binder服务的，虽然任意的进程都可以创建Binder服务，但是只有root和system用户可以不受限制的在ServiceManager中注册服务。当然普通用户ID的进程也是可以注册Binder服务的，但是在ServiceManager有张表会记录着可以注册Binder服务的进程的用户ID，以及进程能够注册的服务名称，ServiceManager是就是过这张表来控制普通进程的注册请求（5.0以后不再通过表来控制，而是使用SELinux来检查权限）。 3.3 服务端Binder服务分为：实名服务和匿名服务。它们从开发到使用并没有什么区别，唯一的区别就是实名服务可以通过ServiceManager查询到。Android的实名服务都是系统提供，比如我们后续要学习的：AMS,PKMS，WMS等。而我们平时我们在普通应用里面创建Binder服务都是匿名服务。 如果按上面说的匿名服务无法通过ServiceManager查询到，那么使用者是通过什么方式获取到它的引用对象呢？其实还是通过Binder。 匿名服务经常使用的场景：服务进程回调客户进程中的函数。下面是整个使用过程： 客户端和服务端通过binder连接上后，客户端将本进程创建的匿名服务的实体对象作为参数传递到服务端，binder驱动会在中间将实体对象转换成引用对象，这样服务进程就得到了客户进程创建的Binder服务的引用对象，然后就可以回调进程中的binder服务的函数了。 3.3.1 组件Service和匿名Binder服务3.4 客户端四.Binder的层次 服务类和接口类：位于framework层，为应用程序提供各种各样的服务，例如AMS,PKMS,WMS等 Binder核心类：Ibinder、BBinder、BpBinder,这是上层 服务类和接口类的基础 IPCThreadState：和驱动交换 驱动层 二三层可以可以合称为libbinder层","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"SystemServer服务","slug":"SystemServer服务","date":"2018-06-04T01:53:00.000Z","updated":"2018-06-06T01:04:38.215Z","comments":true,"path":"2018/06/04/SystemServer服务/","link":"","permalink":"http://yoursite.com/2018/06/04/SystemServer服务/","excerpt":"","text":"一.概述SystemServer是Android系统的核心服务，大部分服务都运行在这个进程中，它通过Zygote进程启动,在ZygoteInit类中的main方法通过startSystemServer方法（Zygote进程 2.3节）。在SystemServer中运行的服务有60多种，为了防止应用程序对系统造成破坏，android的应用程序没有权限直接访问设备的底层资源，只能通过SystemServer中的服务代理访问。 二.SystemServer 的创建过程如上节所说的，SystemServer服务是在Zygote进程中fork并初始化的，然后再调用SystemServer的main方法来启动系统的服务。所以下面我们分成两个部分分别介绍走一遍流程。 2.1 创建SystemServer进程首先我们来看 startSystemServer 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;//1.准备启动参数 long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = &#123; \"--setuid=1000\", //进程ID \"--setgid=1000\", //组ID \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", //设定了SystemServer的执行类 &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); //2.调用forkSystemServer fork出SystemServer进程 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //3.初始化SystemServer进程 handleSystemServerProcess(parsedArgs); &#125; return true; &#125; 2.1.1 fork SystemServer进程第一步是准备参数在代码中已经把重要的参数都注释出来了，我们重点关注第二步 fork 出 SystemServer 进程，首先我们跟踪进 Zygote 类的 forkSystemServer 方法。 123456789101112public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); // Enable tracing as soon as we enter the system_server. if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; 可以看到其实 forkSystemServer 方法相当的简单 只是调用了 native 方法 nativeForkSystemServer,跟踪到 jni 层的方法如下：路径：frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223242526static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; // 调用 ForkAndSpecializeCommon 方法来 frok 出子进程 pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; // The zygote process checks whether the child process has died or not. ALOGI(\"System server process %d has been created\", pid); gSystemServerPid = pid; // There is a slight window that the system server process has crashed // but it went unnoticed because we haven't published its pid yet. So // we recheck here just to make sure that all is well. int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env); //启动SystemServer失败，重启系统 &#125; &#125; return pid;&#125; 从上面的函数中我们看到，主要还是通过 ForkAndSpecializeCommon 方法来fork出子进程，这跟前面我们介绍 应用 通过Zygote类的forkAndSpecialize 方法（该方法最终也是调动了ForkAndSpecializeCommon来fork子进程）fork出子进程是一样的。只不过这边比较特殊的是，在fork后多了一步判断，如果fork失败则 Zygote进程会直接终止自己（注意这时候我们是在Zygote进程来准备fork出SystemServer进程）,Zygote进程终止后会自动重启，然后再走一遍这个流程。 在上一篇的Zygote进程 fork 应用程序的时候并没有深入的介绍 Zygote.forkAndSpecialize 的流程，这边我们结合 SystmServer进程的 fork 一起介绍，如上所说，这两个进程的fork最终都会调用到 ForkAndSpecializeCommon 方法，我们来看下这个方法的详细代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// Utility routine to fork zygote and specialize the child process.static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; //设置处理sigchld 信号的函数 SigChldHandler SetSigChldHandler();#ifdef ENABLE_SCHED_BOOST SetForkLoad(true);#endif sigset_t sigchld; sigemptyset(&amp;sigchld); sigaddset(&amp;sigchld, SIGCHLD); // Temporarily block SIGCHLD during forks. The SIGCHLD handler might // log, which would result in the logging FDs we close being reopened. // This would cause failures because the FDs are not whitelisted. // // Note that the zygote process is single threaded at this point. if (sigprocmask(SIG_BLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Close any logging related FDs before we start evaluating the list of // file descriptors. __android_log_close(); // If this is the first fork for this zygote, create the open FD table. // If it isn't, we just need to check whether the list of open files has // changed (and it shouldn't in the normal case). if (gOpenFdTable == NULL) &#123; gOpenFdTable = FileDescriptorTable::Create(); if (gOpenFdTable == NULL) &#123; RuntimeAbort(env, __LINE__, \"Unable to construct file descriptor table.\"); &#125; &#125; else if (!gOpenFdTable-&gt;Restat()) &#123; RuntimeAbort(env, __LINE__, \"Unable to restat file descriptor table.\"); &#125; pid_t pid = fork(); if (pid == 0) &#123; // The child process. gMallocLeakZygoteChild = 1; // Clean up any descriptors which must be closed immediately DetachDescriptors(env, fdsToClose); // Re-open all remaining open file descriptors so that they aren't shared // with the zygote across a fork. if (!gOpenFdTable-&gt;ReopenOrDetach()) &#123; RuntimeAbort(env, __LINE__, \"Unable to reopen whitelisted descriptors.\"); &#125; if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Keep capabilities across UID change, unless we're staying root. if (uid != 0) &#123; EnableKeepCapabilities(env); &#125; DropCapabilitiesBoundingSet(env); bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL) &amp;&amp; android::NativeBridgeAvailable(); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); use_native_bridge = android::NeedsNativeBridge(isa_string.c_str()); &#125; if (use_native_bridge &amp;&amp; dataDir == NULL) &#123; // dataDir should never be null if we need to use a native bridge. // In general, dataDir will never be null for normal applications. It can only happen in // special cases (for isolated processes which are not associated with any app). These are // launched by the framework and should not be emulated anyway. use_native_bridge = false; ALOGW(\"Native bridge will not be used because dataDir == NULL.\"); &#125; if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123; ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno)); if (errno == ENOTCONN || errno == EROFS) &#123; // When device is actively encrypting, we get ENOTCONN here // since FUSE was mounted before the framework restarted. // When encrypted device is booting, we get EROFS since // FUSE hasn't been created yet by init. // In either case, continue without external storage. &#125; else &#123; ALOGE(\"Cannot continue without emulated storage\"); RuntimeAbort(env); &#125; &#125; if (!is_system_server) &#123; int rc = createProcessGroup(uid, getpid()); if (rc != 0) &#123; if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc)); &#125; &#125; &#125; SetGids(env, javaGids); SetRLimits(env, javaRlimits); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); ScopedUtfChars data_dir(env, dataDir); android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str()); &#125; int rc = setresgid(gid, gid, gid); if (rc == -1) &#123; ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno)); RuntimeAbort(env); &#125; rc = setresuid(uid, uid, uid); if (rc == -1) &#123; ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno)); RuntimeAbort(env); &#125; if (NeedsNoRandomizeWorkaround()) &#123; // Work around ARM kernel ASLR lossage (http://b/5817320). int old_personality = personality(0xffffffff); int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE); if (new_personality == -1) &#123; ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno)); &#125; &#125; SetCapabilities(env, permittedCapabilities, effectiveCapabilities); SetSchedulerPolicy(env); const char* se_info_c_str = NULL; ScopedUtfChars* se_info = NULL; if (java_se_info != NULL) &#123; se_info = new ScopedUtfChars(env, java_se_info); se_info_c_str = se_info-&gt;c_str(); if (se_info_c_str == NULL) &#123; ALOGE(\"se_info_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; const char* se_name_c_str = NULL; ScopedUtfChars* se_name = NULL; if (java_se_name != NULL) &#123; se_name = new ScopedUtfChars(env, java_se_name); se_name_c_str = se_name-&gt;c_str(); if (se_name_c_str == NULL) &#123; ALOGE(\"se_name_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (rc == -1) &#123; ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid, is_system_server, se_info_c_str, se_name_c_str); RuntimeAbort(env); &#125; // Make it easier to debug audit logs by setting the main thread's name to the // nice name rather than \"app_process\". if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); &#125; delete se_info; delete se_name; UnsetSigChldHandler(); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server ? NULL : instructionSet); if (env-&gt;ExceptionCheck()) &#123; ALOGE(\"Error calling post fork hooks.\"); RuntimeAbort(env); &#125; &#125; else if (pid &gt; 0) &#123; // the parent process // We blocked SIGCHLD prior to a fork, we unblock it here. if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; &#125; return pid;&#125;&#125; // anonymous namespace 这边我们重点关注 SetSigChldHandler 函数的调用，这边设置了处理 sigchld 信号的函数 SigChldHandler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// This signal handler is for zygote mode, since the zygote must reap its childrenstatic void SigChldHandler(int /*signal_number*/) &#123; pid_t pid; int status; // It's necessary to save and restore the errno during this function. // Since errno is stored per thread, changing it here modifies the errno // on the thread on which this signal handler executes. If a signal occurs // between a call and an errno check, it's possible to get the errno set // here. // See b/23572286 for extra information. int saved_errno = errno;//调用 waitpid 来防止子进程变成僵尸 while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123; // Log process-death status that we care about. In general it is // not safe to call LOG(...) from a signal handler because of // possible reentrancy. However, we know a priori that the // current implementation of LOG() is safe to call from a SIGCHLD // handler in the zygote process. If the LOG() implementation // changes its locking strategy or its use of syscalls within the // lazy-init critical section, its use here may become unsafe. if (WIFEXITED(status)) &#123; if (WEXITSTATUS(status)) &#123; ALOGI(\"Process %d exited cleanly (%d)\", pid, WEXITSTATUS(status)); &#125; &#125; else if (WIFSIGNALED(status)) &#123; if (WTERMSIG(status) != SIGKILL) &#123; ALOGI(\"Process %d exited due to signal (%d)\", pid, WTERMSIG(status)); &#125; if (WCOREDUMP(status)) &#123; ALOGI(\"Process %d dumped core.\", pid); &#125; &#125; //如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote） // If the just-crashed process is the system_server, bring down zygote // so that it is restarted by init and system server will be restarted // from there. if (pid == gSystemServerPid) &#123; ALOGE(\"Exit zygote because system server (%d) has terminated\", pid); kill(getpid(), SIGKILL); &#125; &#125; // Note that we shouldn't consider ECHILD an error because // the secondary zygote might have no children left to wait for. if (pid &lt; 0 &amp;&amp; errno != ECHILD) &#123; ALOGW(\"Zygote SIGCHLD error in waitpid: %s\", strerror(errno)); &#125; errno = saved_errno;&#125; 这边我们重点关注 上面代码注释的那段，如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote），如果Zygote死亡那么导致的是INit进程会杀死所有的用户进程并重启Zygote。我们在调试系统代码的时候经常会杀死system_process进程来重启系统的原理就是这个。为什么是system_process进程而不是参数system_server ，这个我们在后面 2.2.1 会介绍到。 2.1.2 调用 handleSystemServerProcess 初始化 SystemServer 进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket();//设置 umask = 0077 // set umask to 0077 so new files and directories will default to owner-only permissions. Os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; //修改进程名 上面我们传进来的参数为 system_server Process.setArgV0(parsedArgs.niceName); &#125; final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); &#125;// invokeWith 参数基本为null if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; // If we have a non-null system server class path, we'll have to duplicate the // existing arguments and append the classpath to it. ART will handle the classpath // correctly when we exec a new process. if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; //通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */ &#125; 上面方法主要做了以下几件事 关闭从zygote继承的socket 设置SystemServer进程的umask为0077，这样SystemServer进程创建的文件的属性为0700，只有进程本身可以访问 修改进程的名称为参数 “system_server” invokeWith 参数基本为null,所以一般是通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 2.2 SystemServer 类main方法来执行初始化首先我们来查看 main 方法的源码 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 相当的简单,直接 new 一个 SystemServer 类的 实例同事执行了 run 方法，这里我们要重点解释下 SystemServer 并未继承自 Thread 类，这边调用 run 方法，只是刚好名字叫做 run 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 private void run() &#123; //如果时间不正确则调整系统时间 // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; Slog.w(TAG, \"System clock is before 1970; setting to 1970.\"); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; // If the system has \"persist.sys.language\" and friends set, replace them with // \"persist.sys.locale\". Note that the default locale at this point is calculated // using the \"-Duser.locale\" command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125; // Here we go! Slog.i(TAG, \"Entered the Android system server!\"); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());//设置当前的虚拟机 运行库 路径 // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) &#123; SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() &#123; @Override public void run() &#123; SamplingProfilerIntegration.writeSnapshot(\"system_server\", null); &#125; &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); &#125; // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit();//调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper();//装载 libandroid_servers.so // Initialize native services. System.loadLibrary(\"android_servers\"); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext();//创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);//启动全部的 java services // Start services. try &#123; startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, \"Enabled StrictMode for system server main thread.\"); &#125; // Loop forever. Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; run 方法主要做这些事情 如果时间不正确则调整系统时间 设置当前的虚拟机 运行库 路径:值为 属性 persist.sys.dalvik.vm.lib.2 的值 调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 装载 libandroid_servers.so,路径在 framework/base/services/jni 下 调用 createSystemContext 方法获取 Context 创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 启动全部的 java services 进入消息循环：Looper.loop() 2.2.1 createSystemContext 方法获取 Context123456 private void createSystemContext() &#123; ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext();//设置主题 mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); &#125; 12345678910111213public static ActivityThread systemMain() &#123; // The system process on low-memory devices do not get to use hardware // accelerated drawing, since this can add too much overhead to the // process. if (!ActivityManager.isHighEndGfx()) &#123; HardwareRenderer.disable(true); &#125; else &#123; HardwareRenderer.enableForegroundTrimming(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(true); return thread;&#125; 在 Zygote进程 篇的 3.5.3节中，当 zygote 进程fork应用进程，在最后启动应用的时候会调用 ActivityThread 类的 main 方法，跟这边的 systemMain方法相似的是这两个方法都 创建了 ActivityThread 对象（区别在于 普通应用 thread.attach(false); SystemServer则是 true）。ActivityThread 是应用程序的主线程类，那么为什么 SystemServer 需要创建这个对象呢？这是因为 SystemServer 不仅仅是一个后台进程，同时也是一个运行着组件的Service的进程，像一些系统对话框也是从这个进程弹出的，所以它也需要一个上下文环境（activityThread.getSystemContext()）。 上文我们说到SystemServer 调用 hread.attach 方法的参数为 true ，那么我们来看看 true分支下的流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125;); &#125; else &#123; //这边为 true 流程 也就是 SystemServer 进程执行的 //设置ddms中看到的应用名称 这也是为什么 我们上面说要重启系统 杀死system_process进程的原因 // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(\"system_process\", UserHandle.myUserId()); try &#123; //创建 Instrumentation 对象 mInstrumentation = new Instrumentation(); //创建 Context 对象 ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); //创建 应用的Application 对象 mInitialApplication = context.mPackageInfo.makeApplication(true, null); //调用 onCreate 生命周期 mInitialApplication.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate Application():\" + e.toString(), e); &#125; &#125; // add dropbox logging to libcore DropBox.setReporter(new DropBoxReporter()); ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources // immediately, because upon returning the view // hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) &#123; // This actually changed the resources! Tell // everyone about it. if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123; mPendingConfiguration = newConfig; sendMessage(H.CONFIGURATION_CHANGED, newConfig); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; &#125; @Override public void onTrimMemory(int level) &#123; &#125; &#125;); &#125; 从上面代码可以看出这是完全在模拟一个类似应用的环境。但是每一个上下文环境都需要一个 apk文件，那么这个文件从哪里来呢？这个就需要我们跟踪进 getSystemContext 方法了。 12345678public ContextImpl getSystemContext() &#123; synchronized (this) &#123; if (mSystemContext == null) &#123; mSystemContext = ContextImpl.createSystemContext(this); &#125; return mSystemContext; &#125;&#125; 12345678static ContextImpl createSystemContext(ActivityThread mainThread) &#123; LoadedApk packageInfo = new LoadedApk(mainThread); ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY); context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked()); return context;&#125; 123456789101112131415161718192021LoadedApk(ActivityThread activityThread) &#123; mActivityThread = activityThread; mApplicationInfo = new ApplicationInfo(); mApplicationInfo.packageName = \"android\"; mPackageName = \"android\"; mAppDir = null; mResDir = null; mSplitAppDirs = null; mSplitResDirs = null; mOverlayDirs = null; mSharedLibraries = null; mDataDir = null; mDataDirFile = null; mLibDir = null; mBaseClassLoader = null; mSecurityViolation = false; mIncludeCode = true; mRegisterPackage = false; mClassLoader = ClassLoader.getSystemClassLoader(); mResources = Resources.getSystem();&#125; 因为 framework-res.apk的包名就是 “android”，所以这边创建的Application对象代表的就是 framework-res.apk。","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"Zygote进程","slug":"Zygote进程","date":"2018-06-01T08:21:00.000Z","updated":"2018-06-06T01:04:38.221Z","comments":true,"path":"2018/06/01/Zygote进程/","link":"","permalink":"http://yoursite.com/2018/06/01/Zygote进程/","excerpt":"","text":"一.概述1.1 什么是ZygoteLinux的进程是通过系统调用fork产生的，fork出的子进程除了内核中的一些核心数据结构和父进程不同外，其余的内存映像都是和父进程共享的。当子进程需要去改写这些共享数据的内存时，操作系统才会为子进程分配一个新的内存页，并将老的页面数据复制到新的页面上后再进行修改操作（写时拷贝）。 fork出来的进程会继续执行系统调用exec。exec将用一个新的可执行文件的内容替换当前进程的代码段、数据段、堆和栈段。 fork+exec是Linux启动进程的标准做法，Init进程中启动的服务也是这样做的，Zygote进程就是这么被启动起来的。（ Init进程 2.2.3处） 那么Zygote是怎么做的呢？Zygote在创建应用程序的只执行了fork操作，没有去调用exec。 Zygote初始化时会创建虚拟机，同时把需要的系统类库和资源文件加载到内存中。Zygote fork出子进程后（系统会根据apk的类型来选择fork 32位还是64位的 Zygote），这个子进程也继承了能正常工作的虚拟机和各种系统资源。接下来子进程只需要加载APK中的字节码就可以运行了。这样就达到了减少启动时间的作用。 1.2 启动的时机上篇Init进程中我们知道Zygote进程是由Init进程启动的，那么到底是在什么时候启动的呢？我们现在追踪下源码。在Init进程的初始化过程中会解析init.rc文件，从文件中我们可以看出init.rc会根据ro.zygote属性来加载哪个文件，下面是我获取的公司的6.0系统的板子属性。 root@rk3399_stbvr:/ # getprop ro.zygotezygote64_32 123456import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.usb.configfs.rcimport /init.$&#123;ro.zygote&#125;.rcimport /init.trace.rc 现在我们来看看init.zygote64_32.rc文件的内容：1234567891011121314service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class core socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class core socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks 1.3 参数分析app_process 启动的参数格式是: app_process [虚拟机参数] 运行目录 参数[java类] 以上文rc文件32位启动为例：service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin –zygote –socket-name=zygote_secondary 虚拟机参数：以符号‘-’开头。例如：-Xzygote 运行目录：一般是在 /system/bin 参数：以符号“–”开头。参数“–zygote”表示要启动zygote进程。“–application”表示要以普通进程的方式执行java代码。 java类：将要执行的java类。必须要有一个静态方法main。使用参数“zygote”时不会执行这个类，而是固定执行ZygoteInit类。 二.Zygote的初始化2.1 app_process的main方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int main(int argc, char* const argv[])&#123; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123; // Older kernels don't understand PR_SET_NO_NEW_PRIVS and return // EINVAL. Don't die on such kernels. if (errno != EINVAL) &#123; LOG_ALWAYS_FATAL(\"PR_SET_NO_NEW_PRIVS failed: %s\", strerror(errno)); return 12; &#125; &#125; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++; // Everything up to '--' or first non '-' arg goes to the vm. // // The first argument after the VM args is the \"parent dir\", which // is currently unused. // // After the parent dir, we expect one or more the following internal // arguments : // // --zygote : Start in zygote mode // --start-system-server : Start the system server. // --application : Start in application (stand alone, non zygote) mode. // --nice-name : The nice name for this process. // // For non zygote starts, these arguments will be followed by // the main class name. All remaining arguments are passed to // the main method of this class. // // For zygote starts, all remaining arguments are passed to the zygote. // main function. // // Note that we must copy argument string values since we will rewrite the // entire argument block when we apply the nice name to argv0. int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //解析参数 ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. //执行非zygote模式 args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; //执行zygote模式 // We're in zygote mode. maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //将本进程的名字改成 “--nice-name”参数的指定的值，如果没指定则默认为ZYGOTE_NICE_NAME宏指定的值（可能是zygote或者是zygote64） if (!niceName.isEmpty()) &#123; //替换启动参数窜中的“app_process”为参数--nice-name指定的名称 runtime.setArgv0(niceName.string()); //用来改变进程名 set_process_name(niceName.string()); &#125; if (zygote) &#123; //参数带有--zygote 所以执行ZygoteInit类 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; //否则执行通过参数传进来的java类 runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 2.2 启动虚拟机 AndroidRuntime类负责启动虚拟机以及Java线程.AndroidRuntime类在一个进程中只有一个实例对象，保存在全局变量gCurRuntime中。 1234567891011121314151617AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength)&#123; SkGraphics::Init(); // There is also a global font cache, but its budget is specified by // SK_DEFAULT_FONT_CACHE_COUNT_LIMIT and SK_DEFAULT_FONT_CACHE_LIMIT. // Pre-allocate enough space to hold a fair number of options. mOptions.setCapacity(20); assert(gCurRuntime == NULL); // one per process //保存到全局变量中 gCurRuntime = this;&#125; 2.2.1 启动虚拟机在2.1的main函数的末尾我们执行了runtime的start函数来执行java类。在zygote进程执行java代码前，还需要初始化整个java运行环境。下面我们来追踪下start函数的执行过程 2.2.1.1 输出启动log12ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); 这个日志标志android系统的启动，因为以后的进程都是从zygote进程fork出来的，所以这个不会再执行start函数。所以如果日志中反复出现这段打印的话，并且进程ID为zygote，则说明系统正在不断的重启。 2.2.1.2 获取系统目录123456789const char* rootDir = getenv(\"ANDROID_ROOT\");if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1);&#125; 首先从环境变量ANDROID_ROOT中获取，如果环境变量没有设置则把系统目录设置为/system，然后检查/system目录是否存在，如果不存在zygote退出。系统目录是在Init进程中创建的。 2.2.1.3 启动虚拟机1234567/* start the virtual machine */JniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return;&#125; 2.2.1.4 调用虚函数onVmCreated1onVmCreated(env); 这边onVmCreated只是一个虚函数，在android系统中调用的其实是其子类 AppRuntime中重载的。代码如下 1234567891011121314151617181920212223242526272829 virtual void onVmCreated(JNIEnv* env) &#123;//如果是zygote进程的话，这时候mClassName是null的，所以执行到这边就结束了。 if (mClassName.isEmpty()) &#123; return; // Zygote. Nothing to do here. &#125; /* * This is a little awkward because the JNI FindClass call uses the * class loader associated with the native method we're executing in. * If called in onStarted (from RuntimeInit.finishInit because we're * launching \"am\", for example), FindClass would see that we're calling * from a boot class' native method, and so wouldn't look for the class * we're trying to look up in CLASSPATH. Unfortunately it needs to, * because the \"am\" classes are not boot classes. * * The easiest fix is to call FindClass here, early on before we start * executing boot class Java code and thereby deny ourselves access to * non-boot classes. */ char* slashClassName = toSlashClassName(mClassName.string()); mClass = env-&gt;FindClass(slashClassName); if (mClass == NULL) &#123; ALOGE(\"ERROR: could not find class '%s'\\n\", mClassName.string()); &#125; free(slashClassName); mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass)); &#125; 2.2.1.5 注册系统的JNI函数1234567/* * Register android functions. */if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return;&#125; 12345678910111213141516171819202122232425262728293031323334/* * Register android native functions with the VM. *//*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); /* * Every \"register\" function calls one or more things that return * a local reference (e.g. FindClass). Because we haven't really * started the VM yet, they're all getting stored in the base frame * and never released. Use Push/Pop to manage the storage. */ env-&gt;PushLocalFrame(200); //通过register_jni_procs函数将全局数组gRegJNI中的jni本地函数在虚拟机中注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); //createJavaThread(\"fubar\", quickTest, (void*) \"hello\"); return 0;&#125; 2.2.1.6 准备参数: 调用java类的main函数使用的12345678910111213141516/* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */jclass stringClass;jobjectArray strArray;jstring classNameStr;stringClass = env-&gt;FindClass(\"java/lang/String\");assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); 2.2.1.7 调用java类的main方法如果启动的是Zygote进程调用的java类是ZygoteInit类，否则的话是RuntimeInit。 1234567891011121314151617181920212223242526 /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //获取main方法的ID jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //通过id调用java类的main方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; 2.3 初始化工作—— ZygoteInit 类从这边起我们就从C++进入到了java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 public static void main(String argv[]) &#123; try &#123; RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; if (abiList == null) &#123; throw new RuntimeException(\"No ABI list supplied.\"); &#125;// 注册Zyogte的socket监听端口，用来接收启动应用程序的消息 3.1会详细分析 registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); //装在系统资源。包括系统预加载类、Framework资源和openGL的资源。//这样当应用程序被fork处理后，应用的进程内已经很包含了这些系统资源，大大节省应用的启动时间。//在 第四节 预加载系统类和资源中会详细介绍 preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) &#123; //启动 SystemServer进程 在中会详细介绍 startSystemServer(abiList, socketName); &#125; Log.i(TAG, \"Accepting command socket connections\");//进入监听和接收消息的循环 在3.3节会详细分析 runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; SystemServer服务 的启动也是在这边的startSystemServer()方法中调用的。# 三.Zygote启动应用程序# 3.1 注册zygote的socket在上面2.3 ZygoteInit的main方法中我们调用了 registerZygoteSocket 方法来创建一个本地socket，然后调用了runSelectLoop来进入等待监听socket连接的循环。下面我们先来查看 registerZygoteSocket 方法123456789101112131415161718192021222324 private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc;//ANDROID_SOCKET_PREFIX的值为“ANDROID_SOCKET_” final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //通过环境变量获取socket句柄 String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + \" unset or invalid\", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //生成本地服务的socket并保存在全局变量中。 sServerSocket = new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125; &#125; registerZygoteSocket通过环境变量获取到socket句柄，但是这个socket是在哪里创建的呢？回到 1.2 节，我们是否还记得 zygote的rc文件的zygote服务里面定义了这么一条命令 1socket zygote stream 660 root system Init进程会根据这个选项创建一个AF_UNIX的socket，并把这个句柄放在环境变量ANDROID_SOCKET_[zygote]（zygote这个是指选项的名称）中。根据句柄创建FileDescriptor对象，然后通过LocalServerSocket方法生成一个本地服务的socket,并保存在sServerSocket中。 3.2 请求启动应用android启动一个新的进程都是在AMS中完成的，不管是因为什么原因启动一个新的进程，最终都是AMS的startProcessLocked来实现的。代码如下： 12345678if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";//启动进程Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); “android.app.ActivityThread” 参数就是应用启动后执行的java类。 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 最终start方法调用了 startViaZygote 方法来启动应用。首先将应用程序的启动参数保存到argsForZygote列表中，然后调用 zygoteSendArgsAndGetResult 将应用程序进程的启动参数发送到zygote进程中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; //启动参数保存到argsForZygote列表中 ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123; argsForZygote.add(\"--enable-jni-logging\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123; argsForZygote.add(\"--enable-safemode\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123; argsForZygote.add(\"--enable-debugger\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123; argsForZygote.add(\"--enable-checkjni\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123; argsForZygote.add(\"--enable-jit\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123; argsForZygote.add(\"--generate-debug-info\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123; argsForZygote.add(\"--enable-assert\"); &#125; if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(\"--mount-external-read\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(\"--mount-external-write\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); //TODO optionally enable debuger //argsForZygote.add(\"--enable-debugger\"); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125;// openZygoteSocketIfNeeded创建通信的socket，然后zygoteSendArgsAndGetResult将参数列表发送到zygote进程中 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; 创建通信的socket12345678910111213141516171819202122232425262728private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 发送到zygote进程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; // Throw early if any of the arguments are malformed. This means we can // avoid writing a partial response to the zygote. int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); &#125; &#125; /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125; &#125; 3.3 处理启动应用的请求在2.3节中 我们知道在ZygoteInit的main方法中 会通过runSelectLoop开启无限循环来接收启动应用的请求 12345678910111213141516171819202122232425262728293031323334353637private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 这边通过i=0判断请求连接事件是否到来，如果到来了调用 acceptCommandPeer 来和客户端建立一个socket链接，然后把socket加入到监听数组中，来等待socket上命令的到来。 如果i&gt;0这时候表示socket上有数据到了。这时候直接调用 ZygoteConnection 类的 runOnce 方法，处理完断开连接，并清除scoket。 3.4 fork应用进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123;//通过 readArgumentList 方法从socket连接中读取参数行 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; /** the stderr of the most recent request, if avail */ PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123; newStderr = new PrintStream( new FileOutputStream(descriptors[2])); &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) &#123; return handleAbiListQuery(); &#125; if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123; throw new ZygoteSecurityException(\"Client may not specify capabilities: \" + \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) + \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities)); &#125;//检查客户端进程是否有权利指定进程的用户id 组id 和所属的组//如果 客户端是root进程则可以任意指定//如果客户端是system进程，只有在系统属性 ro.fatorytest值为1 或者2的时候可以指定//没有指定则继承客户端的值 applyUidSecurityPolicy(parsedArgs, peer); applyInvokeWithSecurityPolicy(parsedArgs, peer); applyDebuggerSystemProperty(parsedArgs); applyInvokeWithSystemProperty(parsedArgs); int[][] rlimits = null; if (parsedArgs.rlimits != null) &#123; rlimits = parsedArgs.rlimits.toArray(intArray2d); &#125; if (parsedArgs.invokeWith != null) &#123; FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC); childPipeFd = pipeFds[1]; serverPipeFd = pipeFds[0]; Os.fcntlInt(childPipeFd, F_SETFD, 0); &#125; /** * In order to avoid leaking descriptors to the Zygote child, * the native code must close the two Zygote socket descriptors * in the child process before it switches from Zygote-root to * the UID and privileges of the application being launched. * * In order to avoid \"bad file descriptor\" errors when the * two LocalSocket objects are closed, the Posix file * descriptors are released via a dup2() call which closes * the socket and substitutes an open descriptor to /dev/null. */ int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null;//fork子进程 最后的fork还在native层完成的 在SystemServer进程 2.1 节会详细介绍 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, \"Exception creating pipe\", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, \"Invalid zygote arguments\", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, \"Zygote security policy prevents request: \", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //pid=0 表示在子进程中，所以执行 handleChildProc 在 3.5 节详细展开 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; //这时候还在zygote进程中，所以调用 handleParentProc 继续处理 return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125; 3.5 子进程的初始化我们接着上面的流程继续分析 handleChildProc 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /** * By the time we get here, the native code has closed the two actual Zygote * socket connections, and substituted /dev/null in their place. The LocalSocket * objects still need to be closed properly. */ closeSocket(); ZygoteInit.closeServerSocket(); if (descriptors != null) &#123; try &#123; Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; newStderr = System.err; &#125; catch (ErrnoException ex) &#123; Log.e(TAG, \"Error reopening stdio\", ex); &#125; &#125; if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 在方法的最后会根据参数的不同选择初始化的方式invokeWith不为null的时候，将会通过调用exec的方式来启动app_process进程来执行java类。正常情况下还是调用RuntimeInit.zygoteInit来启动的 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.5.1 commonInit方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 private static final void commonInit() &#123; if (DEBUG) Slog.d(TAG, \"Entered RuntimeInit!\");//设置进程的UncaughtException的处理方法//这边默认的实现是打印出错误堆栈然后退出应用//应用可以调用 Thread.setDefaultUncaughtExceptionHandler 来设置自定义的处理方式//想腾讯的bug平台的实现就是基于这点 /* set default handler; this applies to all threads in the VM */ Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());//设置时区 /* * Install a TimezoneGetter subclass for ZoneInfo.db */ TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null);//重置android系统的log系统 /* * Sets handler for java.util.logging to use Android log facilities. * The odd \"new instance-and-then-throw-away\" is a mirror of how * the \"java.util.logging.config.class\" system property works. We * can't use the system property here since the logger has almost * certainly already been initialized. */ LogManager.getLogManager().reset(); new AndroidConfig();//设置 http.agent 属性 /* * Sets the default HTTP User-Agent used by HttpURLConnection. */ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); /* * Wire socket tagging to traffic stats. */ NetworkManagementSocketTagger.install(); /* * If we're running in an emulator launched with \"-trace\", put the * VM into emulator trace profiling mode so that the user can hit * F9/F10 at any time to capture traces. This has performance * consequences, so it's not something you want to do always. */ String trace = SystemProperties.get(\"ro.kernel.android.tracing\"); if (trace.equals(\"1\")) &#123; Slog.i(TAG, \"NOTE: emulator trace profiling enabled\"); Debug.enableEmulatorTraceOutput(); &#125; initialized = true; &#125; 3.5.2 nativeZygoteInit 方法3.5.3 applicationInit 方法12345678910111213141516171819202122232425262728293031 private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true);//设置虚拟机参数 // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);//这边会真正调用到 ActivityThread.main 方法 // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125; 12345678910111213141516171819202122232425262728293031323334353637private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 四.预加载系统类和资源在 2.3 节 ZygoteInit类的main方法中会调用 preload 方法来可进行系统类和资源的预加载。 123456789101112static void preload() &#123; Log.d(TAG, \"begin preload\"); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, \"end preload\");&#125;","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"Init进程","slug":"Init进程","date":"2018-05-31T06:32:00.000Z","updated":"2018-06-12T02:30:30.466Z","comments":true,"path":"2018/05/31/Init进程/","link":"","permalink":"http://yoursite.com/2018/05/31/Init进程/","excerpt":"","text":"一.概述Init进程是Linux系统中用户空间的第一个进程，Android是基于Linux内核的，所以init也是Android系统中用户空间的第一个进程，进程号是1。在Init初始化的过程中会启动很多重要的守护进程，当然Init本身也是一个守护进程。 二.Init进程的初始化过程Init进程的源码位于\\system\\core\\init\\下。程序的入口函数main()位于init.cpp中。 2.1 main函数的流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162int main(int argc, char** argv) &#123; //2.1.1 选择启动程序 if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv); &#125; //2.1.2 设置进程创建的文件的属性 // Clear the umask. umask(0); add_environment(\"PATH\", _PATH_DEFPATH); //2.1.3 创建目录和挂载文件系统 bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0); // Get the basic filesystem setup we need put together in the initramdisk // on / and then we'll let the rc file figure out the rest. if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL); &#125; //2.1.4 初始化log系统 // We must have some place other than / to create the device nodes for // kmsg and null, otherwise we won't be able to remount / read-only // later on. Now that tmpfs is mounted on /dev, we can actually talk // to the outside world. open_devnull_stdio(); klog_init(); klog_set_level(KLOG_NOTICE_LEVEL); NOTICE(\"init%s started!\\n\", is_first_stage ? \"\" : \" second stage\"); //2.1.5 初始化属性系统 if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt(); process_kernel_cmdline(); // Propogate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; //2.1.6 初始化SELinux内核 // Set up SELinux, including loading the SELinux policy if we're in the kernel domain. selinux_initialize(is_first_stage); // If we're in the kernel domain, re-exec init to transition to the init domain now // that the SELinux policy has been loaded. if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125; &#125; // These directories were necessarily created before initial policy load // and therefore need their security context restored to the proper value. // This must happen before /dev is populated by ueventd. INFO(\"Running restorecon...\\n\"); restorecon(\"/dev\"); restorecon(\"/dev/socket\"); restorecon(\"/dev/__properties__\"); restorecon_recursive(\"/sys\"); epoll_fd = epoll_create1(EPOLL_CLOEXEC); if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1); &#125; // 2.1.7 初始化子进程退出的信号处理过程 signal_handler_init(); //2.1.8 设置系统属性的默认值 property_load_boot_defaults(); //2.1.9 启动属性服务（sockect） start_property_service(); //2.1.10 解析init.rc文件 init_parse_config_file(\"/init.rc\"); //2.1.11 初始化执行列表action_queue action_for_each_trigger(\"early-init\", action_add_queue_tail); // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev... queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\"); queue_builtin_action(keychord_init_action, \"keychord_init\"); queue_builtin_action(console_init_action, \"console_init\"); // Trigger all the boot actions to get us started. action_for_each_trigger(\"init\", action_add_queue_tail); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\"); // Don't mount filesystems or start core system services in charger mode. char bootmode[PROP_VALUE_MAX]; if (property_get(\"ro.bootmode\", bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, \"charger\") == 0) &#123; action_for_each_trigger(\"charger\", action_add_queue_tail); &#125; else &#123; action_for_each_trigger(\"late-init\", action_add_queue_tail); &#125; // Run all property triggers based on current state of the properties. queue_builtin_action(queue_property_triggers_action, \"queue_property_triggers\"); //2.1.12 无限循环执行 while (true) &#123; if (!waiting_for_exec) &#123; execute_one_command(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (!action_queue_empty() || cur_action) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; return 0;&#125; 2.1.1 选择启动程序因为Init和ueventd和watchdogd守护进程的代码存在大量的代码重合，所以直接合并到一个文件中，通过参数来判断执行那个守护进程。 1234567if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125; 2.1.2 设置进程创建的文件的属性缺省情况下一个进程创建的文件属性是022，使用umask可以设置文件属性的掩码。参数为0表示掩码为0777。 12// Clear the umask.umask(0); 2.1.3 创建目录和挂载文件系统12345678910111213//确保只执行一次bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; tmpfs是一种基于内存的文件系统，mount后就可以使用。tmpfs文件系统下的所有文件都存放在内存中，访问速度快，但是关机后会消失，适合用来存放临时性的文件。而且tmpfs文件系统的大小是动态变化的，一开始很小，随着文件的增多会随之变大。从上面的代码我们可以看到Android系统将tmpfs文件系统挂载到/dev目录下，而这个目录是用来保存系统创造的设备节点，正好符合tmpfs的特点。 devpts是虚拟终端文件系统，通常mount在目录/dev/pts下。 2.1.4 初始化log系统1234567891011//将标准输入、输出、错误重定向到空设备文件/dev/null下，这是守护进程常用的手段 open_devnull_stdio();//创建设备节点/dev/kmsg,这样init进程就可以使用kernel的log系统，之所以是用使用kernel的log系统是因为这时候android层的log系统还没有启动起来 klog_init();//设置log级别 klog_set_level(KLOG_NOTICE_LEVEL);//打印init进程开始启动的日志 NOTICE(\"init%s started!\\n\", is_first_stage ? \"\" : \" second stage\"); 日志输出级别的宏定义如下 KLOG_ERROR_LEVEL 3 KLOG_WARNING_LEVEL 4 KLOG_NOTICE_LEVEL 5 KLOG_INFO_LEVEL 6 KLOG_DEBUG_LEVEL 7 KLOG_DEFAULT_LEVEL 3 //默认为3当我们设置的级别低于5的时候会输出到 kernel log 中 2.1.5 初始化属性系统123456789101112131415161718 if (!is_first_stage) &#123;//在/dev下创建一个设备表示正在初始化中，当初始化完成则移除// Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));//创建一个共享区域来存储属性值 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt();//解析kernel的启动参数 process_kernel_cmdline(); // Propogate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; 2.1.6 初始化SELinux内核SELinux内核是android4.3开始引入的。在后面的解析系列中会重点解析这块。1234567891011121314151617181920212223242526272829303132// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.INFO(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; 2.1.7 初始化子进程退出的信号处理过程1signal_handler_init(); 2.1.8 设置系统属性的默认值1property_load_boot_defaults(); 上面的函数会从设备的根目录下的default.prop文件(路径:/default.prop)的属性值读取设置到属性系统中。 下面是截取的nexu5x 6.0系统模拟器下的文件值1234567891011121314151617181920## ADDITIONAL_DEFAULT_PROPERTIES#ro.secure=1ro.allow.mock.location=0ro.debuggable=1ro.zygote=zygote32dalvik.vm.image-dex2oat-Xms=64mdalvik.vm.image-dex2oat-Xmx=64mdalvik.vm.dex2oat-Xms=64mdalvik.vm.dex2oat-Xmx=512mro.dalvik.vm.native.bridge=0debug.atrace.tags.enableflags=0## BOOTIMAGE_BUILD_PROPERTIES#ro.bootimage.build.date=Wed Dec 13 00:51:01 UTC 2017ro.bootimage.build.date.utc=1513126261ro.bootimage.build.fingerprint=Android/sdk_google_phone_x86/generic_x86:6.0/MASTER/4499259:userdebug/test-keyspersist.sys.usb.config=adb 2.1.9 启动属性服务（sockect）读取相应文件的属性，下文5.3中有介绍。1start_property_service(); 2.1.10 解析init.rc文件解析完成后的结果是将init文件中的Server项和Action项分别加入到内部Service列表:service_list 和Action列表:action_list解析的过程会在下面的详细的分析 1init_parse_config_file(\"/init.rc\"); 2.1.11 初始化执行列表action_queue1234567891011121314151617181920212223242526272829303132333435 //将rc文件中触发器为early-init的action添加到执行列表action_for_each_trigger(\"early-init\", action_add_queue_tail);//queue_builtin_action 作用就是将一个函数和一个名称生成action并插入到执行列表 // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...//等待冷插拔设备初始化完成 queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. //从硬件RNG的设备文件/dev/hw_randow中读取512字节并写到Linux RNGd的设备文件/dev/urandom中（这块因为水平有限，还未知道具体作用）queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//初始化组合键监听模块 queue_builtin_action(keychord_init_action, \"keychord_init\");//在屏幕上显示Android字样的Logo queue_builtin_action(console_init_action, \"console_init\"); //将rc文件中触发器为init的action添加到执行列表 // Trigger all the boot actions to get us started. action_for_each_trigger(\"init\", action_add_queue_tail); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//当处于充电模式，则charger加入执行队列；否则late-init加入队列。 // Don't mount filesystems or start core system services in charger mode. char bootmode[PROP_VALUE_MAX]; if (property_get(\"ro.bootmode\", bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, \"charger\") == 0) &#123; action_for_each_trigger(\"charger\", action_add_queue_tail); &#125; else &#123; action_for_each_trigger(\"late-init\", action_add_queue_tail); &#125;//检查Action列表中通过修改属性来触发的Action，查看相关的属性是否已经设置了，如果已经设置则将该action加入到执行列表 // Run all property triggers based on current state of the properties. queue_builtin_action(queue_property_triggers_action, \"queue_property_triggers\"); 2.1.12 无限循环执行123456789101112131415161718192021222324252627while (true) &#123; if (!waiting_for_exec) &#123; execute_one_command(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (!action_queue_empty() || cur_action) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; 2.2 启动Service进程上面最后无限循环的过程中 restart_processes 函数会检查service_list中所有服务，对于带有SVC_RESTARTING标志的服务，将服务作为参数调用 restart_service_if_needed 1234567891011121314static void restart_service_if_needed(struct service *svc) &#123; time_t next_start_time = svc-&gt;time_started + 5; if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); service_start(svc, NULL); return; &#125; if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; 由上面代码可以看出最后调用了service_start方法，下面我们来分析这个方法。 2.2.1 重置Service结构中的标志和可执行判断12345678910111213141516171819202122232425262728293031323334353637 // Starting a service removes it from the disabled or reset state and // immediately takes it out of the restarting state if it was in there.//这四个都是跟启动相关的所以直接去掉 svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START)); svc-&gt;time_started = 0;//如果已经在启动了则不需要再执行 // Running processes require no additional work --- if they're in the // process of exiting, we've ensured that they will immediately restart // on exit, unless they are ONESHOT. if (svc-&gt;flags &amp; SVC_RUNNING) &#123; return; &#125;//如果服务需要控制台，但是控制台没有启动则退出 bool needs_console = (svc-&gt;flags &amp; SVC_CONSOLE); if (needs_console &amp;&amp; !have_console) &#123; ERROR(\"service '%s' requires console\\n\", svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务的二进制文件是否存在 struct stat s; if (stat(svc-&gt;args[0], &amp;s) != 0) &#123; ERROR(\"cannot find '%s', disabling '%s'\\n\", svc-&gt;args[0], svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务是否有SVC_ONESHOT参数 if ((!(svc-&gt;flags &amp; SVC_ONESHOT)) &amp;&amp; dynamic_args) &#123; ERROR(\"service '%s' must be one-shot to use dynamic args, disabling\\n\", svc-&gt;args[0]); svc-&gt;flags |= SVC_DISABLED; return; &#125; 2.2.2 设置安全上下文关于安全机制在后续的文章中分析 12345678910111213141516171819202122232425262728293031323334353637char* scon = NULL;if (is_selinux_enabled() &gt; 0) &#123; if (svc-&gt;seclabel) &#123; scon = strdup(svc-&gt;seclabel); if (!scon) &#123; ERROR(\"Out of memory while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125; else &#123; char *mycon = NULL, *fcon = NULL; INFO(\"computing context for service '%s'\\n\", svc-&gt;args[0]); int rc = getcon(&amp;mycon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; rc = getfilecon(svc-&gt;args[0], &amp;fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); freecon(mycon); return; &#125; rc = security_compute_create(mycon, fcon, string_to_security_class(\"process\"), &amp;scon); if (rc == 0 &amp;&amp; !strcmp(scon, mycon)) &#123; ERROR(\"Warning! Service %s needs a SELinux domain defined; please fix!\\n\", svc-&gt;name); &#125; freecon(mycon); freecon(fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125;&#125; 2.2.3 fork子进程,exec123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 //首先打印 服务启动日志NOTICE(\"Starting service '%s'...\\n\", svc-&gt;name); //fork进程pid_t pid = fork();if (pid == 0) &#123; struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; umask(077); //准备环境变量 if (properties_initialized()) &#123; get_property_workspace(&amp;fd, &amp;sz); snprintf(tmp, sizeof(tmp), \"%d,%d\", dup(fd), sz); add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp); &#125; for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next) add_environment(ei-&gt;name, ei-&gt;value); //如果服务选项中有socket选项。这时候就开始创建参数中定义的socket。 for (si = svc-&gt;sockets; si; si = si-&gt;next) &#123; int socket_type = ( !strcmp(si-&gt;type, \"stream\") ? SOCK_STREAM : (!strcmp(si-&gt;type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET)); int s = create_socket(si-&gt;name, socket_type, si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon); if (s &gt;= 0) &#123; publish_socket(si-&gt;name, s); &#125; &#125; freecon(scon); scon = NULL; if (svc-&gt;writepid_files_) &#123; std::string pid_str = android::base::StringPrintf(\"%d\", pid); for (auto&amp; file : *svc-&gt;writepid_files_) &#123; if (!android::base::WriteStringToFile(pid_str, file)) &#123; ERROR(\"couldn't write %s to %s: %s\\n\", pid_str.c_str(), file.c_str(), strerror(errno)); &#125; &#125; &#125; if (svc-&gt;ioprio_class != IoSchedClass_NONE) &#123; if (android_set_ioprio(getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri)) &#123; ERROR(\"Failed to set pid %d ioprio = %d,%d: %s\\n\", getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri, strerror(errno)); &#125; &#125; //处理标准输入 标准输出 标准错误3个文件描述符 if (needs_console) &#123; setsid(); open_console(); &#125; else &#123; zap_stdio(); &#125; //这边明显不执行 if (false) &#123; for (size_t n = 0; svc-&gt;args[n]; n++) &#123; INFO(\"args[%zu] = '%s'\\n\", n, svc-&gt;args[n]); &#125; for (size_t n = 0; ENV[n]; n++) &#123; INFO(\"env[%zu] = '%s'\\n\", n, ENV[n]); &#125; &#125; setpgid(0, getpid()); // As requested, set our gid, supplemental gids, and uid. if (svc-&gt;gid) &#123; if (setgid(svc-&gt;gid) != 0) &#123; ERROR(\"setgid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;nr_supp_gids) &#123; if (setgroups(svc-&gt;nr_supp_gids, svc-&gt;supp_gids) != 0) &#123; ERROR(\"setgroups failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;uid) &#123; if (setuid(svc-&gt;uid) != 0) &#123; ERROR(\"setuid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;seclabel) &#123; if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) &#123; ERROR(\"cannot setexeccon('%s'): %s\\n\", svc-&gt;seclabel, strerror(errno)); _exit(127); &#125; &#125; //执行exec if (!dynamic_args) &#123; if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", svc-&gt;args[0], strerror(errno)); &#125; &#125; else &#123; char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc-&gt;nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; /* Copy the static arguments */ memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *))); while((bword = strsep(&amp;next, \" \"))) &#123; arg_ptrs[arg_idx++] = bword; if (arg_idx == INIT_PARSER_MAXARGS) break; &#125; arg_ptrs[arg_idx] = NULL; execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV); &#125; _exit(127);&#125; 三. 解析启动脚本init.rc3.1 init.rc文件格式init.rc文件是以块为单位，主要分为两类： 动作:action,以on开头; 服务:service，以service开头。 选项:Options 命令:Commands注释以#开头。无论是action还是service的执行顺序都不是以文件中的编排顺序执行的，执行与否和是否执行都是Init进程中决定的。 3.1.1 action格式：on [trigger] 触发条件 [Command1] [Command2] [Command3] 在on后面紧跟的字符串是action的触发器，触发器后面的是命令列表，每一行都是一个命令。可以通过 trigger 触发器字符串（trigger late-init） 来触发。 当相应的事件发生后，系统会对rc文件中的各个 trigger 进行匹配，匹配到的action会被加入到 命令执行列表的尾部，已经在队伍中的action不会被重复添加。 触发器几种类别 on early-init; 在初始化早期阶段触发； on init; 在初始化阶段触发； on late-init; 在初始化晚期阶段触发； on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举； on property:=: 当属性值满足条件时触发； 123456789101112on property:sys.boot_from_charger_mode=1 class_stop charger trigger late-init# Load properties from /system/ + /factory after fs mount.on load_system_props_action load_system_propson load_persist_props_action load_persist_props start logd start logd-reinit 3.1.2 service格式：service [name:名称] [pathname：路径] [argument：参数] [option] [option] 在service后面是服务的名称，我们可以使用“start”命令加服务名称来启动一个服务（start logd）。名称后面的则是执行文件路径和执行参数。然后下面的行称为选项，每一行都是一个选项。例如class表示服务的类别，我们可以通过class_start来一次性启动一组服务。12345678910111213141516171819202122232425262728293031service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0service logd /system/bin/logd class core socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram 0222 logd logd group root system writepid /dev/cpuset/system-background/tasksservice logd-reinit /system/bin/logd --reinit oneshot writepid /dev/cpuset/system-background/tasks disabledservice healthd /sbin/healthd class core critical seclabel u:r:healthd:s0 group root systemservice console /system/bin/sh class core console disabled user shell group shell log seclabel u:r:shell:s0 3.1.3 Options 选项选项是service的修订项，它决定了服务何时运行以及怎么运行。 disabled: 表示不能通过触发器来触发，只能根据start service名开启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket，并把文件描述符传递给要启动的进程。 critical:这是一个关键服务，如果在4分钟内重启启动4次，则系统会重启并进入Recovery模式。 3.1.4 Commands 命令 class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务； start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过； stop &lt;service_name&gt;： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink &lt;sym_link&gt;： 创建连接到的&lt;sym_link&gt;符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 commands的命令远不止上面这些，这里只是列出一些常用的命令。 3.2 脚本文件解析过程下面我们来追踪下脚本文件的解析过程 源码所在文件路径如下\\system\\core\\init\\init_parser.cpp 首先从入口函数开始 123456789101112131415int init_parse_config_file(const char* path) &#123; INFO(\"Parsing %s...\\n\", path); Timer t; std::string data; if (!read_file(path, &amp;data)) &#123; return -1; &#125; data.push_back('\\n'); // TODO: fix parse_config. parse_config(path, data); dump_parser_state(); NOTICE(\"(Parsing %s took %.2fs.)\\n\", path, t.duration()); return 0;&#125; 从上面的函数可以看出来，首先通过read_file将文件的内容读到内存中，然后再通过parse_config函数进行解析。下面我们继续来追踪parse_config的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void parse_config(const char *fn, const std::string&amp; data)&#123; struct listnode import_list; struct listnode *node; char *args[INIT_PARSER_MAXARGS]; int nargs = 0; parse_state state; state.filename = fn; state.line = 0; state.ptr = strdup(data.c_str()); // TODO: fix this code! state.nexttoken = 0; state.parse_line = parse_line_no_op; list_init(&amp;import_list); state.priv = &amp;import_list; for (;;) &#123; switch (next_token(&amp;state)) &#123; //如果是结束标识符，则跳转到下面的parser_done位置 case T_EOF: state.parse_line(&amp;state, 0, 0); goto parser_done; //行结束符 case T_NEWLINE: state.line++; if (nargs) &#123; int kw = lookup_keyword(args[0]); //判断是否是section：关键字 on service import if (kw_is(kw, SECTION)) &#123; state.parse_line(&amp;state, 0, 0); //具体处理见 3.2.1 parse_new_section(&amp;state, kw, nargs, args); &#125; else &#123; //当作当前section所属行处理 state.parse_line(&amp;state, nargs, args); &#125; nargs = 0; &#125; break; //单词结束符 则先放入到数组中 case T_TEXT: if (nargs &lt; INIT_PARSER_MAXARGS) &#123; args[nargs++] = state.text; &#125; break; &#125; &#125;parser_done: list_for_each(node, &amp;import_list) &#123; struct import *import = node_to_item(node, struct import, list); int ret; ret = init_parse_config_file(import-&gt;filename); if (ret) ERROR(\"could not import file '%s' from '%s'\\n\", import-&gt;filename, fn); &#125;&#125; parse_new_section方法追踪 1234567891011121314151617181920212223242526static void parse_new_section(struct parse_state *state, int kw, int nargs, char **args)&#123; printf(\"[ %s %s ]\\n\", args[0], nargs &gt; 1 ? args[1] : \"\"); switch(kw) &#123; case K_service: state-&gt;context = parse_service(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_service; return; &#125; break; case K_on: state-&gt;context = parse_action(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_action; return; &#125; break; case K_import: parse_import(state, nargs, args); break; &#125; state-&gt;parse_line = parse_line_no_op;&#125; 由上面的函数可以看出，该方法通过传入的参数kw来决定用什么方法来处理： on关键字：parse_action service关键字：parse_service import关键字：parse_action 然后我们可以看出上面对结构体state的parse_line字段分别进行赋值了方法地址,该方法用来解析命令行。 on关键字：parse_line_action service关键字：parse_line_service 3.3 执行action3.2的解析过程只是将init.rc中的action和service添加到各自的列表中。真正将它们添加到执行列表的还是在init进程中处理的。上文2.1.11 中在init的初始化过程通过action_for_each_trigger将action添加到action_queue中。 1234567891011121314151617void action_for_each_trigger(const char *trigger, void (*func)(struct action *act))&#123; struct listnode *node, *node2; struct action *act; struct trigger *cur_trigger; list_for_each(node, &amp;action_list) &#123; act = node_to_item(node, struct action, alist); list_for_each(node2, &amp;act-&gt;triggers) &#123; cur_trigger = node_to_item(node2, struct trigger, nlist); if (!strcmp(cur_trigger-&gt;name, trigger)) &#123; func(act); &#125; &#125; &#125;&#125; 四.Init进程对信号的处理4.1 僵尸进程当一个进程退出exit()时，会向它的父进程发送一个SIGCHLD信号。父进程收到该信号后，会释放分配给该子进程的系统资源；并且父进程需要调用wait()或waitpid()等待子进程结束。 如果父进程没有做这种处理，且父进程初始化时也没有调用signal(SIGCHLD, SIG_IGN)来显示忽略对SIGCHLD的处理，这时子进程将一直保持当前的退出状态，不会完全退出。这样的子进程不能被调度，所做的只是在进程列表中占据一个位置，保存了该进程的PID、终止状态、CPU使用时间等信息；我们将这种进程称为“Zombie”进程，即僵尸进程。 android中查看僵尸进程的方法是通过 adb shell ps来查看的，僵尸进程的的进程状态为“Z”。 由于僵尸进程仍会在进程列表中占据一个位置，而Linux所支持的最大进程数量是有限的；超过这个界限值后，我们就无法创建进程。所以，我们有必要清理那些僵尸进程，以保证系统的正常运作。 4.2 处理过程待补充 五. 属性系统5.1 属性系统介绍android的属性用来保存系统设置和进程间传递一些信息。每个属性由属性名称和属性值组成，名称通常以“.”分割,这些名称的前缀有特殊的含义，不能随便改动。属性值只能是字符串。 对于进程来说，读取属性值是没有限制的，任何进程都可以读取属性值。但是写属性值只能通过init进程进行，而且init进程还会检查请求的进程是否具有该权限（5.0以后只在）。当属性值修改成功后，init进程会init.rc中是否有跟该属性修改值相匹配的“触发器”。如果有则执行触发器下的命令。 前缀分类 “ro.”：表示只读属性，一旦设置则不能改变。 “persist”:表示属性值会被写入目录/data/property下与属性同名的文件中。下次开机init进程会从中读取值。所以这边设置的值是永久生效的。 “ctl”:表示控制信息，用来执行一些命令：ctl.start、ctl.stop、ctl.restart setprop ctl.start bootanim：查看开机动画 setprop ctl.stop bootanim：关闭开机动画 setprop ctl.start pre-recovery：进入recovery模式 5.2 创建属性系统的共享空间在上面Init进程的初始化函数中我们调用了property_init函数为属性系统创建了一块共享内存区域。这块区域只能由init进程进行写入，读则不限制。 123456789101112131415161718192021void property_init() &#123; //防止多次初始化 if (property_area_initialized) &#123; return; &#125; property_area_initialized = true; //创建和初始化属性的共享内存空间，这块内存空间由/dev/__properties__ 设备创建,这块空间的文件描述符保存在 //static workspace pa_workspace; 中，最后在service_start的时候保存到环境变量中 if (__system_property_area_init()) &#123; return; &#125; pa_workspace.size = 0; pa_workspace.fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC); if (pa_workspace.fd == -1) &#123; ERROR(\"Failed to open %s: %s\\n\", PROP_FILENAME, strerror(errno)); return; &#125;&#125; 5.3 初始化属性系统的值通过从以下文件中读取值进行初始化 /system/build.prop：定了系统初始和永久的一些属性/data/local.prop：这个则需要和ro.debuggable配合使用，如果这个值为1，那么从该文件中读取值覆盖系统缺省的属性值，之所有有这个设计是为了方便开发人员调试，因为/system/build.prop 是在根目录下的。/data/property：该目录下的文件读取出来写入到属性值中。/default.prop: Init进程初始化过程中调用property_load_boot_defaults函数读取的 源码地址 本文源码基于android6.0system\\core\\init\\init.cppsystem\\core\\init\\init_parser.cppsystem\\core\\init\\signal_handler.cppsystem\\core\\init\\property_service.cpp","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"开机应用扫描流程","slug":"android6.0/PKMS/开机应用扫描流程","date":"2018-05-30T15:38:00.000Z","updated":"2018-05-31T00:52:32.308Z","comments":true,"path":"2018/05/30/android6.0/PKMS/开机应用扫描流程/","link":"","permalink":"http://yoursite.com/2018/05/30/android6.0/PKMS/开机应用扫描流程/","excerpt":"","text":"","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"PackageManagerService","slug":"android6-0/PackageManagerService","permalink":"http://yoursite.com/categories/android6-0/PackageManagerService/"}],"tags":[]},{"title":"动态更改Launch应用","slug":"工作问题/rk/动态更改Launch应用","date":"2018-05-29T15:45:53.000Z","updated":"2018-05-30T01:43:46.249Z","comments":true,"path":"2018/05/29/工作问题/rk/动态更改Launch应用/","link":"","permalink":"http://yoursite.com/2018/05/29/工作问题/rk/动态更改Launch应用/","excerpt":"","text":"","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"源码导航","slug":"android6.0/总览","date":"2018-05-29T05:37:00.000Z","updated":"2018-06-11T09:19:25.781Z","comments":true,"path":"2018/05/29/android6.0/总览/","link":"","permalink":"http://yoursite.com/2018/05/29/android6.0/总览/","excerpt":"","text":"一.引言Android系统非常庞大、错综复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连通系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而融为一体。 限于本人目前的只是水平,本系列的源码分析基本限于framework层的java代码。目前，网上有大量的android系统源码分析的书籍和博客，其实很不多优秀的文章。那为什么要再写一个自己的blog呢？这是因为android源码分析是个工程量非常巨大的事，在学些的过程中很容易迷失在源码的森林中，经常会出现看完一个模块，过一段时间就忘记的情况，所以很有必要将自己看的过程记录下来，同时也加深自己的理解。 首先说明本系列的源码分析是基于android6.0的源码，主要以事件为驱动来分析源码，比如我们我们在分析PKMS（PackageManagerService）服务的时候我们会从开机扫描过程，应用的安装过程等事件的流程进行分析解读。 二.Binder机制 Binder 开篇 Binder 开篇 三.Android系统启动系列先简单的介绍下Android的启动过程，下面三个阶段默认都有各自的启动画面 3.1 bootloader引导3.1.1 什么是bootloader引导当我们按下手机的电源键时，最先运行的就是bootloader。bootloader主要作用就是初始化基本的硬件设备（CPU,内存，Flash等）并且通过建立内存空间的映射，为装载linux内核准备好适合的环境。内核装载完毕，bootloader将会从内存中清除。 3.1.2 Fastboot模式Fastboot是Android设计的一套通过usb来更新手机分区映像的协议。 3.1.3 Recovery模式Android特有的升级系统。利用该模式可以进行恢复出厂设置，执行ota、补丁和固件升级。进入到Recovery模式实际上就是进入了一个文字模式的Linux 3.2 装载和启动Linux内核Android的boot.img存放的就是Linux的内核和一个根文件系统。上面的bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成整个后装载整个根文件系统，最后启动Init进程 什么是根文件系统？根文件系统是Linux系统一种特殊的文件系统，Android是基于Linux的，当然也有根文件系统。android的根文件系统是基于busybox实现的。 3.3 启动android系统android系统的启动可以更加详细的分为以下几个阶段 3.3.1 启动Init进程Init进程是系统启动的第一个进程。在Init的启动过程中会解析Linux的配置脚本init.rc文件、加载android的文件系统、创建系统目录、初始化属性系统、启动android系统重要的守护进程（USB守护进程、adb守护进程、vold守护进程、rild守护进程）。 Init作为守护进程的作用：修改属性请求、重启崩溃的进程等操作。 3.3.2 启动ServiceManager由init启动。管理binder服务，负责binder的注册和查找。 3.3.3 启动Zygote进程Init进程初始化结束时会启动Zygote进程。Zygote进程负责fork应用进程。是所有应用进程的父进程。 Zygote进程初始化时会创建Dalivik虚拟机、预装载系统的资源文件和Java类。从Zygote中fork的进程都会继承和共享这些预加载的资源。 启动结束后，转为守护进程来响应应用建立的请求。 3.3.4 启动SystemServiceSystemService是Zygote进程fork的第一个进程，也是android系统的核心进程。在SystemService中运行这android大部分的binder服务。 首先会启动SensorService,接着是ActivityManagerService（AMS）,WindowsManagerService（WMS）,PackagerManagerService(PKMS)等服务。 3.3.5 启动LauncherSystemServer加载完所有的服务后，最后会调用AMS中的systemReady()方法。在这个方法的执行过程中会发出Intent(android.intent.category.Home).凡是响应这个Intent的应用都会启动起来（这个流程我们到时候在AMS的分析部分会重点追踪整个过程），这边要跟开机广播区别开来。 Init进程 Init进程 Zygote进程 Zygote进程 SystemServer进程 SystemServer服务 四.PackageManagerService 开机应用扫描流程 应用安装流程 五.ActivityManagerService 开机广播流程 Activity启动流程 Service启动流程 registerReceiver流程 sendBroadcast流程 六.WindowManagerService七.致谢在blog的编写过程中会大量的引用平时看的书籍和前辈优秀的blog,在这边会贴出引用的书籍和blog地址！","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"导读","slug":"android6-0/导读","permalink":"http://yoursite.com/categories/android6-0/导读/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"}]}]}