{"meta":{"title":"道墟","subtitle":"初九，潜龙勿用","description":null,"author":"道墟","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-29T15:28:54.000Z","updated":"2018-05-30T01:43:46.253Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2018-05-29T15:29:50.000Z","updated":"2018-05-30T01:43:46.257Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-30T03:44:46.000Z","updated":"2018-05-30T03:45:39.389Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"日常问题:自定义系统权限级签名","slug":"日常问题-自定义系统权限级签名","date":"2018-06-08T07:09:53.000Z","updated":"2018-06-11T00:43:50.395Z","comments":true,"path":"2018/06/08/日常问题-自定义系统权限级签名/","link":"","permalink":"http://yoursite.com/2018/06/08/日常问题-自定义系统权限级签名/","excerpt":"","text":"一.背景知识1.1 android权限分级在android开发中权限主要分为以下四级 normal: 普通的权限，只需要在 AndroidManifest.xml 文件中定义就可以使用。 dangerous: 危险的权限，不仅需要在 AndroidManifest.xml 文件定义，如果apk的目标版本是23以上并且运行在23版本以上的机子上那么需要动态申请权限。 signature: 系统级别签名才能获取的权限。 signature|system: 系统级别签名或者系统应用可以获取的权限。 关于权限定义的源文件位于：frameworks\\base\\core\\res\\AndroidManifest.xml 这边要注意 系统权限应用(signature)和系统应用（system）的区别：系统应用一般是厂商内置的应用，在目录 system/app 、/system/framework/、/vendor/app/下的都是系统应用，系统权限应用是 指在 AndroidManifest.xml 申请了 android:sharedUserId=”android.uid.system” 的应用，而这个是需要系统签名的。这部分的知识在PKMS服务中会详细的介绍。 1.2 系统签名类型android的标准签名key有： testkey: testkey是作为android编译的时候默认的签名key，如果系统中的apk的android.mk中没有设置LOCAL_CERTIFICATE的值，就默认使用testkey media：如果LOCAL_CERTIFICATE := media 就代表使用 media 来签名，这样apk就会跟系统中所有使用android.uid.media共享UID。用这个是该APK是media/download系统中的一环。 platform: 如果LOCAL_CERTIFICATE := platform 就代表使用platform来签名，这样的话这个apk就拥有了和system相同的签名，因为系统级别的签名也是使用的platform来签名 shared：如果LOCAL_CERTIFICATE := shared 就代表使用 shared 来签名，这样apk就会跟系统中所有使用android.uid.shared共享UID。用这个的一般是该APK需要和home/contacts进程共享数据。 在源码的/build/target/product/security里面看到对应的密钥，其中.pk8代表私钥，.pem公钥，一定是成对出现的。 查看.pem公钥方法openssl x509 -in cert.pem(文件名) -noout -text 关于.pk8和.pem在下面会继续详细介绍。 1.3 签名相关知识1.3.1 数据摘要消息摘要算法（Message Digest Algorithm）是一种能产生特殊输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就被称作原始数据的消息摘要。简单点说就是提取数据的“指纹”。 著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。 消息摘要的主要特点有： 1）无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出。2）一般来说（不考虑碰撞的情况下），只要输入的原始数据不同，对其进行摘要以后产生的消息摘要也必不相同，即使原始数据稍有改变，输出的消息摘要便完全不同。但是，相同的输入必会产生相同的输出。 3）具有不可逆性，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的原始消息。 1.3.2 jarsign和signapk工具这两个都是android系统中使用的签名工具。jarsign是Java本生自带的一个工具，他可以对jar进行签名的。而signapk是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样。 jarsign工具 签名时使用的是 keystore 文件。 signapk工具 签名时使用的是pk8、pem文件。 keystore 文件 和 pk8、pem文件 是可以转化的，在开发具有系统权限的应用的时候我们一般是将pk8、pem文件转化成keystore 文件，然后再在AS中设置调试编译打包使用的keystore 文件，这样就可以像开发普通应用一样去开发具有系统权限的应用，而不是每次打包后再用signapk工具重新签名。 这边补充下：keystore 是Eclipse 打包生成的签名。 而 。jks是Android studio 生成的签名！都是用来打包的，并保证应用的唯一性，它们是可以互相转换的。 因为我们现在常用的是jks文件，可以通过代码获取jks文件的公钥和私钥信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.UnrecoverableKeyException;import java.security.cert.CertificateException;import javax.security.cert.Certificate;public class JKSTesting &#123; public static PublicKey getPublicKey(String keyStoreFile, String storeFilePass, String keyAlias) &#123; // 读取密钥是所要用到的工具类 KeyStore ks; // 公钥类所对应的类 PublicKey pubkey = null; try &#123; // 得到实例对象 ks = KeyStore.getInstance(\"JKS\"); FileInputStream fin; try &#123; // 读取JKS文件 fin = new FileInputStream(keyStoreFile); try &#123; // 读取公钥 ks.load(fin, storeFilePass.toCharArray()); java.security.cert.Certificate cert = ks .getCertificate(keyAlias); pubkey = cert.getPublicKey(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; return pubkey; &#125; /** * 得到私钥 * * @param keyStoreFile * 私钥文件 * @param storeFilePass * 私钥文件的密码 * @param keyAlias * 别名 * @param keyAliasPass * 密码 * @return */ public static PrivateKey getPrivateKey(String keyStoreFile, String storeFilePass, String keyAlias, String keyAliasPass) &#123; KeyStore ks; PrivateKey prikey = null; try &#123; ks = KeyStore.getInstance(\"JKS\"); FileInputStream fin; try &#123; fin = new FileInputStream(keyStoreFile); try &#123; try &#123; ks.load(fin, storeFilePass.toCharArray()); // 先打开文件 prikey = (PrivateKey) ks.getKey(keyAlias, keyAliasPass .toCharArray()); // 通过别名和密码得到私钥 &#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (KeyStoreException e) &#123; e.printStackTrace(); &#125; return prikey; &#125; public static void main(String[] args) &#123; PublicKey publicKey; PrivateKey privateKey; publicKey=getPublicKey(\"*******\",\"*******\", \"*******\"); privateKey=getPrivateKey(\"*******\",\"*******\", \"*******\",\"*******\"); System.out.println(\"publicKey\"); System.out.println(publicKey.toString()); System.out.println(\"privateKey\"); System.out.println(privateKey.toString()); &#125;&#125; 1.3.3 签名后生成的文件解压签名后的apk文件，在 META-INF 文件夹中可以看到以下格式的文件 .RSA或者DSA .SF MANIFEST.MF文件 Android中是允许使用多个 keystore 对apk进行签名的，这样在 META-INF 就会生成多对（.RSA和.SF）的文件，以 keystore 文件的 alias 的值为名称。如果是用 signapk工具 进行签名的话就会直接固定命名CERT。 1.3.3.1 MANIFEST.MF文件我们先看下这个文件的内容 1234567891011121314151617181920212223242526272829303132Name: lombok/installer/InstallerGUI$4.SCL.lombokSHA1-Digest: ZSCgYd7ezY8EyCteY5YFVNSzqbg=Name: res/drawable-hdpi-v4/modify_phone_num_step_first.pngSHA1-Digest: 1A/23eA5r36ww5luAwlaK5n42fc=Name: res/drawable-hdpi-v4/right_kuohao_focus.pngSHA1-Digest: fPzTTOc+c1ogDOlHKpeJ0JGDt6U=Name: res/layout/activity_modify_phone.xmlSHA1-Digest: aE+Ctjnxcu/xHp79HhRZ8LvnA/c=Name: res/drawable-1920x1080/item_h_default.pngSHA1-Digest: KA0HpPJUVaKTpTnF5ouiJmRNyXo=Name: lombok/delombok/LombokOptionsFactory$1.SCL.lombokSHA1-Digest: QlP0zlFTJ9scHtfLL3/OZNhA2uw=Name: AndroidManifest.xmlSHA1-Digest: lkuasUmz9QVhBrAh8JEMmyvL65c=Name: lombok/installer/InstallerGUI$9.SCL.lombokSHA1-Digest: ifEHckOynWf1wUlfPH/aoj73utk=Name: lombok/core/LombokConfiguration.SCL.lombokSHA1-Digest: XOaLbgugkPhHqkxGiDFxUvxNJSA=Name: lombok/installer/eclipse/JbdsLocationProvider.SCL.lombokSHA1-Digest: 3M+Q/7s7VwuoOWk1hpUJe8yBJjM=Name: res/drawable-hdpi-v4/user_prog_entry_layer.pngSHA1-Digest: 5oJ0Hv4o+c7PkwJ4MOox2/xZmzU= 文件的内容是逐一遍历apk里面的所有条目，如果是目录就跳过，如果是一个文件，就用SHA1（或者SHA256）消息摘要算法提取出该文件的摘要然后进行BASE64编码后，作为“SHA1-Digest”属性的值写入到MANIFEST.MF文件中的一个块中。该块有一个“Name”属性，其值就是该文件在apk包中的路径。 1.3.3.2 SF文件12345678910111213141516171819Signature-Version: 1.0X-Android-APK-Signed: 2SHA1-Digest-Manifest: oZ0/oKbtbxza48iz2t1zT9MQ/vw=Created-By: 1.0 (Android)Name: res/layout/play_progress_tip_layout.xmlSHA1-Digest: zGKChGzCciVxMBfsf/9QS1jA9f0=Name: res/anim/boot_one_circle.xmlSHA1-Digest: P4oLIBrBAQqjEn2VUDXvvuYXfeI=Name: res/drawable-hdpi-v4/myapp_del_no_focus.pngSHA1-Digest: GEyz0DWb4vzq33MLCBnxtTVbWQE=Name: lombok/eclipse/handlers/HandleLog$LoggingFramework.SCL.lombokSHA1-Digest: LSHMxv3Atl0Z7MCQaPf9yKvhax4=Name: lombok/delombok/DelombokApp$1.SCL.lombokSHA1-Digest: DfUlhS1EZ55lpPpz+vsDIf847No= SF文件记载的内容： 计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下 逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest 1.3.3.3 RSA文件因为RSA文件加密了，所以我们需要用openssl命令才能查看其内容 openssl pkcs7 -inform DER -in CERT.RSA(文件名) -noout -print_certs –text 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Certificate: Data: Version: 3 (0x2) //版本号 Serial Number: 610763924 (0x24678494) //证书序列号 Signature Algorithm: sha256WithRSAEncryption //算法 Issuer: CN=icntv //发行者名称 Validity Not Before: Nov 5 15:43:01 2012 GMT //生效日期 Not After : Oct 12 15:43:01 2112 GMT //终止日期 Subject: CN=icntv //主体名称 //算法 参数 秘钥:主体公钥信息，包含开发者的加密算法以及密钥信息 Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:80:03:44:30:c7:6a:93:e3:3a:94:8e:b6:a8:70: e0:19:eb:00:de:85:a9:b8:57:b9:e5:2e:0a:db:c0: 1b:e4:56:c0:32:7c:f3:54:65:ca:20:02:df:6c:3b: f6:7e:29:71:3d:aa:69:ac:e9:61:17:65:9c:9b:94: 74:40:a2:67:f8:65:26:2c:a0:cf:2a:2e:15:7d:04: c2:c2:44:d7:28:8a:c0:a7:65:ac:e5:eb:c6:67:ce: 74:82:47:0a:af:3f:7d:a9:d8:de:49:39:9e:17:49: b4:f7:86:39:e1:02:25:6b:6e:94:82:95:3b:f2:62: 07:6a:41:33:0b:3a:d2:31:a7:2b:68:c7:73:49:2f: 7b:5c:83:51:05:5b:a4:5d:01:cf:3a:b9:98:f4:a1: 6b:20:85:f9:3f:aa:e7:5e:e6:35:82:43:1e:d2:ed: 90:8c:24:47:22:06:95:ab:8b:fd:12:0f:23:13:74: 07:f4:02:e0:94:71:0e:7b:b8:ae:02:54:84:d6:e3: eb:91:a5:41:7b:6e:c5:26:57:9d:b6:ab:58:f0:e4: c4:d0:a1:9e:23:31:02:ff:60:98:a3:4e:2b:d2:58: 6c:d1:12:a8:95:cb:19:69:0d:76:bc:50:e1:ed:6a: e3:a9:42:9a:b5:76:55:fb:34:41:b3:00:9a:99:cb: 9c:d9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 6D:26:4A:D1:30:4C:15:D6:EE:9B:63:95:AF:C1:63:7F:8B:83:31:68 //算法 参数 已加密的hash值：用CA的私钥对证书的所有域以及这些域的Hash值一起加密 Signature Algorithm: sha256WithRSAEncryption 08:2d:00:a8:6e:ad:67:87:6b:20:31:b0:d3:0f:52:64:cf:23: ab:05:3a:53:8b:30:05:3e:47:0a:5c:19:1a:b0:e9:8d:4b:1d: 2c:f6:41:33:ba:b3:67:0a:77:46:bb:46:57:ef:f9:66:d8:68: 5d:41:be:3c:1d:35:f3:a3:58:4a:f4:f0:7f:87:1b:e4:0c:0c: 84:91:08:23:4c:9f:82:44:da:11:b1:60:b9:db:da:f6:36:58: 25:f6:ae:dc:4c:24:0d:1f:65:05:ee:9c:9c:c5:64:4a:a0:21: 4c:53:5a:3c:3e:c6:ad:67:cb:36:5e:6d:58:85:f5:2f:dd:6d: c8:cc:7b:09:ba:8c:bd:6f:e8:53:d1:88:8d:35:90:48:ba:db: 5b:16:22:31:46:da:aa:91:ba:50:57:a5:38:08:af:05:ae:a1: ec:3d:4f:fe:06:88:c8:60:9d:b9:16:00:7a:74:c8:a1:85:53: dd:b5:0c:b7:09:f3:d4:e5:07:29:12:05:c2:83:84:c3:96:ec: ba:ad:12:ad:1d:cf:52:d3:e3:ce:47:6a:89:4a:b1:39:c3:d2: b7:e0:d5:77:d9:02:e5:17:89:09:00:b3:cb:38:38:ef:97:90: 35:27:41:90:cf:b7:98:34:21:69:bd:64:ad:2b:23:85:97:96: 6b:74:56:9b 1.3.4 为什么android要用这样的方式加密 首先，如果你改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。 其次，如果你对更改的过的文件相应的算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。 最后，如果你还不死心，继续计算MANIFEST.MF的摘要值，相应的更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。 那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。所以，如果要重新打包后的应用程序能再Android设备上安装，必须对其进行重签名。 1.3.5 总结1.3.5.1 概念 数据指纹就是对一个数据源做SHA/MD5算法，这个值是唯一的 签名文件技术就是：数据指纹+RSA算法 证书文件中包含了公钥信息和其他信息 在Android签名之后，其中SF就是签名文件，RSA就是证书文件我们可以使用openssl来查看RSA文件中的证书信息和公钥信息 1.3.5.2 流程 对Apk中的每个文件做一次算法(数据摘要+Base64编码)，保存到MANIFEST.MF文件中 对MANIFEST.MF整个文件做一次算法(数据摘要+Base64编码)，存放到CERT.SF文件的头属性中，在对MANIFEST.MF文件中各个属性块做一次算法(数据摘要+Base64编码)，存到到一个属性块中。 对CERT.SF文件做签名，内容存档到CERT.RSA中 关于签名相关知识因为本人对安全这块涉及很少，所以基本都是引用自blog（https://blog.csdn.net/jiangwei0910410003/article/details/50402000） 的内容 二.问题分析前面我们对相关的知识做了梳理，现在回到我们的需求上来。已知需求为：要求系统级权限应用使用系统签名文件和指定的第三方签名文件都可以完成验证。在之前的PKMS服务的介绍中我们知道在应用安装和开机扫描的时候是需要做签名验证的，我们现在以应用安装为入口对源码进行跟踪。（关于PKMS服务的源码分析blog会在后续更新出来） 下面的代码基于android6.0，设计的代码文件路径如下：frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.javaframeworks/base/core/java/android/content/pm/PackageParser.javalibcore/luni/src/main/java/java/util/jar/StrictJarFile.java 2.1 installPackageLI这边要先声明 installPackageLI 并不是一个应用安装的入口方法，应用的安装涉及到的服务还有 PackageManagerInstallerService 服务，我们可以简单的把应用的安装分为两个步骤：一是拷贝阶段，二是安装阶段。而这个过程的控制则是由 PackageManagerInstallerService 进行控制的，我们这边要介绍的 installPackageLI 方法算是 第二阶段的入口方法（因为本文主要是介绍签名验证，关于应用安装过程会有跳过，毕竟这个不是本文的重点，后续文章会介绍6.0应用安装的过程。） installPackageLI 方法比较长，篇幅原因就不全部拷贝出来了，这边列举下该方法做了哪些东西 解析apk文件 收集应用的签名 检查安装参数是否带有强制替换参数，并做相应的处理 如果该应用已安装则做相应的验证,还需要判断升级的是否是系统应用 检查应用中定义的权限（这部分的判断会比较多,但不是这次分析的重点） 系统应用升级的话会对安装位置做检查不允许安装在sd卡上 执行 replacePackageLI 或者 installNewPackageLI 这边我们的重点在第二点收集应用的签名和第四点中调用的 verifySignaturesLP 方法。首先我们先看看第二点的代码 123456789101112131415161718192021222324252627 final PackageParser.Package pkg; try &#123; pkg = pp.parsePackage(tmpPackageFile, parseFlags); &#125; catch (PackageParserException e) &#123; res.setError(\"Failed parse during installPackageLI\", e); return; &#125; // Mark that we have an install time CPU ABI override. pkg.cpuAbiOverride = args.abiOverride; String pkgName = res.name = pkg.packageName; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) &#123; if ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == 0) &#123; res.setError(INSTALL_FAILED_TEST_ONLY, \"installPackageLI\"); return; &#125; &#125;//收集应用签名 try &#123; pp.collectCertificates(pkg, parseFlags); pp.collectManifestDigest(pkg); &#125; catch (PackageParserException e) &#123; res.setError(\"Failed collect during installPackageLI\", e); return; &#125; 代码很简单,涉及到一个新的类 ackageParser.Package，我们跟踪进 collectCertificates 方法中查看 2.2 collectCertificates12345678910111213public void collectCertificates(Package pkg, int flags) throws PackageParserException &#123; pkg.mCertificates = null; pkg.mSignatures = null; pkg.mSigningKeys = null; collectCertificates(pkg, new File(pkg.baseCodePath), flags); if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) &#123; for (String splitCodePath : pkg.splitCodePaths) &#123; collectCertificates(pkg, new File(splitCodePath), flags); &#125; &#125;&#125; 这边我们重点关注重载方法 collectCertificates 这里面才是真正实现部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private static void collectCertificates(Package pkg, File apkFile, int flags) throws PackageParserException &#123; final String apkPath = apkFile.getAbsolutePath(); StrictJarFile jarFile = null; try &#123; jarFile = new StrictJarFile(apkPath); // Always verify manifest, regardless of source final ZipEntry manifestEntry = jarFile.findEntry(ANDROID_MANIFEST_FILENAME); if (manifestEntry == null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Package \" + apkPath + \" has no manifest\"); &#125; final List&lt;ZipEntry&gt; toVerify = new ArrayList&lt;&gt;(); toVerify.add(manifestEntry); // If we're parsing an untrusted package, verify all contents if ((flags &amp; PARSE_IS_SYSTEM) == 0) &#123; final Iterator&lt;ZipEntry&gt; i = jarFile.iterator(); while (i.hasNext()) &#123; final ZipEntry entry = i.next(); if (entry.isDirectory()) continue; if (entry.getName().startsWith(\"META-INF/\")) continue; if (entry.getName().equals(ANDROID_MANIFEST_FILENAME)) continue; toVerify.add(entry); &#125; &#125; // Verify that entries are signed consistently with the first entry // we encountered. Note that for splits, certificates may have // already been populated during an earlier parse of a base APK. for (ZipEntry entry : toVerify) &#123; final Certificate[][] entryCerts = loadCertificates(jarFile, entry); if (ArrayUtils.isEmpty(entryCerts)) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES, \"Package \" + apkPath + \" has no certificates at entry \" + entry.getName()); &#125; final Signature[] entrySignatures = convertToSignatures(entryCerts); if (pkg.mCertificates == null) &#123; pkg.mCertificates = entryCerts; pkg.mSignatures = entrySignatures; pkg.mSigningKeys = new ArraySet&lt;PublicKey&gt;(); for (int i=0; i &lt; entryCerts.length; i++) &#123; pkg.mSigningKeys.add(entryCerts[i][0].getPublicKey()); &#125; &#125; else &#123; if (!Signature.areExactMatch(pkg.mSignatures, entrySignatures)) &#123; throw new PackageParserException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, \"Package \" + apkPath + \" has mismatched certificates at entry \" + entry.getName()); &#125; &#125; &#125; &#125; catch (GeneralSecurityException e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING, \"Failed to collect certificates from \" + apkPath, e); &#125; catch (IOException | RuntimeException e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES, \"Failed to collect certificates from \" + apkPath, e); &#125; finally &#123; closeQuietly(jarFile); &#125;&#125; 这边我们重点关注这里 123456pkg.mCertificates = entryCerts;pkg.mSignatures = entrySignatures;pkg.mSigningKeys = new ArraySet&lt;PublicKey&gt;();for (int i=0; i &lt; entryCerts.length; i++) &#123; pkg.mSigningKeys.add(entryCerts[i][0].getPublicKey());&#125; 因为我们的需求是增加一个支持系统级权限的签名，所以关于apk和签名校对来保证apk未被篡改不是我们关注的重点，我们关注的重点应该是证书文件（RSA文件）里面的公钥和我们需要比对的公钥是否是一致的。所以前面签名校对我们直接跳过，直接看这边获取到的公钥信息保存在上面代码所示的位置。 关于这个签名信息的获取过程建议查看姜老师的这篇blog：https://blog.csdn.net/jiangwei0910410003/article/details/50443505 现在我们获取到了apk的公钥信息，那么在哪里进行比较呢？这时候我们回到 2.1 中 第四点提到的 verifySignaturesLP 方法我们先来看看这个方法里面都做了什么 2.4 verifySignaturesLP12345678910111213141516171819202122232425262728293031323334353637383940414243 private void verifySignaturesLP(PackageSetting pkgSetting, PackageParser.Package pkg) throws PackageManagerException &#123; if (pkgSetting.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" signatures do not match the \" + \"previously installed version; ignoring!\"); &#125; &#125;//这边是重点了 检查shared uid的签名信息 // Check for shared user signatures if (pkgSetting.sharedUser != null &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, \"Package \" + pkg.packageName + \" has no signatures that match those in shared user \" + pkgSetting.sharedUser.name + \"; ignoring!\"); &#125; &#125; &#125; 如上面代码所示的，在这里会对 shared uid 的apk进行签名认证，那么我们现在思路有了，因为到这里的时候apk的公钥信息已经收集到了，那么只需要在这里多做一个判断：判断公钥信息是否和指定的第三方公钥信息一致就可以了。 verifySignaturesLP 并不止是在 installPackageLI 被调用,在 scanPackageDirtyLI 都也有调用该方法，而 scanPackageDirtyLI 在安装apk和开机扫描apk（例如：installNewPackageLI replaceSystemPackageLI replaceNonSystemPackageLI）的时候都会被调用到，所以我们只需要在这个方法里面添加判断即可全部覆盖到。 三.解决方案 12345678910111213141516171819202122232425262728private boolean verifySignaturesLP(PackageSetting pkgSetting, PackageParser.Package pkg) &#123; if (pkgSetting.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match if (compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; Slog.e(TAG, \"Package \" + pkg.packageName + \" signatures do not match the previously installed version; ignoring!\"); mLastScanError = PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE; return false; &#125; &#125; // Check for shared user signatures if (pkgSetting.sharedUser != null &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != null) &#123; if( !isNeedSystemSign || (isNeedPackageSignatures() &amp;&amp; checkPackageSignatures(pkg))) &#123; isNeedSystemSign = true; return true; &#125;else if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; Slog.e(TAG, \"Package \" + pkg.packageName + \" has no signatures that match those in shared user \" + pkgSetting.sharedUser.name + \"; ignoring!\"); mLastScanError = PackageManager.INSTALL_FAILED_SHARED_USER_INCOMPATIBLE; return false; &#125; &#125; return true;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private boolean checkPackageSignatures(PackageParser.Package pkg)&#123; if (DEBUG_INSTALL) Slog.i(TAG, \"checkPackageSignatures(\"+pkg.packageName+\")\"); if(pkg == null) return false; FileInputStream is =null; try&#123; is= new FileInputStream(new File(\"/etc/CERT.RSA\")); &#125;catch(java.io.FileNotFoundException e)&#123; e.printStackTrace(); return false; &#125; byte[] readBuffer=new byte[8192];; try&#123; while (is.read(readBuffer, 0, readBuffer.length) != -1) &#123; // not using &#125; is.close(); &#125;catch(java.io.IOException e)&#123; e.printStackTrace(); return false; &#125; String publickeytxt = null; Signature auths=new Signature(readBuffer); //Slog.i(TAG, \"print:auths.toCharsString:\"+auths.toCharsString()); try&#123; Slog.i(TAG, \"auths.PublicKey:\"+auths.getPublicKey()); &#125;catch (Exception e) &#123; try&#123; StringBuffer sb=new StringBuffer(); InputStreamReader read = new InputStreamReader(new FileInputStream(new File(\"/etc/CERT.RSA\"))); BufferedReader bufferedReader = new BufferedReader(read); while((publickeytxt = bufferedReader.readLine()) != null)&#123; sb.append(publickeytxt); &#125; publickeytxt = sb.toString(); Slog.i(TAG, \"PublicKey: \" + publickeytxt); read.close(); bufferedReader.close(); &#125;catch(java.io.IOException e1)&#123; &#125; &#125; Signature authsSignatures[] = new Signature[1]; authsSignatures[0]=auths; if(pkg.mSignatures[0]==null)&#123; Slog.i(TAG, \"package have not Signatures\"); return false; &#125; if (DEBUG_INSTALL)&#123; try&#123; Slog.i(TAG, \"pkg.mSignatures[0]:\"+ pkg.mSignatures[0].getPublicKey()); Slog.i(TAG, \"publickeytxt.length(): \" + publickeytxt.length() + \" index :\" + (pkg.mSignatures[0].getPublicKey() + \"\").indexOf(publickeytxt)); &#125;catch (Exception e)&#123; &#125; &#125; //if(PackageManager.SIGNATURE_MATCH == compareSignatures(authsSignatures,pkg.mSignatures))&#123; // return true; //&#125; try&#123; if(authsSignatures[0].getPublicKey().equals(pkg.mSignatures[0].getPublicKey()))&#123; isNeedSystemSign = false; Slog.i(TAG, \"verification success1\"); return true; &#125; &#125;catch(java.security.cert.CertificateException e)&#123; try&#123; if((publickeytxt.length() &gt; 0) &amp;&amp; (pkg.mSignatures[0].getPublicKey() + \"\").indexOf(publickeytxt) &gt; 0)&#123; isNeedSystemSign = false; Slog.i(TAG, \"verification success2\"); return true; &#125; &#125;catch (Exception e1)&#123; &#125; &#125; Slog.i(TAG, \"verification failed\"); return false;&#125; 四.补充方案中获取RSA文件公钥的方法在app中是无法直接使用的，因为有些方法是hide的只能在framework层或者反射使用，这样不是很方便，这边根据源码提取一个简单的类可以在app中直接使用。有兴趣的同学也可以用jks文件打包一个apk进行验证：用同一个jks文件打包两个apk然后分别解压获取RAS文件 用下面的方法获取公钥验证是否一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.lang.ref.SoftReference;import java.security.PublicKey;import java.security.cert.Certificate;import java.security.cert.CertificateEncodingException;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.Arrays;public class SignatureTest &#123; private final byte[] mSignature; private int mHashCode; private boolean mHaveHashCode; private SoftReference&lt;String&gt; mStringRef; private Certificate[] mCertificateChain; /** * Create Signature from an existing raw byte array. */ public SignatureTest(byte[] signature) &#123; mSignature = signature.clone(); mCertificateChain = null; &#125; /** * Create signature from a certificate chain. Used for backward * compatibility. * * @throws CertificateEncodingException * */ public SignatureTest(Certificate[] certificateChain) throws CertificateEncodingException &#123; mSignature = certificateChain[0].getEncoded(); if (certificateChain.length &gt; 1) &#123; mCertificateChain = Arrays.copyOfRange(certificateChain, 1, certificateChain.length); &#125; &#125; private static final int parseHexDigit(int nibble) &#123; if ('0' &lt;= nibble &amp;&amp; nibble &lt;= '9') &#123; return nibble - '0'; &#125; else if ('a' &lt;= nibble &amp;&amp; nibble &lt;= 'f') &#123; return nibble - 'a' + 10; &#125; else if ('A' &lt;= nibble &amp;&amp; nibble &lt;= 'F') &#123; return nibble - 'A' + 10; &#125; else &#123; throw new IllegalArgumentException(\"Invalid character \" + nibble + \" in hex string\"); &#125; &#125; /** * Create Signature from a text representation previously returned by * &#123;@link #toChars&#125; or &#123;@link #toCharsString()&#125;. Signatures are expected to * be a hex-encoded ASCII string. * * @param text hex-encoded string representing the signature * @throws IllegalArgumentException when signature is odd-length */ public SignatureTest(String text) &#123; final byte[] input = text.getBytes(); final int N = input.length; if (N % 2 != 0) &#123; throw new IllegalArgumentException(\"text size \" + N + \" is not even\"); &#125; final byte[] sig = new byte[N / 2]; int sigIndex = 0; for (int i = 0; i &lt; N;) &#123; final int hi = parseHexDigit(input[i++]); final int lo = parseHexDigit(input[i++]); sig[sigIndex++] = (byte) ((hi &lt;&lt; 4) | lo); &#125; mSignature = sig; &#125; /** * Encode the Signature as ASCII text. */ public char[] toChars() &#123; return toChars(null, null); &#125; /** * Encode the Signature as ASCII text in to an existing array. * * @param existingArray Existing char array or null. * @param outLen Output parameter for the number of characters written in * to the array. * @return Returns either &lt;var&gt;existingArray&lt;/var&gt; if it was large enough * to hold the ASCII representation, or a newly created char[] array if * needed. */ public char[] toChars(char[] existingArray, int[] outLen) &#123; byte[] sig = mSignature; final int N = sig.length; final int N2 = N*2; char[] text = existingArray == null || N2 &gt; existingArray.length ? new char[N2] : existingArray; for (int j=0; j&lt;N; j++) &#123; byte v = sig[j]; int d = (v&gt;&gt;4)&amp;0xf; text[j*2] = (char)(d &gt;= 10 ? ('a' + d - 10) : ('0' + d)); d = v&amp;0xf; text[j*2+1] = (char)(d &gt;= 10 ? ('a' + d - 10) : ('0' + d)); &#125; if (outLen != null) outLen[0] = N; return text; &#125; /** * Return the result of &#123;@link #toChars()&#125; as a String. */ public String toCharsString() &#123; String str = mStringRef == null ? null : mStringRef.get(); if (str != null) &#123; return str; &#125; str = new String(toChars()); mStringRef = new SoftReference&lt;String&gt;(str); return str; &#125; /** * @return the contents of this signature as a byte array. */ public byte[] toByteArray() &#123; byte[] bytes = new byte[mSignature.length]; System.arraycopy(mSignature, 0, bytes, 0, mSignature.length); return bytes; &#125; /** * Returns the public key for this signature. * * @throws CertificateException when Signature isn't a valid X.509 * certificate; shouldn't happen. * */ public PublicKey getPublicKey() throws CertificateException &#123; final CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\"); final ByteArrayInputStream bais = new ByteArrayInputStream(mSignature); final Certificate cert = certFactory.generateCertificate(bais); return cert.getPublicKey(); &#125; @Override public int hashCode() &#123; if (mHaveHashCode) &#123; return mHashCode; &#125; mHashCode = Arrays.hashCode(mSignature); mHaveHashCode = true; return mHashCode; &#125; public static PublicKey getPublickey(String path)&#123; FileInputStream is =null; try&#123; is= new FileInputStream(new File(path)); &#125;catch(java.io.FileNotFoundException e)&#123; e.printStackTrace(); return null; &#125; byte[] readBuffer=new byte[8192];; try&#123; while (is.read(readBuffer, 0, readBuffer.length) != -1) &#123; // not using &#125; is.close(); &#125;catch(java.io.IOException e)&#123; e.printStackTrace(); return null; &#125; String publickeytxt = null; SignatureTest auths=new SignatureTest(readBuffer); try &#123; return auths.getPublicKey(); &#125; catch (CertificateException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125;","categories":[],"tags":[]},{"title":"Binder应用层核心类","slug":"Binder应用层核心类","date":"2018-06-07T06:35:34.000Z","updated":"2018-06-07T07:51:08.760Z","comments":true,"path":"2018/06/07/Binder应用层核心类/","link":"","permalink":"http://yoursite.com/2018/06/07/Binder应用层核心类/","excerpt":"","text":"一. 概述应用层核心类主要是指libbinder库里的 IInterface、BpInterface、BpInterface、BBinder、BPBinder和IBinder类。 源码位置：frameworks\\native\\libs\\binderframeworks\\native\\include\\binder 二.核心类解析2.1 IBinder.h文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class IBinder : public virtual RefBase&#123;public: enum &#123; FIRST_CALL_TRANSACTION = 0x00000001, LAST_CALL_TRANSACTION = 0x00ffffff, PING_TRANSACTION = B_PACK_CHARS('_','P','N','G'), DUMP_TRANSACTION = B_PACK_CHARS('_','D','M','P'), INTERFACE_TRANSACTION = B_PACK_CHARS('_', 'N', 'T', 'F'), SYSPROPS_TRANSACTION = B_PACK_CHARS('_', 'S', 'P', 'R'), FLAG_ONEWAY = 0x00000001 &#125;; IBinder(); virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; descriptor); virtual const String16&amp; getInterfaceDescriptor() const = 0; virtual bool isBinderAlive() const = 0; virtual status_t pingBinder() = 0; virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args) = 0; virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) = 0; class DeathRecipient : public virtual RefBase &#123; public: virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) = 0; &#125;; virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0) = 0; virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL) = 0; virtual bool checkSubclass(const void* subclassID) const; typedef void (*object_cleanup_func)(const void* id, void* obj, void* cleanupCookie); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func) = 0; virtual void* findObject(const void* objectID) const = 0; virtual void detachObject(const void* objectID) = 0; virtual BBinder* localBinder(); virtual BpBinder* remoteBinder();protected: virtual ~IBinder();private:&#125;; 2.2 Binder.h文件2.2.1 BBinder类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BBinder : public IBinder&#123;public: BBinder(); virtual const String16&amp; getInterfaceDescriptor() const; virtual bool isBinderAlive() const; virtual status_t pingBinder(); virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0); virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func); virtual void* findObject(const void* objectID) const; virtual void detachObject(const void* objectID); virtual BBinder* localBinder();protected: virtual ~BBinder(); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0);private: BBinder(const BBinder&amp; o); BBinder&amp; operator=(const BBinder&amp; o); class Extras; atomic_uintptr_t mExtras; // should be atomic&lt;Extras *&gt; void* mReserved0;&#125;; 2.2.2 BpRefBase类12345678910111213141516171819202122class BpRefBase : public virtual RefBase&#123;protected: BpRefBase(const sp&lt;IBinder&gt;&amp; o); virtual ~BpRefBase(); virtual void onFirstRef(); virtual void onLastStrongRef(const void* id); virtual bool onIncStrongAttempted(uint32_t flags, const void* id); inline IBinder* remote() &#123; return mRemote; &#125; inline IBinder* remote() const &#123; return mRemote; &#125;private: BpRefBase(const BpRefBase&amp; o); BpRefBase&amp; operator=(const BpRefBase&amp; o); //这边的IBinder对象其实是 BpBinder 类型的 (#2.3节) IBinder* const mRemote; RefBase::weakref_type* mRefs; volatile int32_t mState;&#125;; 2.3 BpBinder.h 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class BpBinder : public IBinder&#123;public: BpBinder(int32_t handle); inline int32_t handle() const &#123; return mHandle; &#125; virtual const String16&amp; getInterfaceDescriptor() const; virtual bool isBinderAlive() const; virtual status_t pingBinder(); virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual status_t linkToDeath(const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0); virtual status_t unlinkToDeath( const wp&lt;DeathRecipient&gt;&amp; recipient, void* cookie = NULL, uint32_t flags = 0, wp&lt;DeathRecipient&gt;* outRecipient = NULL); virtual void attachObject( const void* objectID, void* object, void* cleanupCookie, object_cleanup_func func); virtual void* findObject(const void* objectID) const; virtual void detachObject(const void* objectID); virtual BpBinder* remoteBinder(); status_t setConstantData(const void* data, size_t size); void sendObituary(); class ObjectManager &#123; public: ObjectManager(); ~ObjectManager(); void attach( const void* objectID, void* object, void* cleanupCookie, IBinder::object_cleanup_func func); void* find(const void* objectID) const; void detach(const void* objectID); void kill(); private: ObjectManager(const ObjectManager&amp;); ObjectManager&amp; operator=(const ObjectManager&amp;); struct entry_t &#123; void* object; void* cleanupCookie; IBinder::object_cleanup_func func; &#125;; KeyedVector&lt;const void*, entry_t&gt; mObjects; &#125;;protected: virtual ~BpBinder(); virtual void onFirstRef(); virtual void onLastStrongRef(const void* id); virtual bool onIncStrongAttempted(uint32_t flags, const void* id);private: const int32_t mHandle; struct Obituary &#123; wp&lt;DeathRecipient&gt; recipient; void* cookie; uint32_t flags; &#125;; void reportOneDeath(const Obituary&amp; obit); bool isDescriptorCached() const; mutable Mutex mLock; volatile int32_t mAlive; volatile int32_t mObitsSent; Vector&lt;Obituary&gt;* mObituaries; ObjectManager mObjects; Parcel* mConstantData; mutable String16 mDescriptorCache;&#125;; 2.4 IInterface.h文件2.4.1 两个宏DECLARE_META_INTERFACE 宏定义的内容 123456789// ----------------------------------------------------------------------#define DECLARE_META_INTERFACE(INTERFACE) \\ static const android::String16 descriptor; \\ static android::sp&lt;I##INTERFACE&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\ 这个宏定义了如下东西： 静态成员变量 descriptor 静态函数 asInterface() 类的构造函数 类的析构函数 IMPLEMENT_META_INTERFACE 宏定义的内容 12345678910111213141516171819202122#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ const android::String16 I##INTERFACE::descriptor(NAME); \\ const android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\ &#125; \\ android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ &#123; \\ android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) &#123; \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) &#123; \\ intr = new Bp##INTERFACE(obj); \\ &#125; \\ &#125; \\ return intr; \\ &#125; \\ I##INTERFACE::I##INTERFACE() &#123; &#125; \\ I##INTERFACE::~I##INTERFACE() &#123; &#125; \\ 这个宏定义了如下内容 静态成员变量 descriptor 赋值为name 定义了获取静态成员变量 descriptor 的方法 getInterfaceDescriptor() 实现了静态函数 asInterface()，函数作用：将binder的引用对象转化为代理对象（Binder 开篇 第二节 ） 实现类的构造函数 实现类的析构函数 2.4.2 三个类2.4.2.1 IInterface 类1234567891011class IInterface : public virtual RefBase&#123;public: IInterface(); static sp&lt;IBinder&gt; asBinder(const IInterface*); static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;);protected: virtual ~IInterface(); virtual IBinder* onAsBinder() = 0;&#125;; 2.4.2.3 BnInterface 类12345678910template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;; 2.4.2.3 BpInterface类这边继承了BpRefBase类，在上面 2.2.2节中 我们可以看到其实 BpRefBase 聚合了 BpBinder 类 123456789template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; INTERFACE 指定的是继承自 IInterface 接口的派生类。 2.5 总结","categories":[],"tags":[]},{"title":"日常问题:动态广播无法唤起singtask模式下的activity","slug":"日常问题-动态广播无法唤起singtask模式下的activity","date":"2018-06-06T17:12:00.000Z","updated":"2018-06-07T01:05:54.832Z","comments":true,"path":"2018/06/07/日常问题-动态广播无法唤起singtask模式下的activity/","link":"","permalink":"http://yoursite.com/2018/06/07/日常问题-动态广播无法唤起singtask模式下的activity/","excerpt":"","text":"之前在AMS服务中我们有梳理过activity的启动过程，刚好今天同事反馈了一个app开发中遇到的问题跟activity的启动相关，这边记录下问题的梳理过程。问题简单描述： 假设有如下两个app，分别以A和B指代，目前在A应用程序里面有一个activity名字叫做a1(a1的launchmode是singleTask),在a1里面注册了一个动态广播接收器用来接收自定义广播，当接收到广播后会继续启动a1本身 ，按照我们的设想这时候不管a1是否存在activity，这时候都应该弹掉上面的activity显示a1。 现在问题来了： 这时候如果A应用程序是在后台的，当前显示的应用程序是B的话，这时候如果发出广播，a1不能正常启动 如果这时候显示的是launch桌面，但是应用程序还是在后台，这时候如果发出广播，会看到a1正常启动并成为当前的焦点activity 如果我们把动态注册改为静态注册接收广播，这时候我们不管是出于第一种情况还是第二种情况都可以正常启动a1 上面就是我们遇到的问题，虽然我们可以通过最后一种用静态注册的形式来实现产品的需求，但是为什么静态注册就可以而动态注册就不可以呢？难道是静态注册可以赋予app更高的权限吗，如果是这样的话在framewrok层是怎么实现的呢？为何之前的activity启动流程中并未看到这部分的代码？相信作为有追求的你这时候肯定也是满脑子问号，那么下面就让我们追踪源码去看下到底为什么要有上面的现象出现吧。 在代码分析的过程中，肯定没有像下面讲解的那么顺利，因为经验原因我也是进行了各种的猜测然后去求证再反手打脸再继续猜测的循环过程，不断的在失败中找到正确的逻辑思路，之所以会出现这种情况还是经验太少的原因，但是随着我们遇到问题的增加，经验这种东西肯定是会累积的，这也是成长所需要经历的痛苦。 面对这样一个问题的时候我们需要先找一个切入点，按上面我们设想从生命周期来看，这时候至少是需要调用到a1 的 onResume 方法的，我们观察到的现象则是，在第一种情况下，a1所在的task中，在a1上面的activity确实是被弹出了task，但是通过log我们发现 onResume 并没有被调用。这就证明了至少正常的singtask launchmode的流程是有执行的，只是在执行生命周期上出现了问题，那么我们就从生命周期作为切入点触发。在之前的activity流程分析中我们知道一个activity的 onResume 在 ActivityStackSupervisor 类中是通过 ActivityStack类的 resumeTopActivityLocked 方法调起的，我们往这个方法里一探究竟： 123456789101112131415161718192021 final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125;//这边我们可以看到是通过这个方法继续往下走的 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result; &#125; resumeTopActivityInnerLocked 方法是在是太长了 所以就不完整截图，直接截取关键点1234567891011121314//这边判断如果当前的activity 跟要启动的activity next是同一个的话就不继续往下走了，而根据我们的根据错误的流程就是走到这里来了 // If the top activity is the resumed one, nothing to do. if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; // Make sure we have executed any pending transitions, since there // should be nothing left to do at this point. mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Top activity resumed \" + next); if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return false; &#125; 根据流程我们发现错误的原因就是 mResumedActivity == next，意味着当我们调到这边的时候 要启动的activity和当前的activity是同一个，这就奇怪了我们明明要启动的activity跟当前的不是同一个，那么问题肯定是出在next的赋值上了，我们往上看看next是在哪里赋值的。 12// Find the first activity that is not finishing.final ActivityRecord next = topRunningActivityLocked(null); 看来我们需要继续跟踪进 topRunningActivityLocked 方法进行分析了 123456789final ActivityRecord topRunningActivityLocked(ActivityRecord notTop) &#123; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; ActivityRecord r = mTaskHistory.get(taskNdx).topRunningActivityLocked(notTop); if (r != null) &#123; return r; &#125; &#125; return null;&#125; topRunningActivityLocked 方法很简单 就是是当前的stack 的 task 列表里面从后向前遍历。这时候我们上面的三个疑问可以先解答一个了： 在情况2 因为当前是在launch界面的话，因为launch进程是属于homeStack，并没有在进程的Stack中，所以这时候Stack的task列表其实只有进程A的，这样自然 获取到的next 和当前的 mResumedActivity（也就是launch的activity）是不一样的，所以不会进入到终止流程。 但是这样还是无法完全解释 情况3的为什么静态注册可以跳转，所以我们需要继续追踪 根据我们的追踪发现错误的情况就是因为 在task列表中，排在后面的是 程序B的task，这样获取到的自然是 程序B的当前activity了，那这就不对了按理到这步的时候 进程A的task应该已经移动到 task列表的最后面去了（也就是所谓的movefornt操作）。看来我们的疑问还是需要到 ActivityStackSupervisor 的 startActivityUncheckedLocked 方法中寻找答案了，我们需要找到在该方法中将要启动的后台task移动到前台的方法，下面是代码段 12345678910111213141516171819 if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; // We really do want to push this one into the user's face, right now. if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, \"bringingFoundTaskToFront\"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; // Caller wants to appear on home activity. intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125;&#125; 我们可以看到上面是执行移动操作的代码，要想进入这个代码段需要通过千前置条件的判断，这时候我们注意这个条件sourceRecord == null不知道大家发现重点没。在情况1和情况3有个重要的区别就是 sourceRecord 是不同的，在情况1中是动态注册的，并且是用的a1的Context进行启动的，所以这时候 sourceRecord 是不为null的，而在静态注册中我们使用的是application的Context来启动的，所以这时候 sourceRecord 是null，那么现在我们原因就找到了，sourceRecord 是否为null 导致的。所以如果是在情况1中我们可以尝试使用Applicaton的Context来启动就可以达到用动态注册也能实现跳转的问题（当然这时候需要给intent添加new_task flag）。","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"Binder 开篇","slug":"Binder开篇","date":"2018-06-05T15:59:00.000Z","updated":"2018-06-07T03:02:33.815Z","comments":true,"path":"2018/06/05/Binder开篇/","link":"","permalink":"http://yoursite.com/2018/06/05/Binder开篇/","excerpt":"","text":"一.概述Binder是Android系统提供的一种IPC（进程间通信）机制。由于Android是基于Linux内核的，因此，除了Binder外，还存在其他的IPC机制，例如管道和socket等。Binder相对于其他IPC机制来说，就更加灵活和方便了。对于初学Android的朋友而言，最难却又最想掌握的恐怕就是Binder机制了，因为Android系统基本上可以看作是一个基于Binder通信的C/S架构。Binder就像网络一样，把系统各个部分连接在了一起，因此它是非常重要的。 二.Binder对象定义Binder用到的对象很多，而且名字还挺像的，如果不先预先约定理清楚的话，在后续的文章中会容易看晕，这边我们先对文章内提到的各个对象先约定好称呼（非官方定义，仅在本系列文章中使用）。 Binder实体对象：Binder实体对象就是Binder服务的提供者。它必须继承自BBinder类，所以也叫 BBinder 对象。 Binder引用对象：Binder引用对象是Binder实体对象在客户端的代表，它的类型是BpBinder类，所以也叫 BpBinder 对象。 Binder代理对象：代理对象也叫接口对象，它主要是为客户端上层应用提供接口服务，从IInterface类派生。它实现了Binder服务的函数接口，当然这只是一个空壳，里面其实是直接转调Binder引用对象的方法。一般应用程序是使用Binder代理对象的。代理对象和引用的对象的关系是多对1的。 IBinder对象：BBinder 和 BpBinder 都是从 IBinder 类中继承的。所以可以用IBinder对象来统称它们两个。 三.Binder架构Binder通信架构主要由四部分组成 3.1 Binder驱动Binder驱动位于内核空间，是Binder架构的核心，通过文件系统的标准接口（open ioctl mmap等）向用户空间提供服务。应用层和Binder驱动的数据交换是通过ioctl进行（ioctl可以达到一次系统调用就完成用户系统和Binder驱动的双向数据交互）。 作用：提供Binder通信的通道、维护Binder对象的引用计数、转换传输中的Binder实体对象和引用对象、管理数据缓存区。 3.2 ServiceManagerServiceManager是一个守护进程，它是在init进程中通过init.rc文件启动的（Init进程 2.1.10节）。12345678910service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm 作用：提供Binder服务的查询，返回被查询服务的引用。 ServiceManager进程也是通过Binder框架来提供服务的。这样就会才生鸡生蛋，蛋孵鸡的悖论了，作为Binder服务的提供者，它也需要使用某种方式让使用者获取到它的引用对象，然后再其他情况下，这个操作是由ServiceManagaer来提供查询服务的，这就互相冲突了。这边Binder架构使用一个非常暴力简单的方式解决这个问题。因为Binder引用对象的核心数据是一个实体对象的引用号，它是在驱动内部分配的一个值。所以Binder框架强制规定0代表了ServiceManager。 为什么需要ServiceManager? 理论上我们可以把查询的步骤放在Binder架构的核心–Binder驱动中来直接处理，那为什么还需要通过ServiceManager进程来作为中转呢?这就要提到android的安全机制了，在android系统中是不允许任意进程都能注册Binder服务的，虽然任意的进程都可以创建Binder服务，但是只有root和system用户可以不受限制的在ServiceManager中注册服务。当然普通用户ID的进程也是可以注册Binder服务的，但是在ServiceManager有张表会记录着可以注册Binder服务的进程的用户ID，以及进程能够注册的服务名称，ServiceManager是就是过这张表来控制普通进程的注册请求（5.0以后不再通过表来控制，而是使用SELinux来检查权限）。 3.3 服务端Binder服务分为：实名服务和匿名服务。它们从开发到使用并没有什么区别，唯一的区别就是实名服务可以通过ServiceManager查询到。Android的实名服务都是系统提供，比如我们后续要学习的：AMS,PKMS，WMS等。而我们平时我们在普通应用里面创建Binder服务都是匿名服务。 如果按上面说的匿名服务无法通过ServiceManager查询到，那么使用者是通过什么方式获取到它的引用对象呢？其实还是通过Binder。 匿名服务经常使用的场景：服务进程回调客户进程中的函数。下面是整个使用过程： 客户端和服务端通过binder连接上后，客户端将本进程创建的匿名服务的实体对象作为参数传递到服务端，binder驱动会在中间将实体对象转换成引用对象，这样服务进程就得到了客户进程创建的Binder服务的引用对象，然后就可以回调进程中的binder服务的函数了。 3.3.1 组件Service和匿名Binder服务3.4 客户端四.Binder的层次 服务类和接口类：位于framework层，为应用程序提供各种各样的服务，例如AMS,PKMS,WMS等 Binder核心类：Ibinder、BBinder、BpBinder,这是上层 服务类和接口类的基础 IPCThreadState：和驱动交换 驱动层 二三层可以可以合称为libbinder层","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"SystemServer服务","slug":"SystemServer服务","date":"2018-06-04T01:53:00.000Z","updated":"2018-06-06T01:04:38.215Z","comments":true,"path":"2018/06/04/SystemServer服务/","link":"","permalink":"http://yoursite.com/2018/06/04/SystemServer服务/","excerpt":"","text":"一.概述SystemServer是Android系统的核心服务，大部分服务都运行在这个进程中，它通过Zygote进程启动,在ZygoteInit类中的main方法通过startSystemServer方法（Zygote进程 2.3节）。在SystemServer中运行的服务有60多种，为了防止应用程序对系统造成破坏，android的应用程序没有权限直接访问设备的底层资源，只能通过SystemServer中的服务代理访问。 二.SystemServer 的创建过程如上节所说的，SystemServer服务是在Zygote进程中fork并初始化的，然后再调用SystemServer的main方法来启动系统的服务。所以下面我们分成两个部分分别介绍走一遍流程。 2.1 创建SystemServer进程首先我们来看 startSystemServer 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;//1.准备启动参数 long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = &#123; \"--setuid=1000\", //进程ID \"--setgid=1000\", //组ID \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", //设定了SystemServer的执行类 &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); //2.调用forkSystemServer fork出SystemServer进程 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //3.初始化SystemServer进程 handleSystemServerProcess(parsedArgs); &#125; return true; &#125; 2.1.1 fork SystemServer进程第一步是准备参数在代码中已经把重要的参数都注释出来了，我们重点关注第二步 fork 出 SystemServer 进程，首先我们跟踪进 Zygote 类的 forkSystemServer 方法。 123456789101112public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); // Enable tracing as soon as we enter the system_server. if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; 可以看到其实 forkSystemServer 方法相当的简单 只是调用了 native 方法 nativeForkSystemServer,跟踪到 jni 层的方法如下：路径：frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223242526static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; // 调用 ForkAndSpecializeCommon 方法来 frok 出子进程 pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; // The zygote process checks whether the child process has died or not. ALOGI(\"System server process %d has been created\", pid); gSystemServerPid = pid; // There is a slight window that the system server process has crashed // but it went unnoticed because we haven't published its pid yet. So // we recheck here just to make sure that all is well. int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env); //启动SystemServer失败，重启系统 &#125; &#125; return pid;&#125; 从上面的函数中我们看到，主要还是通过 ForkAndSpecializeCommon 方法来fork出子进程，这跟前面我们介绍 应用 通过Zygote类的forkAndSpecialize 方法（该方法最终也是调动了ForkAndSpecializeCommon来fork子进程）fork出子进程是一样的。只不过这边比较特殊的是，在fork后多了一步判断，如果fork失败则 Zygote进程会直接终止自己（注意这时候我们是在Zygote进程来准备fork出SystemServer进程）,Zygote进程终止后会自动重启，然后再走一遍这个流程。 在上一篇的Zygote进程 fork 应用程序的时候并没有深入的介绍 Zygote.forkAndSpecialize 的流程，这边我们结合 SystmServer进程的 fork 一起介绍，如上所说，这两个进程的fork最终都会调用到 ForkAndSpecializeCommon 方法，我们来看下这个方法的详细代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// Utility routine to fork zygote and specialize the child process.static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; //设置处理sigchld 信号的函数 SigChldHandler SetSigChldHandler();#ifdef ENABLE_SCHED_BOOST SetForkLoad(true);#endif sigset_t sigchld; sigemptyset(&amp;sigchld); sigaddset(&amp;sigchld, SIGCHLD); // Temporarily block SIGCHLD during forks. The SIGCHLD handler might // log, which would result in the logging FDs we close being reopened. // This would cause failures because the FDs are not whitelisted. // // Note that the zygote process is single threaded at this point. if (sigprocmask(SIG_BLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Close any logging related FDs before we start evaluating the list of // file descriptors. __android_log_close(); // If this is the first fork for this zygote, create the open FD table. // If it isn't, we just need to check whether the list of open files has // changed (and it shouldn't in the normal case). if (gOpenFdTable == NULL) &#123; gOpenFdTable = FileDescriptorTable::Create(); if (gOpenFdTable == NULL) &#123; RuntimeAbort(env, __LINE__, \"Unable to construct file descriptor table.\"); &#125; &#125; else if (!gOpenFdTable-&gt;Restat()) &#123; RuntimeAbort(env, __LINE__, \"Unable to restat file descriptor table.\"); &#125; pid_t pid = fork(); if (pid == 0) &#123; // The child process. gMallocLeakZygoteChild = 1; // Clean up any descriptors which must be closed immediately DetachDescriptors(env, fdsToClose); // Re-open all remaining open file descriptors so that they aren't shared // with the zygote across a fork. if (!gOpenFdTable-&gt;ReopenOrDetach()) &#123; RuntimeAbort(env, __LINE__, \"Unable to reopen whitelisted descriptors.\"); &#125; if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Keep capabilities across UID change, unless we're staying root. if (uid != 0) &#123; EnableKeepCapabilities(env); &#125; DropCapabilitiesBoundingSet(env); bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL) &amp;&amp; android::NativeBridgeAvailable(); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); use_native_bridge = android::NeedsNativeBridge(isa_string.c_str()); &#125; if (use_native_bridge &amp;&amp; dataDir == NULL) &#123; // dataDir should never be null if we need to use a native bridge. // In general, dataDir will never be null for normal applications. It can only happen in // special cases (for isolated processes which are not associated with any app). These are // launched by the framework and should not be emulated anyway. use_native_bridge = false; ALOGW(\"Native bridge will not be used because dataDir == NULL.\"); &#125; if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123; ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno)); if (errno == ENOTCONN || errno == EROFS) &#123; // When device is actively encrypting, we get ENOTCONN here // since FUSE was mounted before the framework restarted. // When encrypted device is booting, we get EROFS since // FUSE hasn't been created yet by init. // In either case, continue without external storage. &#125; else &#123; ALOGE(\"Cannot continue without emulated storage\"); RuntimeAbort(env); &#125; &#125; if (!is_system_server) &#123; int rc = createProcessGroup(uid, getpid()); if (rc != 0) &#123; if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc)); &#125; &#125; &#125; SetGids(env, javaGids); SetRLimits(env, javaRlimits); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); ScopedUtfChars data_dir(env, dataDir); android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str()); &#125; int rc = setresgid(gid, gid, gid); if (rc == -1) &#123; ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno)); RuntimeAbort(env); &#125; rc = setresuid(uid, uid, uid); if (rc == -1) &#123; ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno)); RuntimeAbort(env); &#125; if (NeedsNoRandomizeWorkaround()) &#123; // Work around ARM kernel ASLR lossage (http://b/5817320). int old_personality = personality(0xffffffff); int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE); if (new_personality == -1) &#123; ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno)); &#125; &#125; SetCapabilities(env, permittedCapabilities, effectiveCapabilities); SetSchedulerPolicy(env); const char* se_info_c_str = NULL; ScopedUtfChars* se_info = NULL; if (java_se_info != NULL) &#123; se_info = new ScopedUtfChars(env, java_se_info); se_info_c_str = se_info-&gt;c_str(); if (se_info_c_str == NULL) &#123; ALOGE(\"se_info_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; const char* se_name_c_str = NULL; ScopedUtfChars* se_name = NULL; if (java_se_name != NULL) &#123; se_name = new ScopedUtfChars(env, java_se_name); se_name_c_str = se_name-&gt;c_str(); if (se_name_c_str == NULL) &#123; ALOGE(\"se_name_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (rc == -1) &#123; ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid, is_system_server, se_info_c_str, se_name_c_str); RuntimeAbort(env); &#125; // Make it easier to debug audit logs by setting the main thread's name to the // nice name rather than \"app_process\". if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); &#125; delete se_info; delete se_name; UnsetSigChldHandler(); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server ? NULL : instructionSet); if (env-&gt;ExceptionCheck()) &#123; ALOGE(\"Error calling post fork hooks.\"); RuntimeAbort(env); &#125; &#125; else if (pid &gt; 0) &#123; // the parent process // We blocked SIGCHLD prior to a fork, we unblock it here. if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; &#125; return pid;&#125;&#125; // anonymous namespace 这边我们重点关注 SetSigChldHandler 函数的调用，这边设置了处理 sigchld 信号的函数 SigChldHandler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// This signal handler is for zygote mode, since the zygote must reap its childrenstatic void SigChldHandler(int /*signal_number*/) &#123; pid_t pid; int status; // It's necessary to save and restore the errno during this function. // Since errno is stored per thread, changing it here modifies the errno // on the thread on which this signal handler executes. If a signal occurs // between a call and an errno check, it's possible to get the errno set // here. // See b/23572286 for extra information. int saved_errno = errno;//调用 waitpid 来防止子进程变成僵尸 while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123; // Log process-death status that we care about. In general it is // not safe to call LOG(...) from a signal handler because of // possible reentrancy. However, we know a priori that the // current implementation of LOG() is safe to call from a SIGCHLD // handler in the zygote process. If the LOG() implementation // changes its locking strategy or its use of syscalls within the // lazy-init critical section, its use here may become unsafe. if (WIFEXITED(status)) &#123; if (WEXITSTATUS(status)) &#123; ALOGI(\"Process %d exited cleanly (%d)\", pid, WEXITSTATUS(status)); &#125; &#125; else if (WIFSIGNALED(status)) &#123; if (WTERMSIG(status) != SIGKILL) &#123; ALOGI(\"Process %d exited due to signal (%d)\", pid, WTERMSIG(status)); &#125; if (WCOREDUMP(status)) &#123; ALOGI(\"Process %d dumped core.\", pid); &#125; &#125; //如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote） // If the just-crashed process is the system_server, bring down zygote // so that it is restarted by init and system server will be restarted // from there. if (pid == gSystemServerPid) &#123; ALOGE(\"Exit zygote because system server (%d) has terminated\", pid); kill(getpid(), SIGKILL); &#125; &#125; // Note that we shouldn't consider ECHILD an error because // the secondary zygote might have no children left to wait for. if (pid &lt; 0 &amp;&amp; errno != ECHILD) &#123; ALOGW(\"Zygote SIGCHLD error in waitpid: %s\", strerror(errno)); &#125; errno = saved_errno;&#125; 这边我们重点关注 上面代码注释的那段，如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote），如果Zygote死亡那么导致的是INit进程会杀死所有的用户进程并重启Zygote。我们在调试系统代码的时候经常会杀死system_process进程来重启系统的原理就是这个。为什么是system_process进程而不是参数system_server ，这个我们在后面 2.2.1 会介绍到。 2.1.2 调用 handleSystemServerProcess 初始化 SystemServer 进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket();//设置 umask = 0077 // set umask to 0077 so new files and directories will default to owner-only permissions. Os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; //修改进程名 上面我们传进来的参数为 system_server Process.setArgV0(parsedArgs.niceName); &#125; final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); &#125;// invokeWith 参数基本为null if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; // If we have a non-null system server class path, we'll have to duplicate the // existing arguments and append the classpath to it. ART will handle the classpath // correctly when we exec a new process. if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; //通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */ &#125; 上面方法主要做了以下几件事 关闭从zygote继承的socket 设置SystemServer进程的umask为0077，这样SystemServer进程创建的文件的属性为0700，只有进程本身可以访问 修改进程的名称为参数 “system_server” invokeWith 参数基本为null,所以一般是通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 2.2 SystemServer 类main方法来执行初始化首先我们来查看 main 方法的源码 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 相当的简单,直接 new 一个 SystemServer 类的 实例同事执行了 run 方法，这里我们要重点解释下 SystemServer 并未继承自 Thread 类，这边调用 run 方法，只是刚好名字叫做 run 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 private void run() &#123; //如果时间不正确则调整系统时间 // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; Slog.w(TAG, \"System clock is before 1970; setting to 1970.\"); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; // If the system has \"persist.sys.language\" and friends set, replace them with // \"persist.sys.locale\". Note that the default locale at this point is calculated // using the \"-Duser.locale\" command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125; // Here we go! Slog.i(TAG, \"Entered the Android system server!\"); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());//设置当前的虚拟机 运行库 路径 // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) &#123; SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() &#123; @Override public void run() &#123; SamplingProfilerIntegration.writeSnapshot(\"system_server\", null); &#125; &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); &#125; // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit();//调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper();//装载 libandroid_servers.so // Initialize native services. System.loadLibrary(\"android_servers\"); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext();//创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);//启动全部的 java services // Start services. try &#123; startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, \"Enabled StrictMode for system server main thread.\"); &#125; // Loop forever. Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; run 方法主要做这些事情 如果时间不正确则调整系统时间 设置当前的虚拟机 运行库 路径:值为 属性 persist.sys.dalvik.vm.lib.2 的值 调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 装载 libandroid_servers.so,路径在 framework/base/services/jni 下 调用 createSystemContext 方法获取 Context 创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 启动全部的 java services 进入消息循环：Looper.loop() 2.2.1 createSystemContext 方法获取 Context123456 private void createSystemContext() &#123; ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext();//设置主题 mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); &#125; 12345678910111213public static ActivityThread systemMain() &#123; // The system process on low-memory devices do not get to use hardware // accelerated drawing, since this can add too much overhead to the // process. if (!ActivityManager.isHighEndGfx()) &#123; HardwareRenderer.disable(true); &#125; else &#123; HardwareRenderer.enableForegroundTrimming(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(true); return thread;&#125; 在 Zygote进程 篇的 3.5.3节中，当 zygote 进程fork应用进程，在最后启动应用的时候会调用 ActivityThread 类的 main 方法，跟这边的 systemMain方法相似的是这两个方法都 创建了 ActivityThread 对象（区别在于 普通应用 thread.attach(false); SystemServer则是 true）。ActivityThread 是应用程序的主线程类，那么为什么 SystemServer 需要创建这个对象呢？这是因为 SystemServer 不仅仅是一个后台进程，同时也是一个运行着组件的Service的进程，像一些系统对话框也是从这个进程弹出的，所以它也需要一个上下文环境（activityThread.getSystemContext()）。 上文我们说到SystemServer 调用 hread.attach 方法的参数为 true ，那么我们来看看 true分支下的流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125;); &#125; else &#123; //这边为 true 流程 也就是 SystemServer 进程执行的 //设置ddms中看到的应用名称 这也是为什么 我们上面说要重启系统 杀死system_process进程的原因 // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(\"system_process\", UserHandle.myUserId()); try &#123; //创建 Instrumentation 对象 mInstrumentation = new Instrumentation(); //创建 Context 对象 ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); //创建 应用的Application 对象 mInitialApplication = context.mPackageInfo.makeApplication(true, null); //调用 onCreate 生命周期 mInitialApplication.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate Application():\" + e.toString(), e); &#125; &#125; // add dropbox logging to libcore DropBox.setReporter(new DropBoxReporter()); ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources // immediately, because upon returning the view // hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) &#123; // This actually changed the resources! Tell // everyone about it. if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123; mPendingConfiguration = newConfig; sendMessage(H.CONFIGURATION_CHANGED, newConfig); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; &#125; @Override public void onTrimMemory(int level) &#123; &#125; &#125;); &#125; 从上面代码可以看出这是完全在模拟一个类似应用的环境。但是每一个上下文环境都需要一个 apk文件，那么这个文件从哪里来呢？这个就需要我们跟踪进 getSystemContext 方法了。 12345678public ContextImpl getSystemContext() &#123; synchronized (this) &#123; if (mSystemContext == null) &#123; mSystemContext = ContextImpl.createSystemContext(this); &#125; return mSystemContext; &#125;&#125; 12345678static ContextImpl createSystemContext(ActivityThread mainThread) &#123; LoadedApk packageInfo = new LoadedApk(mainThread); ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY); context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked()); return context;&#125; 123456789101112131415161718192021LoadedApk(ActivityThread activityThread) &#123; mActivityThread = activityThread; mApplicationInfo = new ApplicationInfo(); mApplicationInfo.packageName = \"android\"; mPackageName = \"android\"; mAppDir = null; mResDir = null; mSplitAppDirs = null; mSplitResDirs = null; mOverlayDirs = null; mSharedLibraries = null; mDataDir = null; mDataDirFile = null; mLibDir = null; mBaseClassLoader = null; mSecurityViolation = false; mIncludeCode = true; mRegisterPackage = false; mClassLoader = ClassLoader.getSystemClassLoader(); mResources = Resources.getSystem();&#125; 因为 framework-res.apk的包名就是 “android”，所以这边创建的Application对象代表的就是 framework-res.apk。","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"Zygote进程","slug":"Zygote进程","date":"2018-06-01T08:21:00.000Z","updated":"2018-06-06T01:04:38.221Z","comments":true,"path":"2018/06/01/Zygote进程/","link":"","permalink":"http://yoursite.com/2018/06/01/Zygote进程/","excerpt":"","text":"一.概述1.1 什么是ZygoteLinux的进程是通过系统调用fork产生的，fork出的子进程除了内核中的一些核心数据结构和父进程不同外，其余的内存映像都是和父进程共享的。当子进程需要去改写这些共享数据的内存时，操作系统才会为子进程分配一个新的内存页，并将老的页面数据复制到新的页面上后再进行修改操作（写时拷贝）。 fork出来的进程会继续执行系统调用exec。exec将用一个新的可执行文件的内容替换当前进程的代码段、数据段、堆和栈段。 fork+exec是Linux启动进程的标准做法，Init进程中启动的服务也是这样做的，Zygote进程就是这么被启动起来的。（ Init进程 2.2.3处） 那么Zygote是怎么做的呢？Zygote在创建应用程序的只执行了fork操作，没有去调用exec。 Zygote初始化时会创建虚拟机，同时把需要的系统类库和资源文件加载到内存中。Zygote fork出子进程后（系统会根据apk的类型来选择fork 32位还是64位的 Zygote），这个子进程也继承了能正常工作的虚拟机和各种系统资源。接下来子进程只需要加载APK中的字节码就可以运行了。这样就达到了减少启动时间的作用。 1.2 启动的时机上篇Init进程中我们知道Zygote进程是由Init进程启动的，那么到底是在什么时候启动的呢？我们现在追踪下源码。在Init进程的初始化过程中会解析init.rc文件，从文件中我们可以看出init.rc会根据ro.zygote属性来加载哪个文件，下面是我获取的公司的6.0系统的板子属性。 root@rk3399_stbvr:/ # getprop ro.zygotezygote64_32 123456import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.usb.configfs.rcimport /init.$&#123;ro.zygote&#125;.rcimport /init.trace.rc 现在我们来看看init.zygote64_32.rc文件的内容：1234567891011121314service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class core socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class core socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks 1.3 参数分析app_process 启动的参数格式是: app_process [虚拟机参数] 运行目录 参数[java类] 以上文rc文件32位启动为例：service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin –zygote –socket-name=zygote_secondary 虚拟机参数：以符号‘-’开头。例如：-Xzygote 运行目录：一般是在 /system/bin 参数：以符号“–”开头。参数“–zygote”表示要启动zygote进程。“–application”表示要以普通进程的方式执行java代码。 java类：将要执行的java类。必须要有一个静态方法main。使用参数“zygote”时不会执行这个类，而是固定执行ZygoteInit类。 二.Zygote的初始化2.1 app_process的main方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int main(int argc, char* const argv[])&#123; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123; // Older kernels don't understand PR_SET_NO_NEW_PRIVS and return // EINVAL. Don't die on such kernels. if (errno != EINVAL) &#123; LOG_ALWAYS_FATAL(\"PR_SET_NO_NEW_PRIVS failed: %s\", strerror(errno)); return 12; &#125; &#125; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++; // Everything up to '--' or first non '-' arg goes to the vm. // // The first argument after the VM args is the \"parent dir\", which // is currently unused. // // After the parent dir, we expect one or more the following internal // arguments : // // --zygote : Start in zygote mode // --start-system-server : Start the system server. // --application : Start in application (stand alone, non zygote) mode. // --nice-name : The nice name for this process. // // For non zygote starts, these arguments will be followed by // the main class name. All remaining arguments are passed to // the main method of this class. // // For zygote starts, all remaining arguments are passed to the zygote. // main function. // // Note that we must copy argument string values since we will rewrite the // entire argument block when we apply the nice name to argv0. int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //解析参数 ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. //执行非zygote模式 args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; //执行zygote模式 // We're in zygote mode. maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //将本进程的名字改成 “--nice-name”参数的指定的值，如果没指定则默认为ZYGOTE_NICE_NAME宏指定的值（可能是zygote或者是zygote64） if (!niceName.isEmpty()) &#123; //替换启动参数窜中的“app_process”为参数--nice-name指定的名称 runtime.setArgv0(niceName.string()); //用来改变进程名 set_process_name(niceName.string()); &#125; if (zygote) &#123; //参数带有--zygote 所以执行ZygoteInit类 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; //否则执行通过参数传进来的java类 runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 2.2 启动虚拟机 AndroidRuntime类负责启动虚拟机以及Java线程.AndroidRuntime类在一个进程中只有一个实例对象，保存在全局变量gCurRuntime中。 1234567891011121314151617AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength)&#123; SkGraphics::Init(); // There is also a global font cache, but its budget is specified by // SK_DEFAULT_FONT_CACHE_COUNT_LIMIT and SK_DEFAULT_FONT_CACHE_LIMIT. // Pre-allocate enough space to hold a fair number of options. mOptions.setCapacity(20); assert(gCurRuntime == NULL); // one per process //保存到全局变量中 gCurRuntime = this;&#125; 2.2.1 启动虚拟机在2.1的main函数的末尾我们执行了runtime的start函数来执行java类。在zygote进程执行java代码前，还需要初始化整个java运行环境。下面我们来追踪下start函数的执行过程 2.2.1.1 输出启动log12ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); 这个日志标志android系统的启动，因为以后的进程都是从zygote进程fork出来的，所以这个不会再执行start函数。所以如果日志中反复出现这段打印的话，并且进程ID为zygote，则说明系统正在不断的重启。 2.2.1.2 获取系统目录123456789const char* rootDir = getenv(\"ANDROID_ROOT\");if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1);&#125; 首先从环境变量ANDROID_ROOT中获取，如果环境变量没有设置则把系统目录设置为/system，然后检查/system目录是否存在，如果不存在zygote退出。系统目录是在Init进程中创建的。 2.2.1.3 启动虚拟机1234567/* start the virtual machine */JniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return;&#125; 2.2.1.4 调用虚函数onVmCreated1onVmCreated(env); 这边onVmCreated只是一个虚函数，在android系统中调用的其实是其子类 AppRuntime中重载的。代码如下 1234567891011121314151617181920212223242526272829 virtual void onVmCreated(JNIEnv* env) &#123;//如果是zygote进程的话，这时候mClassName是null的，所以执行到这边就结束了。 if (mClassName.isEmpty()) &#123; return; // Zygote. Nothing to do here. &#125; /* * This is a little awkward because the JNI FindClass call uses the * class loader associated with the native method we're executing in. * If called in onStarted (from RuntimeInit.finishInit because we're * launching \"am\", for example), FindClass would see that we're calling * from a boot class' native method, and so wouldn't look for the class * we're trying to look up in CLASSPATH. Unfortunately it needs to, * because the \"am\" classes are not boot classes. * * The easiest fix is to call FindClass here, early on before we start * executing boot class Java code and thereby deny ourselves access to * non-boot classes. */ char* slashClassName = toSlashClassName(mClassName.string()); mClass = env-&gt;FindClass(slashClassName); if (mClass == NULL) &#123; ALOGE(\"ERROR: could not find class '%s'\\n\", mClassName.string()); &#125; free(slashClassName); mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass)); &#125; 2.2.1.5 注册系统的JNI函数1234567/* * Register android functions. */if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return;&#125; 12345678910111213141516171819202122232425262728293031323334/* * Register android native functions with the VM. *//*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); /* * Every \"register\" function calls one or more things that return * a local reference (e.g. FindClass). Because we haven't really * started the VM yet, they're all getting stored in the base frame * and never released. Use Push/Pop to manage the storage. */ env-&gt;PushLocalFrame(200); //通过register_jni_procs函数将全局数组gRegJNI中的jni本地函数在虚拟机中注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); //createJavaThread(\"fubar\", quickTest, (void*) \"hello\"); return 0;&#125; 2.2.1.6 准备参数: 调用java类的main函数使用的12345678910111213141516/* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */jclass stringClass;jobjectArray strArray;jstring classNameStr;stringClass = env-&gt;FindClass(\"java/lang/String\");assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); 2.2.1.7 调用java类的main方法如果启动的是Zygote进程调用的java类是ZygoteInit类，否则的话是RuntimeInit。 1234567891011121314151617181920212223242526 /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //获取main方法的ID jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //通过id调用java类的main方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; 2.3 初始化工作—— ZygoteInit 类从这边起我们就从C++进入到了java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 public static void main(String argv[]) &#123; try &#123; RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; if (abiList == null) &#123; throw new RuntimeException(\"No ABI list supplied.\"); &#125;// 注册Zyogte的socket监听端口，用来接收启动应用程序的消息 3.1会详细分析 registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); //装在系统资源。包括系统预加载类、Framework资源和openGL的资源。//这样当应用程序被fork处理后，应用的进程内已经很包含了这些系统资源，大大节省应用的启动时间。//在 第四节 预加载系统类和资源中会详细介绍 preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) &#123; //启动 SystemServer进程 在中会详细介绍 startSystemServer(abiList, socketName); &#125; Log.i(TAG, \"Accepting command socket connections\");//进入监听和接收消息的循环 在3.3节会详细分析 runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; SystemServer服务 的启动也是在这边的startSystemServer()方法中调用的。# 三.Zygote启动应用程序# 3.1 注册zygote的socket在上面2.3 ZygoteInit的main方法中我们调用了 registerZygoteSocket 方法来创建一个本地socket，然后调用了runSelectLoop来进入等待监听socket连接的循环。下面我们先来查看 registerZygoteSocket 方法123456789101112131415161718192021222324 private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc;//ANDROID_SOCKET_PREFIX的值为“ANDROID_SOCKET_” final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //通过环境变量获取socket句柄 String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + \" unset or invalid\", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //生成本地服务的socket并保存在全局变量中。 sServerSocket = new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125; &#125; registerZygoteSocket通过环境变量获取到socket句柄，但是这个socket是在哪里创建的呢？回到 1.2 节，我们是否还记得 zygote的rc文件的zygote服务里面定义了这么一条命令 1socket zygote stream 660 root system Init进程会根据这个选项创建一个AF_UNIX的socket，并把这个句柄放在环境变量ANDROID_SOCKET_[zygote]（zygote这个是指选项的名称）中。根据句柄创建FileDescriptor对象，然后通过LocalServerSocket方法生成一个本地服务的socket,并保存在sServerSocket中。 3.2 请求启动应用android启动一个新的进程都是在AMS中完成的，不管是因为什么原因启动一个新的进程，最终都是AMS的startProcessLocked来实现的。代码如下： 12345678if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";//启动进程Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); “android.app.ActivityThread” 参数就是应用启动后执行的java类。 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 最终start方法调用了 startViaZygote 方法来启动应用。首先将应用程序的启动参数保存到argsForZygote列表中，然后调用 zygoteSendArgsAndGetResult 将应用程序进程的启动参数发送到zygote进程中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; //启动参数保存到argsForZygote列表中 ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123; argsForZygote.add(\"--enable-jni-logging\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123; argsForZygote.add(\"--enable-safemode\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123; argsForZygote.add(\"--enable-debugger\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123; argsForZygote.add(\"--enable-checkjni\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123; argsForZygote.add(\"--enable-jit\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123; argsForZygote.add(\"--generate-debug-info\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123; argsForZygote.add(\"--enable-assert\"); &#125; if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(\"--mount-external-read\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(\"--mount-external-write\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); //TODO optionally enable debuger //argsForZygote.add(\"--enable-debugger\"); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125;// openZygoteSocketIfNeeded创建通信的socket，然后zygoteSendArgsAndGetResult将参数列表发送到zygote进程中 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; 创建通信的socket12345678910111213141516171819202122232425262728private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 发送到zygote进程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; // Throw early if any of the arguments are malformed. This means we can // avoid writing a partial response to the zygote. int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); &#125; &#125; /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125; &#125; 3.3 处理启动应用的请求在2.3节中 我们知道在ZygoteInit的main方法中 会通过runSelectLoop开启无限循环来接收启动应用的请求 12345678910111213141516171819202122232425262728293031323334353637private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 这边通过i=0判断请求连接事件是否到来，如果到来了调用 acceptCommandPeer 来和客户端建立一个socket链接，然后把socket加入到监听数组中，来等待socket上命令的到来。 如果i&gt;0这时候表示socket上有数据到了。这时候直接调用 ZygoteConnection 类的 runOnce 方法，处理完断开连接，并清除scoket。 3.4 fork应用进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123;//通过 readArgumentList 方法从socket连接中读取参数行 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; /** the stderr of the most recent request, if avail */ PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123; newStderr = new PrintStream( new FileOutputStream(descriptors[2])); &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) &#123; return handleAbiListQuery(); &#125; if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123; throw new ZygoteSecurityException(\"Client may not specify capabilities: \" + \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) + \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities)); &#125;//检查客户端进程是否有权利指定进程的用户id 组id 和所属的组//如果 客户端是root进程则可以任意指定//如果客户端是system进程，只有在系统属性 ro.fatorytest值为1 或者2的时候可以指定//没有指定则继承客户端的值 applyUidSecurityPolicy(parsedArgs, peer); applyInvokeWithSecurityPolicy(parsedArgs, peer); applyDebuggerSystemProperty(parsedArgs); applyInvokeWithSystemProperty(parsedArgs); int[][] rlimits = null; if (parsedArgs.rlimits != null) &#123; rlimits = parsedArgs.rlimits.toArray(intArray2d); &#125; if (parsedArgs.invokeWith != null) &#123; FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC); childPipeFd = pipeFds[1]; serverPipeFd = pipeFds[0]; Os.fcntlInt(childPipeFd, F_SETFD, 0); &#125; /** * In order to avoid leaking descriptors to the Zygote child, * the native code must close the two Zygote socket descriptors * in the child process before it switches from Zygote-root to * the UID and privileges of the application being launched. * * In order to avoid \"bad file descriptor\" errors when the * two LocalSocket objects are closed, the Posix file * descriptors are released via a dup2() call which closes * the socket and substitutes an open descriptor to /dev/null. */ int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null;//fork子进程 最后的fork还在native层完成的 在SystemServer进程 2.1 节会详细介绍 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, \"Exception creating pipe\", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, \"Invalid zygote arguments\", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, \"Zygote security policy prevents request: \", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //pid=0 表示在子进程中，所以执行 handleChildProc 在 3.5 节详细展开 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; //这时候还在zygote进程中，所以调用 handleParentProc 继续处理 return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125; 3.5 子进程的初始化我们接着上面的流程继续分析 handleChildProc 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /** * By the time we get here, the native code has closed the two actual Zygote * socket connections, and substituted /dev/null in their place. The LocalSocket * objects still need to be closed properly. */ closeSocket(); ZygoteInit.closeServerSocket(); if (descriptors != null) &#123; try &#123; Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; newStderr = System.err; &#125; catch (ErrnoException ex) &#123; Log.e(TAG, \"Error reopening stdio\", ex); &#125; &#125; if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 在方法的最后会根据参数的不同选择初始化的方式invokeWith不为null的时候，将会通过调用exec的方式来启动app_process进程来执行java类。正常情况下还是调用RuntimeInit.zygoteInit来启动的 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.5.1 commonInit方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 private static final void commonInit() &#123; if (DEBUG) Slog.d(TAG, \"Entered RuntimeInit!\");//设置进程的UncaughtException的处理方法//这边默认的实现是打印出错误堆栈然后退出应用//应用可以调用 Thread.setDefaultUncaughtExceptionHandler 来设置自定义的处理方式//想腾讯的bug平台的实现就是基于这点 /* set default handler; this applies to all threads in the VM */ Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());//设置时区 /* * Install a TimezoneGetter subclass for ZoneInfo.db */ TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null);//重置android系统的log系统 /* * Sets handler for java.util.logging to use Android log facilities. * The odd \"new instance-and-then-throw-away\" is a mirror of how * the \"java.util.logging.config.class\" system property works. We * can't use the system property here since the logger has almost * certainly already been initialized. */ LogManager.getLogManager().reset(); new AndroidConfig();//设置 http.agent 属性 /* * Sets the default HTTP User-Agent used by HttpURLConnection. */ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); /* * Wire socket tagging to traffic stats. */ NetworkManagementSocketTagger.install(); /* * If we're running in an emulator launched with \"-trace\", put the * VM into emulator trace profiling mode so that the user can hit * F9/F10 at any time to capture traces. This has performance * consequences, so it's not something you want to do always. */ String trace = SystemProperties.get(\"ro.kernel.android.tracing\"); if (trace.equals(\"1\")) &#123; Slog.i(TAG, \"NOTE: emulator trace profiling enabled\"); Debug.enableEmulatorTraceOutput(); &#125; initialized = true; &#125; 3.5.2 nativeZygoteInit 方法3.5.3 applicationInit 方法12345678910111213141516171819202122232425262728293031 private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true);//设置虚拟机参数 // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);//这边会真正调用到 ActivityThread.main 方法 // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125; 12345678910111213141516171819202122232425262728293031323334353637private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 四.预加载系统类和资源在 2.3 节 ZygoteInit类的main方法中会调用 preload 方法来可进行系统类和资源的预加载。 123456789101112static void preload() &#123; Log.d(TAG, \"begin preload\"); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, \"end preload\");&#125;","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"Init进程","slug":"Init进程","date":"2018-05-31T06:32:00.000Z","updated":"2018-06-06T01:04:38.205Z","comments":true,"path":"2018/05/31/Init进程/","link":"","permalink":"http://yoursite.com/2018/05/31/Init进程/","excerpt":"","text":"一.概述Init进程是内核启动后创建的第一个用户进程，地位非常的重要。在Init初始化的过程中会启动很多重要的守护进程，当然Init本身也是一个守护进程。 在介绍Init进程前先简单的介绍下Android的启动过程 1.1 bootloader引导1.1.1 什么是bootloader引导当我们按下手机的电源键时，最先运行的就是bootloader。bootloader主要作用就是初始化基本的硬件设备（CPU,内存，Flash等）并且通过建立内存空间的映射，为装载linux内核准备好适合的环境。内核装载完毕，bootloader将会从内存中清除。 1.1.2 Fastboot模式Fastboot是Android设计的一套通过usb来更新手机分区映像的协议。 1.1.3 Recovery模式Android特有的升级系统。利用该模式可以进行恢复出厂设置，执行ota、补丁和固件升级。进入到Recovery模式实际上就是进入了一个文字模式的Linux 1.2 装载和启动Linux内核Android的boot.img存放的就是Linux的内核和一个根文件系统。上面的bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成整个后装载整个根文件系统，最后启动Init进程 什么是根文件系统？根文件系统是Linux系统一种特殊的文件系统，Android是基于Linux的，当然也有根文件系统。android的根文件系统是基于busybox实现的。 1.3 启动android系统android系统的启动可以更加详细的分为以下几个阶段 1.3.1 启动Init进程Init进程是系统启动的第一个进程。在Init的启动过程中会解析Linux的配置脚本init.rc文件、加载android的文件系统、创建系统目录、初始化属性系统、启动android系统重要的守护进程（USB守护进程、adb守护进程、vold守护进程、rild守护进程）。 Init作为守护进程的作用：修改属性请求、重启崩溃的进程等操作。 1.3.2 启动ServiceManager由init启动。管理binder服务，负责binder的注册和查找。 1.3.3 启动Zygote进程Init进程初始化结束时会启动Zygote进程。Zygote进程负责fork应用进程。是所有应用进程的父进程。 Zygote进程初始化时会创建Dalivik虚拟机、预装载系统的资源文件和Java类。从Zygote中fork的进程都会继承和共享这些预加载的资源。 启动结束后，转为守护进程来响应应用建立的请求。 1.3.4 启动SystemServiceSystemService是Zygote进程fork的第一个进程，也是android系统的核心进程。在SystemService中运行这android大部分的binder服务。 首先会启动SensorService,接着是ActivityManagerService（AMS）,WindowsManagerService（WMS）,PackagerManagerService(PKMS)等服务。 1.3.5 启动LauncherSystemServer加载完所有的服务后，最后会调用AMS中的systemReady()方法。在这个方法的执行过程中会发出Intent(android.intent.category.Home).凡是响应这个Intent的应用都会启动起来（这个流程我们到时候在AMS的分析部分会重点追踪整个过程），这边要跟开机广播区别开来。 二.Init进程的初始化过程Init进程的源码位于\\system\\core\\init\\下。程序的入口函数main()位于init.cpp中。 2.1 main函数的流程2.1.1 选择启动程序因为Init和ueventd和watchdogd守护进程的代码存在大量的代码重合，所以直接合并到一个文件中，通过参数来判断执行那个守护进程。 1234567if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125; 2.1.2 设置进程创建的文件的属性缺省情况下一个进程创建的文件属性是022，使用umask可以设置文件属性的掩码。参数为0表示掩码为0777。 12// Clear the umask.umask(0); 2.1.3 创建目录和挂载文件系统12345678910111213//确保只执行一次bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; tmpfs是一种基于内存的文件系统，mount后就可以使用。tmpfs文件系统下的所有文件都存放在内存中，访问速度快，但是关机后会消失，适合用来存放临时性的文件。而且tmpfs文件系统的大小是动态变化的，一开始很小，随着文件的增多会随之变大。从上面的代码我们可以看到Android系统将tmpfs文件系统挂载到/dev目录下，而这个目录是用来保存系统创造的设备节点，正好符合tmpfs的特点。 devpts是虚拟终端文件系统，通常mount在目录/dev/pts下。 2.1.4 初始化log系统1234567891011//将标准输入、输出、错误重定向到空设备文件/dev/null下，这是守护进程常用的手段 open_devnull_stdio();//创建设备节点/dev/kmsg,这样init进程就可以使用kernel的log系统，之所以是用使用kernel的log系统是因为这时候android层的log系统还没有启动起来 klog_init();//设置log级别 klog_set_level(KLOG_NOTICE_LEVEL);//打印init进程开始启动的日志 NOTICE(\"init%s started!\\n\", is_first_stage ? \"\" : \" second stage\"); 日志输出级别的宏定义如下 KLOG_ERROR_LEVEL 3 KLOG_WARNING_LEVEL 4 KLOG_NOTICE_LEVEL 5 KLOG_INFO_LEVEL 6 KLOG_DEBUG_LEVEL 7 KLOG_DEFAULT_LEVEL 3 //默认为3当我们设置的级别低于5的时候会输出到 kernel log 中 2.1.5 初始化属性系统123456789101112131415161718 if (!is_first_stage) &#123;//在/dev下创建一个设备表示正在初始化中，当初始化完成则移除// Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));//创建一个共享区域来存储属性值 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt();//解析kernel的启动参数 process_kernel_cmdline(); // Propogate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; 2.1.6 初始化SELinux内核SELinux内核是android4.3开始引入的。在后面的解析系列中会重点解析这块。1234567891011121314151617181920212223242526272829303132// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.INFO(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; 2.1.7 初始化子进程退出的信号处理过程1signal_handler_init(); 2.1.8 设置系统属性的默认值1property_load_boot_defaults(); 上面的函数会从设备的根目录下的default.prop文件(路径:/default.prop)的属性值读取设置到属性系统中。 下面是截取的nexu5x 6.0系统模拟器下的文件值1234567891011121314151617181920## ADDITIONAL_DEFAULT_PROPERTIES#ro.secure=1ro.allow.mock.location=0ro.debuggable=1ro.zygote=zygote32dalvik.vm.image-dex2oat-Xms=64mdalvik.vm.image-dex2oat-Xmx=64mdalvik.vm.dex2oat-Xms=64mdalvik.vm.dex2oat-Xmx=512mro.dalvik.vm.native.bridge=0debug.atrace.tags.enableflags=0## BOOTIMAGE_BUILD_PROPERTIES#ro.bootimage.build.date=Wed Dec 13 00:51:01 UTC 2017ro.bootimage.build.date.utc=1513126261ro.bootimage.build.fingerprint=Android/sdk_google_phone_x86/generic_x86:6.0/MASTER/4499259:userdebug/test-keyspersist.sys.usb.config=adb 2.1.9 启动属性服务（sockect）读取相应文件的属性，下文5.3中有介绍。1start_property_service(); 2.1.10 解析init.rc文件解析完成后的结果是将init文件中的Server项和Action项分别加入到内部Service列表:service_list 和Action列表:action_list解析的过程会在下面的详细的分析 1init_parse_config_file(\"/init.rc\"); 2.1.11 初始化执行列表action_queue1234567891011121314151617181920212223242526272829303132333435 //将rc文件中触发器为early-init的action添加到执行列表action_for_each_trigger(\"early-init\", action_add_queue_tail);//queue_builtin_action 作用就是将一个函数和一个名称生成action并插入到执行列表 // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...//等待冷插拔设备初始化完成 queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. //从硬件RNG的设备文件/dev/hw_randow中读取512字节并写到Linux RNGd的设备文件/dev/urandom中（这块因为水平有限，还未知道具体作用）queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//初始化组合键监听模块 queue_builtin_action(keychord_init_action, \"keychord_init\");//在屏幕上显示Android字样的Logo queue_builtin_action(console_init_action, \"console_init\"); //将rc文件中触发器为init的action添加到执行列表 // Trigger all the boot actions to get us started. action_for_each_trigger(\"init\", action_add_queue_tail); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//当处于充电模式，则charger加入执行队列；否则late-init加入队列。 // Don't mount filesystems or start core system services in charger mode. char bootmode[PROP_VALUE_MAX]; if (property_get(\"ro.bootmode\", bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, \"charger\") == 0) &#123; action_for_each_trigger(\"charger\", action_add_queue_tail); &#125; else &#123; action_for_each_trigger(\"late-init\", action_add_queue_tail); &#125;//检查Action列表中通过修改属性来触发的Action，查看相关的属性是否已经设置了，如果已经设置则将该action加入到执行列表 // Run all property triggers based on current state of the properties. queue_builtin_action(queue_property_triggers_action, \"queue_property_triggers\"); 2.1.12 无限循环执行123456789101112131415161718192021222324252627while (true) &#123; if (!waiting_for_exec) &#123; execute_one_command(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (!action_queue_empty() || cur_action) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; 2.2 启动Service进程上面最后无限循环的过程中 restart_processes 函数会检查service_list中所有服务，对于带有SVC_RESTARTING标志的服务，将服务作为参数调用 restart_service_if_needed 1234567891011121314static void restart_service_if_needed(struct service *svc) &#123; time_t next_start_time = svc-&gt;time_started + 5; if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); service_start(svc, NULL); return; &#125; if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; 由上面代码可以看出最后调用了service_start方法，下面我们来分析这个方法。 2.2.1 重置Service结构中的标志和可执行判断12345678910111213141516171819202122232425262728293031323334353637 // Starting a service removes it from the disabled or reset state and // immediately takes it out of the restarting state if it was in there.//这四个表示都是有启动相关的所以直接去掉 svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START)); svc-&gt;time_started = 0;//如果已经在启动了则不需要再执行 // Running processes require no additional work --- if they're in the // process of exiting, we've ensured that they will immediately restart // on exit, unless they are ONESHOT. if (svc-&gt;flags &amp; SVC_RUNNING) &#123; return; &#125;//如果服务需要控制台，但是控制台没有启动则退出 bool needs_console = (svc-&gt;flags &amp; SVC_CONSOLE); if (needs_console &amp;&amp; !have_console) &#123; ERROR(\"service '%s' requires console\\n\", svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务的二进制文件是否存在 struct stat s; if (stat(svc-&gt;args[0], &amp;s) != 0) &#123; ERROR(\"cannot find '%s', disabling '%s'\\n\", svc-&gt;args[0], svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务是否有SVC_ONESHOT参数 if ((!(svc-&gt;flags &amp; SVC_ONESHOT)) &amp;&amp; dynamic_args) &#123; ERROR(\"service '%s' must be one-shot to use dynamic args, disabling\\n\", svc-&gt;args[0]); svc-&gt;flags |= SVC_DISABLED; return; &#125; 2.2.2 设置安全上下文关于安全机制在后续的文章中分析 12345678910111213141516171819202122232425262728293031323334353637char* scon = NULL;if (is_selinux_enabled() &gt; 0) &#123; if (svc-&gt;seclabel) &#123; scon = strdup(svc-&gt;seclabel); if (!scon) &#123; ERROR(\"Out of memory while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125; else &#123; char *mycon = NULL, *fcon = NULL; INFO(\"computing context for service '%s'\\n\", svc-&gt;args[0]); int rc = getcon(&amp;mycon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; rc = getfilecon(svc-&gt;args[0], &amp;fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); freecon(mycon); return; &#125; rc = security_compute_create(mycon, fcon, string_to_security_class(\"process\"), &amp;scon); if (rc == 0 &amp;&amp; !strcmp(scon, mycon)) &#123; ERROR(\"Warning! Service %s needs a SELinux domain defined; please fix!\\n\", svc-&gt;name); &#125; freecon(mycon); freecon(fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125;&#125; 2.2.3 fork子进程,exec123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 //首先打印 服务启动日志NOTICE(\"Starting service '%s'...\\n\", svc-&gt;name); //fork进程pid_t pid = fork();if (pid == 0) &#123; struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; umask(077); //准备环境变量 if (properties_initialized()) &#123; get_property_workspace(&amp;fd, &amp;sz); snprintf(tmp, sizeof(tmp), \"%d,%d\", dup(fd), sz); add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp); &#125; for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next) add_environment(ei-&gt;name, ei-&gt;value); //如果服务选项中有socket选项。这时候就开始创建参数中定义的socket。 for (si = svc-&gt;sockets; si; si = si-&gt;next) &#123; int socket_type = ( !strcmp(si-&gt;type, \"stream\") ? SOCK_STREAM : (!strcmp(si-&gt;type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET)); int s = create_socket(si-&gt;name, socket_type, si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon); if (s &gt;= 0) &#123; publish_socket(si-&gt;name, s); &#125; &#125; freecon(scon); scon = NULL; if (svc-&gt;writepid_files_) &#123; std::string pid_str = android::base::StringPrintf(\"%d\", pid); for (auto&amp; file : *svc-&gt;writepid_files_) &#123; if (!android::base::WriteStringToFile(pid_str, file)) &#123; ERROR(\"couldn't write %s to %s: %s\\n\", pid_str.c_str(), file.c_str(), strerror(errno)); &#125; &#125; &#125; if (svc-&gt;ioprio_class != IoSchedClass_NONE) &#123; if (android_set_ioprio(getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri)) &#123; ERROR(\"Failed to set pid %d ioprio = %d,%d: %s\\n\", getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri, strerror(errno)); &#125; &#125; //处理标准输入 标准输出 标准错误3个文件描述符 if (needs_console) &#123; setsid(); open_console(); &#125; else &#123; zap_stdio(); &#125; //这边明显不执行 if (false) &#123; for (size_t n = 0; svc-&gt;args[n]; n++) &#123; INFO(\"args[%zu] = '%s'\\n\", n, svc-&gt;args[n]); &#125; for (size_t n = 0; ENV[n]; n++) &#123; INFO(\"env[%zu] = '%s'\\n\", n, ENV[n]); &#125; &#125; setpgid(0, getpid()); // As requested, set our gid, supplemental gids, and uid. if (svc-&gt;gid) &#123; if (setgid(svc-&gt;gid) != 0) &#123; ERROR(\"setgid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;nr_supp_gids) &#123; if (setgroups(svc-&gt;nr_supp_gids, svc-&gt;supp_gids) != 0) &#123; ERROR(\"setgroups failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;uid) &#123; if (setuid(svc-&gt;uid) != 0) &#123; ERROR(\"setuid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;seclabel) &#123; if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) &#123; ERROR(\"cannot setexeccon('%s'): %s\\n\", svc-&gt;seclabel, strerror(errno)); _exit(127); &#125; &#125; //执行exec if (!dynamic_args) &#123; if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", svc-&gt;args[0], strerror(errno)); &#125; &#125; else &#123; char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc-&gt;nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; /* Copy the static arguments */ memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *))); while((bword = strsep(&amp;next, \" \"))) &#123; arg_ptrs[arg_idx++] = bword; if (arg_idx == INIT_PARSER_MAXARGS) break; &#125; arg_ptrs[arg_idx] = NULL; execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV); &#125; _exit(127);&#125; 三. 解析启动脚本init.rc3.1 init.rc文件格式init.rc文件是以块为单位，主要分为两类：一是行为:action,以on开头;二是服务:service，以service开头。注释以#开头。无论是action还是service的执行顺序都不是以文件中的编排顺序执行的，执行与否和是否执行都是Init进程中决定的。 3.1.1 action在on后面紧跟的字符串是action的触发器，触发器后面的是命令列表，每一行都是一个命令。可以通过 trigger 触发器字符串（trigger late-init） 来触发。 触发器几种类别 on early-init; 在初始化早期阶段触发； on init; 在初始化阶段触发； on late-init; 在初始化晚期阶段触发； on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举； on property:=: 当属性值满足条件时触发； 123456789101112on property:sys.boot_from_charger_mode=1 class_stop charger trigger late-init# Load properties from /system/ + /factory after fs mount.on load_system_props_action load_system_propson load_persist_props_action load_persist_props start logd start logd-reinit 3.1.2 service在service后面是服务的名称，我们可以使用“start”命令加服务名称来启动一个服务（start logd）。名称后面的则是执行文件路径和执行参数。然后下面的行称为选项，每一行都是一个选项。例如class表示服务的类别，我们可以通过class_start来一次性启动一组服务。12345678910111213141516171819202122232425262728293031service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0service logd /system/bin/logd class core socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram 0222 logd logd group root system writepid /dev/cpuset/system-background/tasksservice logd-reinit /system/bin/logd --reinit oneshot writepid /dev/cpuset/system-background/tasks disabledservice healthd /sbin/healthd class core critical seclabel u:r:healthd:s0 group root systemservice console /system/bin/sh class core console disabled user shell group shell log seclabel u:r:shell:s0 3.1.3 Options 选项选项是service的修订项，它决定了服务何时运行以及怎么运行。 disabled: 表示不能通过触发器来触发，只能根据start service名开启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket，并把文件描述符传递给要启动的进程。 critical:这是一个关键服务，如果在4分钟内重启启动4次，则系统会重启并进入Recovery模式。 3.1.4 Commands 命令 class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务； start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过； stop &lt;service_name&gt;： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink &lt;sym_link&gt;： 创建连接到的&lt;sym_link&gt;符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 commands的命令远不止上面这些，这里只是列出一些常用的命令。 3.2 脚本文件解析过程下面我们来追踪下脚本文件的解析过程 源码所在文件路径如下\\system\\core\\init\\init_parser.cpp 首先从入口函数开始 123456789101112131415int init_parse_config_file(const char* path) &#123; INFO(\"Parsing %s...\\n\", path); Timer t; std::string data; if (!read_file(path, &amp;data)) &#123; return -1; &#125; data.push_back('\\n'); // TODO: fix parse_config. parse_config(path, data); dump_parser_state(); NOTICE(\"(Parsing %s took %.2fs.)\\n\", path, t.duration()); return 0;&#125; 从上面的函数可以看出来，首先通过read_file将文件的内容读到内存中，然后再通过parse_config函数进行解析。下面我们继续来追踪parse_config的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void parse_config(const char *fn, const std::string&amp; data)&#123; struct listnode import_list; struct listnode *node; char *args[INIT_PARSER_MAXARGS]; int nargs = 0; parse_state state; state.filename = fn; state.line = 0; state.ptr = strdup(data.c_str()); // TODO: fix this code! state.nexttoken = 0; state.parse_line = parse_line_no_op; list_init(&amp;import_list); state.priv = &amp;import_list; for (;;) &#123; switch (next_token(&amp;state)) &#123; //如果是结束标识符，则跳转到下面的parser_done位置 case T_EOF: state.parse_line(&amp;state, 0, 0); goto parser_done; //行结束符 case T_NEWLINE: state.line++; if (nargs) &#123; int kw = lookup_keyword(args[0]); //判断是否是section：关键字 on service import if (kw_is(kw, SECTION)) &#123; state.parse_line(&amp;state, 0, 0); //具体处理见 3.2.1 parse_new_section(&amp;state, kw, nargs, args); &#125; else &#123; //当作当前section所属行处理 state.parse_line(&amp;state, nargs, args); &#125; nargs = 0; &#125; break; //单词结束符 则先放入到数组中 case T_TEXT: if (nargs &lt; INIT_PARSER_MAXARGS) &#123; args[nargs++] = state.text; &#125; break; &#125; &#125;parser_done: list_for_each(node, &amp;import_list) &#123; struct import *import = node_to_item(node, struct import, list); int ret; ret = init_parse_config_file(import-&gt;filename); if (ret) ERROR(\"could not import file '%s' from '%s'\\n\", import-&gt;filename, fn); &#125;&#125; parse_new_section方法追踪 1234567891011121314151617181920212223242526static void parse_new_section(struct parse_state *state, int kw, int nargs, char **args)&#123; printf(\"[ %s %s ]\\n\", args[0], nargs &gt; 1 ? args[1] : \"\"); switch(kw) &#123; case K_service: state-&gt;context = parse_service(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_service; return; &#125; break; case K_on: state-&gt;context = parse_action(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_action; return; &#125; break; case K_import: parse_import(state, nargs, args); break; &#125; state-&gt;parse_line = parse_line_no_op;&#125; 由上面的函数可以看出，该方法通过传入的参数kw来决定用什么方法来处理： on关键字：parse_action service关键字：parse_service import关键字：parse_action 然后我们可以看出上面对结构体state的parse_line字段分别进行赋值了方法地址,该方法用来解析命令行。 on关键字：parse_line_action service关键字：parse_line_service 3.3 执行action3.2的解析过程只是将init.rc中的action和service添加到各自的列表中。真正将它们添加到执行列表的还是在init进程中处理的。上文2.1.11 中在init的初始化过程通过action_for_each_trigger将action添加到action_queue中。 1234567891011121314151617void action_for_each_trigger(const char *trigger, void (*func)(struct action *act))&#123; struct listnode *node, *node2; struct action *act; struct trigger *cur_trigger; list_for_each(node, &amp;action_list) &#123; act = node_to_item(node, struct action, alist); list_for_each(node2, &amp;act-&gt;triggers) &#123; cur_trigger = node_to_item(node2, struct trigger, nlist); if (!strcmp(cur_trigger-&gt;name, trigger)) &#123; func(act); &#125; &#125; &#125;&#125; 四.Init进程对信号的处理4.1 僵尸进程当一个进程退出exit()时，会向它的父进程发送一个SIGCHLD信号。父进程收到该信号后，会释放分配给该子进程的系统资源；并且父进程需要调用wait()或waitpid()等待子进程结束。 如果父进程没有做这种处理，且父进程初始化时也没有调用signal(SIGCHLD, SIG_IGN)来显示忽略对SIGCHLD的处理，这时子进程将一直保持当前的退出状态，不会完全退出。这样的子进程不能被调度，所做的只是在进程列表中占据一个位置，保存了该进程的PID、终止状态、CPU使用时间等信息；我们将这种进程称为“Zombie”进程，即僵尸进程。 android中查看僵尸进程的方法是通过 adb shell ps来查看的，僵尸进程的的进程状态为“Z”。 由于僵尸进程仍会在进程列表中占据一个位置，而Linux所支持的最大进程数量是有限的；超过这个界限值后，我们就无法创建进程。所以，我们有必要清理那些僵尸进程，以保证系统的正常运作。 4.2 处理过程待补充 五. 属性系统5.1 属性系统介绍android的属性用来保存系统设置和进程间传递一些信息。每个属性由属性名称和属性值组成，名称通常以“.”分割,这些名称的前缀有特殊的含义，不能随便改动。属性值只能是字符串。 对于进程来说，读取属性值是没有限制的，任何进程都可以读取属性值。但是写属性值只能通过init进程进行，而且init进程还会检查请求的进程是否具有该权限（5.0以后只在）。当属性值修改成功后，init进程会init.rc中是否有跟该属性修改值相匹配的“触发器”。如果有则执行触发器下的命令。 前缀分类 “ro.”：表示只读属性，一旦设置则不能改变。 “persist”:表示属性值会被写入目录/data/property下与属性同名的文件中。下次开机init进程会从中读取值。所以这边设置的值是永久生效的。 “ctl”:表示控制信息，用来执行一些命令：ctl.start、ctl.stop、ctl.restart setprop ctl.start bootanim：查看开机动画 setprop ctl.stop bootanim：关闭开机动画 setprop ctl.start pre-recovery：进入recovery模式 5.2 创建属性系统的共享空间在上面Init进程的初始化函数中我们调用了property_init函数为属性系统创建了一块共享内存区域。这块区域只能由init进程进行写入，读则不限制。 123456789101112131415161718192021void property_init() &#123; //防止多次初始化 if (property_area_initialized) &#123; return; &#125; property_area_initialized = true; //创建和初始化属性的共享内存空间，这块内存空间由/dev/__properties__ 设备创建,这块空间的文件描述符保存在 //static workspace pa_workspace; 中，最后在service_start的时候保存到环境变量中 if (__system_property_area_init()) &#123; return; &#125; pa_workspace.size = 0; pa_workspace.fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC); if (pa_workspace.fd == -1) &#123; ERROR(\"Failed to open %s: %s\\n\", PROP_FILENAME, strerror(errno)); return; &#125;&#125; 5.3 初始化属性系统的值通过从以下文件中读取值进行初始化 /system/build.prop：定了系统初始和永久的一些属性/data/local.prop：这个则需要和ro.debuggable配合使用，如果这个值为1，那么从该文件中读取值覆盖系统缺省的属性值，之所有有这个设计是为了方便开发人员调试，因为/system/build.prop 是在根目录下的。/data/property：该目录下的文件读取出来写入到属性值中。/default.prop: Init进程初始化过程中调用property_load_boot_defaults函数读取的 源码地址 本文源码基于android6.0system\\core\\init\\init.cppsystem\\core\\init\\init_parser.cppsystem\\core\\init\\signal_handler.cppsystem\\core\\init\\property_service.cpp","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"}],"tags":[]},{"title":"开机应用扫描流程","slug":"android6.0/PKMS/开机应用扫描流程","date":"2018-05-30T15:38:00.000Z","updated":"2018-05-31T00:52:32.308Z","comments":true,"path":"2018/05/30/android6.0/PKMS/开机应用扫描流程/","link":"","permalink":"http://yoursite.com/2018/05/30/android6.0/PKMS/开机应用扫描流程/","excerpt":"","text":"","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"PackageManagerService","slug":"android6-0/PackageManagerService","permalink":"http://yoursite.com/categories/android6-0/PackageManagerService/"}],"tags":[]},{"title":"动态更改Launch应用","slug":"工作问题/rk/动态更改Launch应用","date":"2018-05-29T15:45:53.000Z","updated":"2018-05-30T01:43:46.249Z","comments":true,"path":"2018/05/29/工作问题/rk/动态更改Launch应用/","link":"","permalink":"http://yoursite.com/2018/05/29/工作问题/rk/动态更改Launch应用/","excerpt":"","text":"","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"源码导航","slug":"android6.0/总览","date":"2018-05-29T05:37:00.000Z","updated":"2018-06-06T01:04:38.230Z","comments":true,"path":"2018/05/29/android6.0/总览/","link":"","permalink":"http://yoursite.com/2018/05/29/android6.0/总览/","excerpt":"","text":"一.引言Android系统非常庞大、错综复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连通系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而融为一体。 限于本人目前的只是水平,本系列的源码分析基本限于framework层的java代码。目前，网上有大量的android系统源码分析的书籍和博客，其实很不多优秀的文章。那为什么要再写一个自己的blog呢？这是因为android源码分析是个工程量非常巨大的事，在学些的过程中很容易迷失在源码的森林中，经常会出现看完一个模块，过一段时间就忘记的情况，所以很有必要将自己看的过程记录下来，同时也加深自己的理解。 首先说明本系列的源码分析是基于android6.0的源码，主要以事件为驱动来分析源码，比如我们我们在分析PKMS（PackageManagerService）服务的时候我们会从开机扫描过程，应用的安装过程等事件的流程进行分析解读。 二.Binder机制 Binder 开篇 Binder 开篇 三.Android系统启动系列 Init进程 Init进程 Zygote进程 Zygote进程 SystemServer进程 SystemServer服务 四.PackageManagerService 开机应用扫描流程 应用安装流程 五.ActivityManagerService 开机广播流程 Activity启动流程 Service启动流程 registerReceiver流程 sendBroadcast流程 六.WindowManagerService七.致谢在blog的编写过程中会大量的引用平时看的书籍和前辈优秀的blog,在这边会贴出引用的书籍和blog地址！","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"导读","slug":"android6-0/导读","permalink":"http://yoursite.com/categories/android6-0/导读/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"}]}]}