{"meta":{"title":"道墟","subtitle":"初九，潜龙勿用","description":null,"author":"道墟","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-29T15:28:54.000Z","updated":"2018-05-30T01:43:46.253Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2018-05-29T15:29:50.000Z","updated":"2018-05-30T01:43:46.257Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-30T03:44:46.000Z","updated":"2018-05-30T03:45:39.389Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SystemServer服务","slug":"SystemServer服务","date":"2018-06-04T01:53:03.000Z","updated":"2018-06-05T01:10:34.817Z","comments":true,"path":"2018/06/04/SystemServer服务/","link":"","permalink":"http://yoursite.com/2018/06/04/SystemServer服务/","excerpt":"","text":"一.概述SystemServer是Android系统的核心服务，大部分服务都运行在这个进程中，它通过Zygote进程启动,在ZygoteInit类中的main方法通过startSystemServer方法（ 2.3节）。在SystemServer中运行的服务有60多种，为了防止应用程序对系统造成破坏，android的应用程序没有权限直接访问设备的底层资源，只能通过SystemServer中的服务代理访问。 二.SystemServer 的创建过程如上节所说的，SystemServer服务是在Zygote进程中fork并初始化的，然后再调用SystemServer的main方法来启动系统的服务。所以下面我们分成两个部分分别介绍走一遍流程。 2.1 创建SystemServer进程首先我们来看 startSystemServer 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123;//1.准备启动参数 long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = &#123; \"--setuid=1000\", //进程ID \"--setgid=1000\", //组ID \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", //设定了SystemServer的执行类 &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); //2.调用forkSystemServer fork出SystemServer进程 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //3.初始化SystemServer进程 handleSystemServerProcess(parsedArgs); &#125; return true; &#125; 2.1.1 fork SystemServer进程第一步是准备参数在代码中已经把重要的参数都注释出来了，我们重点关注第二步 fork 出 SystemServer 进程，首先我们跟踪进 Zygote 类的 forkSystemServer 方法。 123456789101112public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); // Enable tracing as soon as we enter the system_server. if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; 可以看到其实 forkSystemServer 方法相当的简单 只是调用了 native 方法 nativeForkSystemServer,跟踪到 jni 层的方法如下：路径：frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223242526static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; // 调用 ForkAndSpecializeCommon 方法来 frok 出子进程 pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; // The zygote process checks whether the child process has died or not. ALOGI(\"System server process %d has been created\", pid); gSystemServerPid = pid; // There is a slight window that the system server process has crashed // but it went unnoticed because we haven't published its pid yet. So // we recheck here just to make sure that all is well. int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env); //启动SystemServer失败，重启系统 &#125; &#125; return pid;&#125; 从上面的函数中我们看到，主要还是通过 ForkAndSpecializeCommon 方法来fork出子进程，这跟前面我们介绍 应用 通过Zygote类的forkAndSpecialize 方法（该方法最终也是调动了ForkAndSpecializeCommon来fork子进程）fork出子进程是一样的。只不过这边比较特殊的是，在fork后多了一步判断，如果fork失败则 Zygote进程会直接终止自己（注意这时候我们是在Zygote进程来准备fork出SystemServer进程）,Zygote进程终止后会自动重启，然后再走一遍这个流程。 在上一篇的Zygote进程 fork 应用程序的时候并没有深入的介绍 Zygote.forkAndSpecialize 的流程，这边我们结合 SystmServer进程的 fork 一起介绍，如上所说，这两个进程的fork最终都会调用到 ForkAndSpecializeCommon 方法，我们来看下这个方法的详细代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207// Utility routine to fork zygote and specialize the child process.static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; //设置处理sigchld 信号的函数 SigChldHandler SetSigChldHandler();#ifdef ENABLE_SCHED_BOOST SetForkLoad(true);#endif sigset_t sigchld; sigemptyset(&amp;sigchld); sigaddset(&amp;sigchld, SIGCHLD); // Temporarily block SIGCHLD during forks. The SIGCHLD handler might // log, which would result in the logging FDs we close being reopened. // This would cause failures because the FDs are not whitelisted. // // Note that the zygote process is single threaded at this point. if (sigprocmask(SIG_BLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Close any logging related FDs before we start evaluating the list of // file descriptors. __android_log_close(); // If this is the first fork for this zygote, create the open FD table. // If it isn't, we just need to check whether the list of open files has // changed (and it shouldn't in the normal case). if (gOpenFdTable == NULL) &#123; gOpenFdTable = FileDescriptorTable::Create(); if (gOpenFdTable == NULL) &#123; RuntimeAbort(env, __LINE__, \"Unable to construct file descriptor table.\"); &#125; &#125; else if (!gOpenFdTable-&gt;Restat()) &#123; RuntimeAbort(env, __LINE__, \"Unable to restat file descriptor table.\"); &#125; pid_t pid = fork(); if (pid == 0) &#123; // The child process. gMallocLeakZygoteChild = 1; // Clean up any descriptors which must be closed immediately DetachDescriptors(env, fdsToClose); // Re-open all remaining open file descriptors so that they aren't shared // with the zygote across a fork. if (!gOpenFdTable-&gt;ReopenOrDetach()) &#123; RuntimeAbort(env, __LINE__, \"Unable to reopen whitelisted descriptors.\"); &#125; if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // Keep capabilities across UID change, unless we're staying root. if (uid != 0) &#123; EnableKeepCapabilities(env); &#125; DropCapabilitiesBoundingSet(env); bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL) &amp;&amp; android::NativeBridgeAvailable(); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); use_native_bridge = android::NeedsNativeBridge(isa_string.c_str()); &#125; if (use_native_bridge &amp;&amp; dataDir == NULL) &#123; // dataDir should never be null if we need to use a native bridge. // In general, dataDir will never be null for normal applications. It can only happen in // special cases (for isolated processes which are not associated with any app). These are // launched by the framework and should not be emulated anyway. use_native_bridge = false; ALOGW(\"Native bridge will not be used because dataDir == NULL.\"); &#125; if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123; ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno)); if (errno == ENOTCONN || errno == EROFS) &#123; // When device is actively encrypting, we get ENOTCONN here // since FUSE was mounted before the framework restarted. // When encrypted device is booting, we get EROFS since // FUSE hasn't been created yet by init. // In either case, continue without external storage. &#125; else &#123; ALOGE(\"Cannot continue without emulated storage\"); RuntimeAbort(env); &#125; &#125; if (!is_system_server) &#123; int rc = createProcessGroup(uid, getpid()); if (rc != 0) &#123; if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc)); &#125; &#125; &#125; SetGids(env, javaGids); SetRLimits(env, javaRlimits); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); ScopedUtfChars data_dir(env, dataDir); android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str()); &#125; int rc = setresgid(gid, gid, gid); if (rc == -1) &#123; ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno)); RuntimeAbort(env); &#125; rc = setresuid(uid, uid, uid); if (rc == -1) &#123; ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno)); RuntimeAbort(env); &#125; if (NeedsNoRandomizeWorkaround()) &#123; // Work around ARM kernel ASLR lossage (http://b/5817320). int old_personality = personality(0xffffffff); int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE); if (new_personality == -1) &#123; ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno)); &#125; &#125; SetCapabilities(env, permittedCapabilities, effectiveCapabilities); SetSchedulerPolicy(env); const char* se_info_c_str = NULL; ScopedUtfChars* se_info = NULL; if (java_se_info != NULL) &#123; se_info = new ScopedUtfChars(env, java_se_info); se_info_c_str = se_info-&gt;c_str(); if (se_info_c_str == NULL) &#123; ALOGE(\"se_info_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; const char* se_name_c_str = NULL; ScopedUtfChars* se_name = NULL; if (java_se_name != NULL) &#123; se_name = new ScopedUtfChars(env, java_se_name); se_name_c_str = se_name-&gt;c_str(); if (se_name_c_str == NULL) &#123; ALOGE(\"se_name_c_str == NULL\"); RuntimeAbort(env); &#125; &#125; rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (rc == -1) &#123; ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid, is_system_server, se_info_c_str, se_name_c_str); RuntimeAbort(env); &#125; // Make it easier to debug audit logs by setting the main thread's name to the // nice name rather than \"app_process\". if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); &#125; delete se_info; delete se_name; UnsetSigChldHandler(); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server ? NULL : instructionSet); if (env-&gt;ExceptionCheck()) &#123; ALOGE(\"Error calling post fork hooks.\"); RuntimeAbort(env); &#125; &#125; else if (pid &gt; 0) &#123; // the parent process // We blocked SIGCHLD prior to a fork, we unblock it here. if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, NULL) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; &#125; return pid;&#125;&#125; // anonymous namespace 这边我们重点关注 SetSigChldHandler 函数的调用，这边设置了处理 sigchld 信号的函数 SigChldHandler： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// This signal handler is for zygote mode, since the zygote must reap its childrenstatic void SigChldHandler(int /*signal_number*/) &#123; pid_t pid; int status; // It's necessary to save and restore the errno during this function. // Since errno is stored per thread, changing it here modifies the errno // on the thread on which this signal handler executes. If a signal occurs // between a call and an errno check, it's possible to get the errno set // here. // See b/23572286 for extra information. int saved_errno = errno;//调用 waitpid 来防止子进程变成僵尸 while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123; // Log process-death status that we care about. In general it is // not safe to call LOG(...) from a signal handler because of // possible reentrancy. However, we know a priori that the // current implementation of LOG() is safe to call from a SIGCHLD // handler in the zygote process. If the LOG() implementation // changes its locking strategy or its use of syscalls within the // lazy-init critical section, its use here may become unsafe. if (WIFEXITED(status)) &#123; if (WEXITSTATUS(status)) &#123; ALOGI(\"Process %d exited cleanly (%d)\", pid, WEXITSTATUS(status)); &#125; &#125; else if (WIFSIGNALED(status)) &#123; if (WTERMSIG(status) != SIGKILL) &#123; ALOGI(\"Process %d exited due to signal (%d)\", pid, WTERMSIG(status)); &#125; if (WCOREDUMP(status)) &#123; ALOGI(\"Process %d dumped core.\", pid); &#125; &#125; //如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote） // If the just-crashed process is the system_server, bring down zygote // so that it is restarted by init and system server will be restarted // from there. if (pid == gSystemServerPid) &#123; ALOGE(\"Exit zygote because system server (%d) has terminated\", pid); kill(getpid(), SIGKILL); &#125; &#125; // Note that we shouldn't consider ECHILD an error because // the secondary zygote might have no children left to wait for. if (pid &lt; 0 &amp;&amp; errno != ECHILD) &#123; ALOGW(\"Zygote SIGCHLD error in waitpid: %s\", strerror(errno)); &#125; errno = saved_errno;&#125; 这边我们重点关注 上面代码注释的那段，如果死亡的是 SystemServer 进程，那么杀死父进程（也就是Zygote），如果Zygote死亡那么导致的是INit进程会杀死所有的用户进程并重启Zygote。我们在调试系统代码的时候经常会杀死system_process进程来重启系统的原理就是这个。为什么是system_process进程而不是参数system_server ，这个我们在后面 2.2.1 会介绍到。 2.1.2 调用 handleSystemServerProcess 初始化 SystemServer 进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket();//设置 umask = 0077 // set umask to 0077 so new files and directories will default to owner-only permissions. Os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; //修改进程名 上面我们传进来的参数为 system_server Process.setArgV0(parsedArgs.niceName); &#125; final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); &#125;// invokeWith 参数基本为null if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; // If we have a non-null system server class path, we'll have to duplicate the // existing arguments and append the classpath to it. ART will handle the classpath // correctly when we exec a new process. if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; //通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */ &#125; 上面方法主要做了以下几件事 关闭从zygote继承的socket 设置SystemServer进程的umask为0077，这样SystemServer进程创建的文件的属性为0700，只有进程本身可以访问 修改进程的名称为参数 “system_server” invokeWith 参数基本为null,所以一般是通过 RuntimeInit 类 zygoteInit 来调用 SystemServer 的 main 方法 2.2 SystemServer 类main方法来执行初始化首先我们来查看 main 方法的源码 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 相当的简单,直接 new 一个 SystemServer 类的 实例同事执行了 run 方法，这里我们要重点解释下 SystemServer 并未继承自 Thread 类，这边调用 run 方法，只是刚好名字叫做 run 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 private void run() &#123; //如果时间不正确则调整系统时间 // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; Slog.w(TAG, \"System clock is before 1970; setting to 1970.\"); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; // If the system has \"persist.sys.language\" and friends set, replace them with // \"persist.sys.locale\". Note that the default locale at this point is calculated // using the \"-Duser.locale\" command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125; // Here we go! Slog.i(TAG, \"Entered the Android system server!\"); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());//设置当前的虚拟机 运行库 路径 // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) &#123; SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() &#123; @Override public void run() &#123; SamplingProfilerIntegration.writeSnapshot(\"system_server\", null); &#125; &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); &#125; // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit();//调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper();//装载 libandroid_servers.so // Initialize native services. System.loadLibrary(\"android_servers\"); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext();//创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);//启动全部的 java services // Start services. try &#123; startBootstrapServices(); startCoreServices(); startOtherServices(); &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, \"Enabled StrictMode for system server main thread.\"); &#125; // Loop forever. Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; run 方法主要做这些事情 如果时间不正确则调整系统时间 设置当前的虚拟机 运行库 路径:值为 属性 persist.sys.dalvik.vm.lib.2 的值 调整虚拟机堆的内存，设置堆利用率为0.8，当实际利用率偏离这个值的时候，虚拟机在立即回收的时候会重新调整堆大小，使得利用率接近这个设置值 装载 libandroid_servers.so,路径在 framework/base/services/jni 下 调用 createSystemContext 方法获取 Context 创建 SystemServiceManager 的实例 mSystemServiceManager ，它将负责系统Service的启动 启动全部的 java services 进入消息循环：Looper.loop() 2.2.1 createSystemContext 方法获取 Context123456 private void createSystemContext() &#123; ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext();//设置主题 mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); &#125; 12345678910111213public static ActivityThread systemMain() &#123; // The system process on low-memory devices do not get to use hardware // accelerated drawing, since this can add too much overhead to the // process. if (!ActivityManager.isHighEndGfx()) &#123; HardwareRenderer.disable(true); &#125; else &#123; HardwareRenderer.enableForegroundTrimming(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(true); return thread;&#125; 在 篇的 3.5.3节中，当 zygote 进程fork应用进程，在最后启动应用的时候会调用 ActivityThread 类的 main 方法，跟这边的 systemMain方法相似的是这两个方法都 创建了 ActivityThread 对象（区别在于 普通应用 thread.attach(false); SystemServer则是 true）。ActivityThread 是应用程序的主线程类，那么为什么 SystemServer 需要创建这个对象呢？这是因为 SystemServer 不仅仅是一个后台进程，同时也是一个运行着组件的Service的进程，像一些系统对话框也是从这个进程弹出的，所以它也需要一个上下文环境（activityThread.getSystemContext()）。 上文我们说到SystemServer 调用 hread.attach 方法的参数为 true ，那么我们来看看 true分支下的流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125;); &#125; else &#123; //这边为 true 流程 也就是 SystemServer 进程执行的 //设置ddms中看到的应用名称 这也是为什么 我们上面说要重启系统 杀死system_process进程的原因 // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(\"system_process\", UserHandle.myUserId()); try &#123; //创建 Instrumentation 对象 mInstrumentation = new Instrumentation(); //创建 Context 对象 ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); //创建 应用的Application 对象 mInitialApplication = context.mPackageInfo.makeApplication(true, null); //调用 onCreate 生命周期 mInitialApplication.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate Application():\" + e.toString(), e); &#125; &#125; // add dropbox logging to libcore DropBox.setReporter(new DropBoxReporter()); ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources // immediately, because upon returning the view // hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) &#123; // This actually changed the resources! Tell // everyone about it. if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123; mPendingConfiguration = newConfig; sendMessage(H.CONFIGURATION_CHANGED, newConfig); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; &#125; @Override public void onTrimMemory(int level) &#123; &#125; &#125;); &#125; 从上面代码可以看出这是完全在模拟一个类似应用的环境。但是每一个上下文环境都需要一个 apk文件，那么这个文件从哪里来呢？这个就需要我们跟踪进 getSystemContext 方法了。 12345678public ContextImpl getSystemContext() &#123; synchronized (this) &#123; if (mSystemContext == null) &#123; mSystemContext = ContextImpl.createSystemContext(this); &#125; return mSystemContext; &#125;&#125; 12345678static ContextImpl createSystemContext(ActivityThread mainThread) &#123; LoadedApk packageInfo = new LoadedApk(mainThread); ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY); context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked()); return context;&#125; 123456789101112131415161718192021LoadedApk(ActivityThread activityThread) &#123; mActivityThread = activityThread; mApplicationInfo = new ApplicationInfo(); mApplicationInfo.packageName = \"android\"; mPackageName = \"android\"; mAppDir = null; mResDir = null; mSplitAppDirs = null; mSplitResDirs = null; mOverlayDirs = null; mSharedLibraries = null; mDataDir = null; mDataDirFile = null; mLibDir = null; mBaseClassLoader = null; mSecurityViolation = false; mIncludeCode = true; mRegisterPackage = false; mClassLoader = ClassLoader.getSystemClassLoader(); mResources = Resources.getSystem();&#125; 因为 framework-res.apk的包名就是 “android”，所以这边创建的Application对象代表的就是 framework-res.apk。","categories":[],"tags":[]},{"title":"Zygote进程","slug":"Zygote","date":"2018-06-01T08:21:00.000Z","updated":"2018-06-05T01:10:34.819Z","comments":true,"path":"2018/06/01/Zygote/","link":"","permalink":"http://yoursite.com/2018/06/01/Zygote/","excerpt":"","text":"一.概述1.1 什么是ZygoteLinux的进程是通过系统调用fork产生的，fork出的子进程除了内核中的一些核心数据结构和父进程不同外，其余的内存映像都是和父进程共享的。当子进程需要去改写这些共享数据的内存时，操作系统才会为子进程分配一个新的内存页，并将老的页面数据复制到新的页面上后再进行修改操作（写时拷贝）。 fork出来的进程会继续执行系统调用exec。exec将用一个新的可执行文件的内容替换当前进程的代码段、数据段、堆和栈段。 fork+exec是Linux启动进程的标准做法，Init进程中启动的服务也是这样做的，Zygote进程就是这么被启动起来的。（Init进程 2.2.3处） 那么Zygote是怎么做的呢？Zygote在创建应用程序的只执行了fork操作，没有去调用exec。 Zygote初始化时会创建虚拟机，同时把需要的系统类库和资源文件加载到内存中。Zygote fork出子进程后（系统会根据apk的类型来选择fork 32位还是64位的 Zygote），这个子进程也继承了能正常工作的虚拟机和各种系统资源。接下来子进程只需要加载APK中的字节码就可以运行了。这样就达到了减少启动时间的作用。 1.2 启动的时机上篇Init进程中我们知道Zygote进程是由Init进程启动的，那么到底是在什么时候启动的呢？我们现在追踪下源码。在Init进程的初始化过程中会解析init.rc文件，从文件中我们可以看出init.rc会根据ro.zygote属性来加载哪个文件，下面是我获取的公司的6.0系统的板子属性。 root@rk3399_stbvr:/ # getprop ro.zygotezygote64_32 123456import /init.environ.rcimport /init.usb.rcimport /init.$&#123;ro.hardware&#125;.rcimport /init.usb.configfs.rcimport /init.$&#123;ro.zygote&#125;.rcimport /init.trace.rc 现在我们来看看init.zygote64_32.rc文件的内容：1234567891011121314service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class core socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class core socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks 1.3 参数分析app_process 启动的参数格式是: app_process [虚拟机参数] 运行目录 参数[java类] 以上文rc文件32位启动为例：service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin –zygote –socket-name=zygote_secondary 虚拟机参数：以符号‘-’开头。例如：-Xzygote 运行目录：一般是在 /system/bin 参数：以符号“–”开头。参数“–zygote”表示要启动zygote进程。“–application”表示要以普通进程的方式执行java代码。 java类：将要执行的java类。必须要有一个静态方法main。使用参数“zygote”时不会执行这个类，而是固定执行ZygoteInit类。 二.Zygote的初始化2.1 app_process的main方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int main(int argc, char* const argv[])&#123; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123; // Older kernels don't understand PR_SET_NO_NEW_PRIVS and return // EINVAL. Don't die on such kernels. if (errno != EINVAL) &#123; LOG_ALWAYS_FATAL(\"PR_SET_NO_NEW_PRIVS failed: %s\", strerror(errno)); return 12; &#125; &#125; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++; // Everything up to '--' or first non '-' arg goes to the vm. // // The first argument after the VM args is the \"parent dir\", which // is currently unused. // // After the parent dir, we expect one or more the following internal // arguments : // // --zygote : Start in zygote mode // --start-system-server : Start the system server. // --application : Start in application (stand alone, non zygote) mode. // --nice-name : The nice name for this process. // // For non zygote starts, these arguments will be followed by // the main class name. All remaining arguments are passed to // the main method of this class. // // For zygote starts, all remaining arguments are passed to the zygote. // main function. // // Note that we must copy argument string values since we will rewrite the // entire argument block when we apply the nice name to argv0. int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //解析参数 ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. //执行非zygote模式 args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; //执行zygote模式 // We're in zygote mode. maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //将本进程的名字改成 “--nice-name”参数的指定的值，如果没指定则默认为ZYGOTE_NICE_NAME宏指定的值（可能是zygote或者是zygote64） if (!niceName.isEmpty()) &#123; //替换启动参数窜中的“app_process”为参数--nice-name指定的名称 runtime.setArgv0(niceName.string()); //用来改变进程名 set_process_name(niceName.string()); &#125; if (zygote) &#123; //参数带有--zygote 所以执行ZygoteInit类 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; //否则执行通过参数传进来的java类 runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 2.2 启动虚拟机 AndroidRuntime类负责启动虚拟机以及Java线程.AndroidRuntime类在一个进程中只有一个实例对象，保存在全局变量gCurRuntime中。 1234567891011121314151617AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength)&#123; SkGraphics::Init(); // There is also a global font cache, but its budget is specified by // SK_DEFAULT_FONT_CACHE_COUNT_LIMIT and SK_DEFAULT_FONT_CACHE_LIMIT. // Pre-allocate enough space to hold a fair number of options. mOptions.setCapacity(20); assert(gCurRuntime == NULL); // one per process //保存到全局变量中 gCurRuntime = this;&#125; 2.2.1 启动虚拟机在2.1的main函数的末尾我们执行了runtime的start函数来执行java类。在zygote进程执行java代码前，还需要初始化整个java运行环境。下面我们来追踪下start函数的执行过程 2.2.1.1 输出启动log12ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); 这个日志标志android系统的启动，因为以后的进程都是从zygote进程fork出来的，所以这个不会再执行start函数。所以如果日志中反复出现这段打印的话，并且进程ID为zygote，则说明系统正在不断的重启。 2.2.1.2 获取系统目录123456789const char* rootDir = getenv(\"ANDROID_ROOT\");if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1);&#125; 首先从环境变量ANDROID_ROOT中获取，如果环境变量没有设置则把系统目录设置为/system，然后检查/system目录是否存在，如果不存在zygote退出。系统目录是在Init进程中创建的。 2.2.1.3 启动虚拟机1234567/* start the virtual machine */JniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return;&#125; 2.2.1.4 调用虚函数onVmCreated1onVmCreated(env); 这边onVmCreated只是一个虚函数，在android系统中调用的其实是其子类 AppRuntime中重载的。代码如下 1234567891011121314151617181920212223242526272829 virtual void onVmCreated(JNIEnv* env) &#123;//如果是zygote进程的话，这时候mClassName是null的，所以执行到这边就结束了。 if (mClassName.isEmpty()) &#123; return; // Zygote. Nothing to do here. &#125; /* * This is a little awkward because the JNI FindClass call uses the * class loader associated with the native method we're executing in. * If called in onStarted (from RuntimeInit.finishInit because we're * launching \"am\", for example), FindClass would see that we're calling * from a boot class' native method, and so wouldn't look for the class * we're trying to look up in CLASSPATH. Unfortunately it needs to, * because the \"am\" classes are not boot classes. * * The easiest fix is to call FindClass here, early on before we start * executing boot class Java code and thereby deny ourselves access to * non-boot classes. */ char* slashClassName = toSlashClassName(mClassName.string()); mClass = env-&gt;FindClass(slashClassName); if (mClass == NULL) &#123; ALOGE(\"ERROR: could not find class '%s'\\n\", mClassName.string()); &#125; free(slashClassName); mClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass)); &#125; 2.2.1.5 注册系统的JNI函数1234567/* * Register android functions. */if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return;&#125; 12345678910111213141516171819202122232425262728293031323334/* * Register android native functions with the VM. *//*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); /* * Every \"register\" function calls one or more things that return * a local reference (e.g. FindClass). Because we haven't really * started the VM yet, they're all getting stored in the base frame * and never released. Use Push/Pop to manage the storage. */ env-&gt;PushLocalFrame(200); //通过register_jni_procs函数将全局数组gRegJNI中的jni本地函数在虚拟机中注册 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); //createJavaThread(\"fubar\", quickTest, (void*) \"hello\"); return 0;&#125; 2.2.1.6 准备参数: 调用java类的main函数使用的12345678910111213141516/* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */jclass stringClass;jobjectArray strArray;jstring classNameStr;stringClass = env-&gt;FindClass(\"java/lang/String\");assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); 2.2.1.7 调用java类的main方法如果启动的是Zygote进程调用的java类是ZygoteInit类，否则的话是RuntimeInit。 1234567891011121314151617181920212223242526 /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //获取main方法的ID jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //通过id调用java类的main方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; 2.3 初始化工作—— ZygoteInit 类从这边起我们就从C++进入到了java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 public static void main(String argv[]) &#123; try &#123; RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; if (abiList == null) &#123; throw new RuntimeException(\"No ABI list supplied.\"); &#125;// 注册Zyogte的socket监听端口，用来接收启动应用程序的消息 3.1会详细分析 registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); //装在系统资源。包括系统预加载类、Framework资源和openGL的资源。//这样当应用程序被fork处理后，应用的进程内已经很包含了这些系统资源，大大节省应用的启动时间。//在 第四节 预加载系统类和资源中会详细介绍 preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) &#123; //启动 SystemServer进程 在中会详细介绍 startSystemServer(abiList, socketName); &#125; Log.i(TAG, \"Accepting command socket connections\");//进入监听和接收消息的循环 在3.3节会详细分析 runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125; &#125; SystemServer服务 的启动也是在这边的startSystemServer()方法中调用的。# 三.Zygote启动应用程序# 3.1 注册zygote的socket在上面2.3 ZygoteInit的main方法中我们调用了 registerZygoteSocket 方法来创建一个本地socket，然后调用了runSelectLoop来进入等待监听socket连接的循环。下面我们先来查看 registerZygoteSocket 方法123456789101112131415161718192021222324 private static void registerZygoteSocket(String socketName) &#123; if (sServerSocket == null) &#123; int fileDesc;//ANDROID_SOCKET_PREFIX的值为“ANDROID_SOCKET_” final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //通过环境变量获取socket句柄 String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(fullSocketName + \" unset or invalid\", ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //生成本地服务的socket并保存在全局变量中。 sServerSocket = new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error binding to local socket '\" + fileDesc + \"'\", ex); &#125; &#125; &#125; registerZygoteSocket通过环境变量获取到socket句柄，但是这个socket是在哪里创建的呢？回到 1.2 节，我们是否还记得 zygote的rc文件的zygote服务里面定义了这么一条命令 1socket zygote stream 660 root system Init进程会根据这个选项创建一个AF_UNIX的socket，并把这个句柄放在环境变量ANDROID_SOCKET_[zygote]（zygote这个是指选项的名称）中。根据句柄创建FileDescriptor对象，然后通过LocalServerSocket方法生成一个本地服务的socket,并保存在sServerSocket中。 3.2 请求启动应用android启动一个新的进程都是在AMS中完成的，不管是因为什么原因启动一个新的进程，最终都是AMS的startProcessLocked来实现的。代码如下： 12345678if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";//启动进程Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); “android.app.ActivityThread” 参数就是应用启动后执行的java类。 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 最终start方法调用了 startViaZygote 方法来启动应用。首先将应用程序的启动参数保存到argsForZygote列表中，然后调用 zygoteSendArgsAndGetResult 将应用程序进程的启动参数发送到zygote进程中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; //启动参数保存到argsForZygote列表中 ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123; argsForZygote.add(\"--enable-jni-logging\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123; argsForZygote.add(\"--enable-safemode\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123; argsForZygote.add(\"--enable-debugger\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123; argsForZygote.add(\"--enable-checkjni\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JIT) != 0) &#123; argsForZygote.add(\"--enable-jit\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123; argsForZygote.add(\"--generate-debug-info\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123; argsForZygote.add(\"--enable-assert\"); &#125; if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(\"--mount-external-read\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(\"--mount-external-write\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); //TODO optionally enable debuger //argsForZygote.add(\"--enable-debugger\"); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125;// openZygoteSocketIfNeeded创建通信的socket，然后zygoteSendArgsAndGetResult将参数列表发送到zygote进程中 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; 创建通信的socket12345678910111213141516171819202122232425262728private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 发送到zygote进程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; // Throw early if any of the arguments are malformed. This means we can // avoid writing a partial response to the zygote. int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); &#125; &#125; /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125; &#125; 3.3 处理启动应用的请求在2.3节中 我们知道在ZygoteInit的main方法中 会通过runSelectLoop开启无限循环来接收启动应用的请求 12345678910111213141516171819202122232425262728293031323334353637private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 这边通过i=0判断请求连接事件是否到来，如果到来了调用 acceptCommandPeer 来和客户端建立一个socket链接，然后把socket加入到监听数组中，来等待socket上命令的到来。 如果i&gt;0这时候表示socket上有数据到了。这时候直接调用 ZygoteConnection 类的 runOnce 方法，处理完断开连接，并清除scoket。 3.4 fork应用进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123;//通过 readArgumentList 方法从socket连接中读取参数行 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; /** the stderr of the most recent request, if avail */ PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123; newStderr = new PrintStream( new FileOutputStream(descriptors[2])); &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) &#123; return handleAbiListQuery(); &#125; if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123; throw new ZygoteSecurityException(\"Client may not specify capabilities: \" + \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) + \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities)); &#125;//检查客户端进程是否有权利指定进程的用户id 组id 和所属的组//如果 客户端是root进程则可以任意指定//如果客户端是system进程，只有在系统属性 ro.fatorytest值为1 或者2的时候可以指定//没有指定则继承客户端的值 applyUidSecurityPolicy(parsedArgs, peer); applyInvokeWithSecurityPolicy(parsedArgs, peer); applyDebuggerSystemProperty(parsedArgs); applyInvokeWithSystemProperty(parsedArgs); int[][] rlimits = null; if (parsedArgs.rlimits != null) &#123; rlimits = parsedArgs.rlimits.toArray(intArray2d); &#125; if (parsedArgs.invokeWith != null) &#123; FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC); childPipeFd = pipeFds[1]; serverPipeFd = pipeFds[0]; Os.fcntlInt(childPipeFd, F_SETFD, 0); &#125; /** * In order to avoid leaking descriptors to the Zygote child, * the native code must close the two Zygote socket descriptors * in the child process before it switches from Zygote-root to * the UID and privileges of the application being launched. * * In order to avoid \"bad file descriptor\" errors when the * two LocalSocket objects are closed, the Posix file * descriptors are released via a dup2() call which closes * the socket and substitutes an open descriptor to /dev/null. */ int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null;//fork子进程 最后的fork还在native层完成的 在SystemServer进程 2.1 节会详细介绍 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, \"Exception creating pipe\", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, \"Invalid zygote arguments\", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, \"Zygote security policy prevents request: \", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //pid=0 表示在子进程中，所以执行 handleChildProc 在 3.5 节详细展开 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; //这时候还在zygote进程中，所以调用 handleParentProc 继续处理 return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125; 3.5 子进程的初始化我们接着上面的流程继续分析 handleChildProc 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /** * By the time we get here, the native code has closed the two actual Zygote * socket connections, and substituted /dev/null in their place. The LocalSocket * objects still need to be closed properly. */ closeSocket(); ZygoteInit.closeServerSocket(); if (descriptors != null) &#123; try &#123; Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; newStderr = System.err; &#125; catch (ErrnoException ex) &#123; Log.e(TAG, \"Error reopening stdio\", ex); &#125; &#125; if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 在方法的最后会根据参数的不同选择初始化的方式invokeWith不为null的时候，将会通过调用exec的方式来启动app_process进程来执行java类。正常情况下还是调用RuntimeInit.zygoteInit来启动的 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.5.1 commonInit方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 private static final void commonInit() &#123; if (DEBUG) Slog.d(TAG, \"Entered RuntimeInit!\");//设置进程的UncaughtException的处理方法//这边默认的实现是打印出错误堆栈然后退出应用//应用可以调用 Thread.setDefaultUncaughtExceptionHandler 来设置自定义的处理方式//想腾讯的bug平台的实现就是基于这点 /* set default handler; this applies to all threads in the VM */ Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());//设置时区 /* * Install a TimezoneGetter subclass for ZoneInfo.db */ TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null);//重置android系统的log系统 /* * Sets handler for java.util.logging to use Android log facilities. * The odd \"new instance-and-then-throw-away\" is a mirror of how * the \"java.util.logging.config.class\" system property works. We * can't use the system property here since the logger has almost * certainly already been initialized. */ LogManager.getLogManager().reset(); new AndroidConfig();//设置 http.agent 属性 /* * Sets the default HTTP User-Agent used by HttpURLConnection. */ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); /* * Wire socket tagging to traffic stats. */ NetworkManagementSocketTagger.install(); /* * If we're running in an emulator launched with \"-trace\", put the * VM into emulator trace profiling mode so that the user can hit * F9/F10 at any time to capture traces. This has performance * consequences, so it's not something you want to do always. */ String trace = SystemProperties.get(\"ro.kernel.android.tracing\"); if (trace.equals(\"1\")) &#123; Slog.i(TAG, \"NOTE: emulator trace profiling enabled\"); Debug.enableEmulatorTraceOutput(); &#125; initialized = true; &#125; 3.5.2 nativeZygoteInit 方法3.5.3 applicationInit 方法12345678910111213141516171819202122232425262728293031 private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true);//设置虚拟机参数 // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);//这边会真正调用到 ActivityThread.main 方法 // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125; 12345678910111213141516171819202122232425262728293031323334353637private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 四.预加载系统类和资源在 2.3 节 ZygoteInit类的main方法中会调用 preload 方法来可进行系统类和资源的预加载。 123456789101112static void preload() &#123; Log.d(TAG, \"begin preload\"); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, \"end preload\");&#125;","categories":[],"tags":[]},{"title":"Init进程","slug":"Init进程","date":"2018-05-31T06:32:00.000Z","updated":"2018-06-04T00:47:50.340Z","comments":true,"path":"2018/05/31/Init进程/","link":"","permalink":"http://yoursite.com/2018/05/31/Init进程/","excerpt":"","text":"一.概述Init进程是内核启动后创建的第一个用户进程，地位非常的重要。在Init初始化的过程中会启动很多重要的守护进程，当然Init本身也是一个守护进程。 在介绍Init进程前先简单的介绍下Android的启动过程 1.1 bootloader引导1.1.1 什么是bootloader引导当我们按下手机的电源键时，最先运行的就是bootloader。bootloader主要作用就是初始化基本的硬件设备（CPU,内存，Flash等）并且通过建立内存空间的映射，为装载linux内核准备好适合的环境。内核装载完毕，bootloader将会从内存中清除。 1.1.2 Fastboot模式Fastboot是Android设计的一套通过usb来更新手机分区映像的协议。 1.1.3 Recovery模式Android特有的升级系统。利用该模式可以进行恢复出厂设置，执行ota、补丁和固件升级。进入到Recovery模式实际上就是进入了一个文字模式的Linux 1.2 装载和启动Linux内核Android的boot.img存放的就是Linux的内核和一个根文件系统。上面的bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成整个后装载整个根文件系统，最后启动Init进程 什么是根文件系统？根文件系统是Linux系统一种特殊的文件系统，Android是基于Linux的，当然也有根文件系统。android的根文件系统是基于busybox实现的。 1.3 启动android系统android系统的启动可以更加详细的分为以下几个阶段 1.3.1 启动Init进程Init进程是系统启动的第一个进程。在Init的启动过程中会解析Linux的配置脚本init.rc文件、加载android的文件系统、创建系统目录、初始化属性系统、启动android系统重要的守护进程（USB守护进程、adb守护进程、vold守护进程、rild守护进程）。 Init作为守护进程的作用：修改属性请求、重启崩溃的进程等操作。 1.3.2 启动ServiceManager由init启动。管理binder服务，负责binder的注册和查找。 1.3.3 启动Zygote进程Init进程初始化结束时会启动Zygote进程。Zygote进程负责fork应用进程。是所有应用进程的父进程。 Zygote进程初始化时会创建Dalivik虚拟机、预装载系统的资源文件和Java类。从Zygote中fork的进程都会继承和共享这些预加载的资源。 启动结束后，转为守护进程来响应应用建立的请求。 1.3.4 启动SystemServiceSystemService是Zygote进程fork的第一个进程，也是android系统的核心进程。在SystemService中运行这android大部分的binder服务。 首先会启动SensorService,接着是ActivityManagerService（AMS）,WindowsManagerService（WMS）,PackagerManagerService(PKMS)等服务。 1.3.5 启动LauncherSystemServer加载完所有的服务后，最后会调用AMS中的systemReady()方法。在这个方法的执行过程中会发出Intent(android.intent.category.Home).凡是响应这个Intent的应用都会启动起来（这个流程我们到时候在AMS的分析部分会重点追踪整个过程），这边要跟开机广播区别开来。 二.Init进程的初始化过程Init进程的源码位于\\system\\core\\init\\下。程序的入口函数main()位于init.cpp中。 2.1 main函数的流程2.1.1 选择启动程序因为Init和ueventd和watchdogd守护进程的代码存在大量的代码重合，所以直接合并到一个文件中，通过参数来判断执行那个守护进程。 1234567if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125; 2.1.2 设置进程创建的文件的属性缺省情况下一个进程创建的文件属性是022，使用umask可以设置文件属性的掩码。参数为0表示掩码为0777。 12// Clear the umask.umask(0); 2.1.3 创建目录和挂载文件系统12345678910111213//确保只执行一次bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; tmpfs是一种基于内存的文件系统，mount后就可以使用。tmpfs文件系统下的所有文件都存放在内存中，访问速度快，但是关机后会消失，适合用来存放临时性的文件。而且tmpfs文件系统的大小是动态变化的，一开始很小，随着文件的增多会随之变大。从上面的代码我们可以看到Android系统将tmpfs文件系统挂载到/dev目录下，而这个目录是用来保存系统创造的设备节点，正好符合tmpfs的特点。 devpts是虚拟终端文件系统，通常mount在目录/dev/pts下。 2.1.4 初始化log系统1234567891011//将标准输入、输出、错误重定向到空设备文件/dev/null下，这是守护进程常用的手段 open_devnull_stdio();//创建设备节点/dev/kmsg,这样init进程就可以使用kernel的log系统，之所以是用使用kernel的log系统是因为这时候android层的log系统还没有启动起来 klog_init();//设置log级别 klog_set_level(KLOG_NOTICE_LEVEL);//打印init进程开始启动的日志 NOTICE(\"init%s started!\\n\", is_first_stage ? \"\" : \" second stage\"); 日志输出级别的宏定义如下 KLOG_ERROR_LEVEL 3 KLOG_WARNING_LEVEL 4 KLOG_NOTICE_LEVEL 5 KLOG_INFO_LEVEL 6 KLOG_DEBUG_LEVEL 7 KLOG_DEFAULT_LEVEL 3 //默认为3当我们设置的级别低于5的时候会输出到 kernel log 中 2.1.5 初始化属性系统123456789101112131415161718 if (!is_first_stage) &#123;//在/dev下创建一个设备表示正在初始化中，当初始化完成则移除// Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));//创建一个共享区域来存储属性值 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt();//解析kernel的启动参数 process_kernel_cmdline(); // Propogate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; 2.1.6 初始化SELinux内核SELinux内核是android4.3开始引入的。在后面的解析系列中会重点解析这块。1234567891011121314151617181920212223242526272829303132// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.INFO(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; 2.1.7 初始化子进程退出的信号处理过程1signal_handler_init(); 2.1.8 设置系统属性的默认值1property_load_boot_defaults(); 上面的函数会从设备的根目录下的default.prop文件(路径:/default.prop)的属性值读取设置到属性系统中。 下面是截取的nexu5x 6.0系统模拟器下的文件值1234567891011121314151617181920## ADDITIONAL_DEFAULT_PROPERTIES#ro.secure=1ro.allow.mock.location=0ro.debuggable=1ro.zygote=zygote32dalvik.vm.image-dex2oat-Xms=64mdalvik.vm.image-dex2oat-Xmx=64mdalvik.vm.dex2oat-Xms=64mdalvik.vm.dex2oat-Xmx=512mro.dalvik.vm.native.bridge=0debug.atrace.tags.enableflags=0## BOOTIMAGE_BUILD_PROPERTIES#ro.bootimage.build.date=Wed Dec 13 00:51:01 UTC 2017ro.bootimage.build.date.utc=1513126261ro.bootimage.build.fingerprint=Android/sdk_google_phone_x86/generic_x86:6.0/MASTER/4499259:userdebug/test-keyspersist.sys.usb.config=adb 2.1.9 启动属性服务（sockect）读取相应文件的属性，下文5.3中有介绍。1start_property_service(); 2.1.10 解析init.rc文件解析完成后的结果是将init文件中的Server项和Action项分别加入到内部Service列表:service_list 和Action列表:action_list解析的过程会在下面的详细的分析 1init_parse_config_file(\"/init.rc\"); 2.1.11 初始化执行列表action_queue1234567891011121314151617181920212223242526272829303132333435 //将rc文件中触发器为early-init的action添加到执行列表action_for_each_trigger(\"early-init\", action_add_queue_tail);//queue_builtin_action 作用就是将一个函数和一个名称生成action并插入到执行列表 // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...//等待冷插拔设备初始化完成 queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. //从硬件RNG的设备文件/dev/hw_randow中读取512字节并写到Linux RNGd的设备文件/dev/urandom中（这块因为水平有限，还未知道具体作用）queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//初始化组合键监听模块 queue_builtin_action(keychord_init_action, \"keychord_init\");//在屏幕上显示Android字样的Logo queue_builtin_action(console_init_action, \"console_init\"); //将rc文件中触发器为init的action添加到执行列表 // Trigger all the boot actions to get us started. action_for_each_trigger(\"init\", action_add_queue_tail); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//当处于充电模式，则charger加入执行队列；否则late-init加入队列。 // Don't mount filesystems or start core system services in charger mode. char bootmode[PROP_VALUE_MAX]; if (property_get(\"ro.bootmode\", bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, \"charger\") == 0) &#123; action_for_each_trigger(\"charger\", action_add_queue_tail); &#125; else &#123; action_for_each_trigger(\"late-init\", action_add_queue_tail); &#125;//检查Action列表中通过修改属性来触发的Action，查看相关的属性是否已经设置了，如果已经设置则将该action加入到执行列表 // Run all property triggers based on current state of the properties. queue_builtin_action(queue_property_triggers_action, \"queue_property_triggers\"); 2.1.12 无限循环执行123456789101112131415161718192021222324252627while (true) &#123; if (!waiting_for_exec) &#123; execute_one_command(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (!action_queue_empty() || cur_action) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; 2.2 启动Service进程上面最后无限循环的过程中 restart_processes 函数会检查service_list中所有服务，对于带有SVC_RESTARTING标志的服务，将服务作为参数调用 restart_service_if_needed 1234567891011121314static void restart_service_if_needed(struct service *svc) &#123; time_t next_start_time = svc-&gt;time_started + 5; if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); service_start(svc, NULL); return; &#125; if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; 由上面代码可以看出最后调用了service_start方法，下面我们来分析这个方法。 2.2.1 重置Service结构中的标志和可执行判断12345678910111213141516171819202122232425262728293031323334353637 // Starting a service removes it from the disabled or reset state and // immediately takes it out of the restarting state if it was in there.//这四个表示都是有启动相关的所以直接去掉 svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START)); svc-&gt;time_started = 0;//如果已经在启动了则不需要再执行 // Running processes require no additional work --- if they're in the // process of exiting, we've ensured that they will immediately restart // on exit, unless they are ONESHOT. if (svc-&gt;flags &amp; SVC_RUNNING) &#123; return; &#125;//如果服务需要控制台，但是控制台没有启动则退出 bool needs_console = (svc-&gt;flags &amp; SVC_CONSOLE); if (needs_console &amp;&amp; !have_console) &#123; ERROR(\"service '%s' requires console\\n\", svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务的二进制文件是否存在 struct stat s; if (stat(svc-&gt;args[0], &amp;s) != 0) &#123; ERROR(\"cannot find '%s', disabling '%s'\\n\", svc-&gt;args[0], svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务是否有SVC_ONESHOT参数 if ((!(svc-&gt;flags &amp; SVC_ONESHOT)) &amp;&amp; dynamic_args) &#123; ERROR(\"service '%s' must be one-shot to use dynamic args, disabling\\n\", svc-&gt;args[0]); svc-&gt;flags |= SVC_DISABLED; return; &#125; 2.2.2 设置安全上下文关于安全机制在后续的文章中分析 12345678910111213141516171819202122232425262728293031323334353637char* scon = NULL;if (is_selinux_enabled() &gt; 0) &#123; if (svc-&gt;seclabel) &#123; scon = strdup(svc-&gt;seclabel); if (!scon) &#123; ERROR(\"Out of memory while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125; else &#123; char *mycon = NULL, *fcon = NULL; INFO(\"computing context for service '%s'\\n\", svc-&gt;args[0]); int rc = getcon(&amp;mycon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; rc = getfilecon(svc-&gt;args[0], &amp;fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); freecon(mycon); return; &#125; rc = security_compute_create(mycon, fcon, string_to_security_class(\"process\"), &amp;scon); if (rc == 0 &amp;&amp; !strcmp(scon, mycon)) &#123; ERROR(\"Warning! Service %s needs a SELinux domain defined; please fix!\\n\", svc-&gt;name); &#125; freecon(mycon); freecon(fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125;&#125; 2.2.3 fork子进程,exec123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 //首先打印 服务启动日志NOTICE(\"Starting service '%s'...\\n\", svc-&gt;name); //fork进程pid_t pid = fork();if (pid == 0) &#123; struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; umask(077); //准备环境变量 if (properties_initialized()) &#123; get_property_workspace(&amp;fd, &amp;sz); snprintf(tmp, sizeof(tmp), \"%d,%d\", dup(fd), sz); add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp); &#125; for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next) add_environment(ei-&gt;name, ei-&gt;value); //如果服务选项中有socket选项。这时候就开始创建参数中定义的socket。 for (si = svc-&gt;sockets; si; si = si-&gt;next) &#123; int socket_type = ( !strcmp(si-&gt;type, \"stream\") ? SOCK_STREAM : (!strcmp(si-&gt;type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET)); int s = create_socket(si-&gt;name, socket_type, si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon); if (s &gt;= 0) &#123; publish_socket(si-&gt;name, s); &#125; &#125; freecon(scon); scon = NULL; if (svc-&gt;writepid_files_) &#123; std::string pid_str = android::base::StringPrintf(\"%d\", pid); for (auto&amp; file : *svc-&gt;writepid_files_) &#123; if (!android::base::WriteStringToFile(pid_str, file)) &#123; ERROR(\"couldn't write %s to %s: %s\\n\", pid_str.c_str(), file.c_str(), strerror(errno)); &#125; &#125; &#125; if (svc-&gt;ioprio_class != IoSchedClass_NONE) &#123; if (android_set_ioprio(getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri)) &#123; ERROR(\"Failed to set pid %d ioprio = %d,%d: %s\\n\", getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri, strerror(errno)); &#125; &#125; //处理标准输入 标准输出 标准错误3个文件描述符 if (needs_console) &#123; setsid(); open_console(); &#125; else &#123; zap_stdio(); &#125; //这边明显不执行 if (false) &#123; for (size_t n = 0; svc-&gt;args[n]; n++) &#123; INFO(\"args[%zu] = '%s'\\n\", n, svc-&gt;args[n]); &#125; for (size_t n = 0; ENV[n]; n++) &#123; INFO(\"env[%zu] = '%s'\\n\", n, ENV[n]); &#125; &#125; setpgid(0, getpid()); // As requested, set our gid, supplemental gids, and uid. if (svc-&gt;gid) &#123; if (setgid(svc-&gt;gid) != 0) &#123; ERROR(\"setgid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;nr_supp_gids) &#123; if (setgroups(svc-&gt;nr_supp_gids, svc-&gt;supp_gids) != 0) &#123; ERROR(\"setgroups failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;uid) &#123; if (setuid(svc-&gt;uid) != 0) &#123; ERROR(\"setuid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;seclabel) &#123; if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) &#123; ERROR(\"cannot setexeccon('%s'): %s\\n\", svc-&gt;seclabel, strerror(errno)); _exit(127); &#125; &#125; //执行exec if (!dynamic_args) &#123; if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", svc-&gt;args[0], strerror(errno)); &#125; &#125; else &#123; char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc-&gt;nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; /* Copy the static arguments */ memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *))); while((bword = strsep(&amp;next, \" \"))) &#123; arg_ptrs[arg_idx++] = bword; if (arg_idx == INIT_PARSER_MAXARGS) break; &#125; arg_ptrs[arg_idx] = NULL; execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV); &#125; _exit(127);&#125; 三. 解析启动脚本init.rc3.1 init.rc文件格式init.rc文件是以块为单位，主要分为两类：一是行为:action,以on开头;二是服务:service，以service开头。注释以#开头。无论是action还是service的执行顺序都不是以文件中的编排顺序执行的，执行与否和是否执行都是Init进程中决定的。 3.1.1 action在on后面紧跟的字符串是action的触发器，触发器后面的是命令列表，每一行都是一个命令。可以通过 trigger 触发器字符串（trigger late-init） 来触发。 触发器几种类别 on early-init; 在初始化早期阶段触发； on init; 在初始化阶段触发； on late-init; 在初始化晚期阶段触发； on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举； on property:=: 当属性值满足条件时触发； 123456789101112on property:sys.boot_from_charger_mode=1 class_stop charger trigger late-init# Load properties from /system/ + /factory after fs mount.on load_system_props_action load_system_propson load_persist_props_action load_persist_props start logd start logd-reinit 3.1.2 service在service后面是服务的名称，我们可以使用“start”命令加服务名称来启动一个服务（start logd）。名称后面的则是执行文件路径和执行参数。然后下面的行称为选项，每一行都是一个选项。例如class表示服务的类别，我们可以通过class_start来一次性启动一组服务。12345678910111213141516171819202122232425262728293031service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0service logd /system/bin/logd class core socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram 0222 logd logd group root system writepid /dev/cpuset/system-background/tasksservice logd-reinit /system/bin/logd --reinit oneshot writepid /dev/cpuset/system-background/tasks disabledservice healthd /sbin/healthd class core critical seclabel u:r:healthd:s0 group root systemservice console /system/bin/sh class core console disabled user shell group shell log seclabel u:r:shell:s0 3.1.3 Options 选项选项是service的修订项，它决定了服务何时运行以及怎么运行。 disabled: 表示不能通过触发器来触发，只能根据start service名开启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket，并把文件描述符传递给要启动的进程。 critical:这是一个关键服务，如果在4分钟内重启启动4次，则系统会重启并进入Recovery模式。 3.1.4 Commands 命令 class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务； start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过； stop &lt;service_name&gt;： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink &lt;sym_link&gt;： 创建连接到的&lt;sym_link&gt;符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 commands的命令远不止上面这些，这里只是列出一些常用的命令。 3.2 脚本文件解析过程下面我们来追踪下脚本文件的解析过程 源码所在文件路径如下\\system\\core\\init\\init_parser.cpp 首先从入口函数开始 123456789101112131415int init_parse_config_file(const char* path) &#123; INFO(\"Parsing %s...\\n\", path); Timer t; std::string data; if (!read_file(path, &amp;data)) &#123; return -1; &#125; data.push_back('\\n'); // TODO: fix parse_config. parse_config(path, data); dump_parser_state(); NOTICE(\"(Parsing %s took %.2fs.)\\n\", path, t.duration()); return 0;&#125; 从上面的函数可以看出来，首先通过read_file将文件的内容读到内存中，然后再通过parse_config函数进行解析。下面我们继续来追踪parse_config的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void parse_config(const char *fn, const std::string&amp; data)&#123; struct listnode import_list; struct listnode *node; char *args[INIT_PARSER_MAXARGS]; int nargs = 0; parse_state state; state.filename = fn; state.line = 0; state.ptr = strdup(data.c_str()); // TODO: fix this code! state.nexttoken = 0; state.parse_line = parse_line_no_op; list_init(&amp;import_list); state.priv = &amp;import_list; for (;;) &#123; switch (next_token(&amp;state)) &#123; //如果是结束标识符，则跳转到下面的parser_done位置 case T_EOF: state.parse_line(&amp;state, 0, 0); goto parser_done; //行结束符 case T_NEWLINE: state.line++; if (nargs) &#123; int kw = lookup_keyword(args[0]); //判断是否是section：关键字 on service import if (kw_is(kw, SECTION)) &#123; state.parse_line(&amp;state, 0, 0); //具体处理见 3.2.1 parse_new_section(&amp;state, kw, nargs, args); &#125; else &#123; //当作当前section所属行处理 state.parse_line(&amp;state, nargs, args); &#125; nargs = 0; &#125; break; //单词结束符 则先放入到数组中 case T_TEXT: if (nargs &lt; INIT_PARSER_MAXARGS) &#123; args[nargs++] = state.text; &#125; break; &#125; &#125;parser_done: list_for_each(node, &amp;import_list) &#123; struct import *import = node_to_item(node, struct import, list); int ret; ret = init_parse_config_file(import-&gt;filename); if (ret) ERROR(\"could not import file '%s' from '%s'\\n\", import-&gt;filename, fn); &#125;&#125; parse_new_section方法追踪 1234567891011121314151617181920212223242526static void parse_new_section(struct parse_state *state, int kw, int nargs, char **args)&#123; printf(\"[ %s %s ]\\n\", args[0], nargs &gt; 1 ? args[1] : \"\"); switch(kw) &#123; case K_service: state-&gt;context = parse_service(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_service; return; &#125; break; case K_on: state-&gt;context = parse_action(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_action; return; &#125; break; case K_import: parse_import(state, nargs, args); break; &#125; state-&gt;parse_line = parse_line_no_op;&#125; 由上面的函数可以看出，该方法通过传入的参数kw来决定用什么方法来处理： on关键字：parse_action service关键字：parse_service import关键字：parse_action 然后我们可以看出上面对结构体state的parse_line字段分别进行赋值了方法地址,该方法用来解析命令行。 on关键字：parse_line_action service关键字：parse_line_service 3.3 执行action3.2的解析过程只是将init.rc中的action和service添加到各自的列表中。真正将它们添加到执行列表的还是在init进程中处理的。上文2.1.11 中在init的初始化过程通过action_for_each_trigger将action添加到action_queue中。 1234567891011121314151617void action_for_each_trigger(const char *trigger, void (*func)(struct action *act))&#123; struct listnode *node, *node2; struct action *act; struct trigger *cur_trigger; list_for_each(node, &amp;action_list) &#123; act = node_to_item(node, struct action, alist); list_for_each(node2, &amp;act-&gt;triggers) &#123; cur_trigger = node_to_item(node2, struct trigger, nlist); if (!strcmp(cur_trigger-&gt;name, trigger)) &#123; func(act); &#125; &#125; &#125;&#125; 四.Init进程对信号的处理4.1 僵尸进程当一个进程退出exit()时，会向它的父进程发送一个SIGCHLD信号。父进程收到该信号后，会释放分配给该子进程的系统资源；并且父进程需要调用wait()或waitpid()等待子进程结束。 如果父进程没有做这种处理，且父进程初始化时也没有调用signal(SIGCHLD, SIG_IGN)来显示忽略对SIGCHLD的处理，这时子进程将一直保持当前的退出状态，不会完全退出。这样的子进程不能被调度，所做的只是在进程列表中占据一个位置，保存了该进程的PID、终止状态、CPU使用时间等信息；我们将这种进程称为“Zombie”进程，即僵尸进程。 android中查看僵尸进程的方法是通过 adb shell ps来查看的，僵尸进程的的进程状态为“Z”。 由于僵尸进程仍会在进程列表中占据一个位置，而Linux所支持的最大进程数量是有限的；超过这个界限值后，我们就无法创建进程。所以，我们有必要清理那些僵尸进程，以保证系统的正常运作。 4.2 处理过程待补充 五. 属性系统5.1 属性系统介绍android的属性用来保存系统设置和进程间传递一些信息。每个属性由属性名称和属性值组成，名称通常以“.”分割,这些名称的前缀有特殊的含义，不能随便改动。属性值只能是字符串。 对于进程来说，读取属性值是没有限制的，任何进程都可以读取属性值。但是写属性值只能通过init进程进行，而且init进程还会检查请求的进程是否具有该权限（5.0以后只在）。当属性值修改成功后，init进程会init.rc中是否有跟该属性修改值相匹配的“触发器”。如果有则执行触发器下的命令。 前缀分类 “ro.”：表示只读属性，一旦设置则不能改变。 “persist”:表示属性值会被写入目录/data/property下与属性同名的文件中。下次开机init进程会从中读取值。所以这边设置的值是永久生效的。 “ctl”:表示控制信息，用来执行一些命令：ctl.start、ctl.stop、ctl.restart setprop ctl.start bootanim：查看开机动画 setprop ctl.stop bootanim：关闭开机动画 setprop ctl.start pre-recovery：进入recovery模式 5.2 创建属性系统的共享空间在上面Init进程的初始化函数中我们调用了property_init函数为属性系统创建了一块共享内存区域。这块区域只能由init进程进行写入，读则不限制。 123456789101112131415161718192021void property_init() &#123; //防止多次初始化 if (property_area_initialized) &#123; return; &#125; property_area_initialized = true; //创建和初始化属性的共享内存空间，这块内存空间由/dev/__properties__ 设备创建,这块空间的文件描述符保存在 //static workspace pa_workspace; 中，最后在service_start的时候保存到环境变量中 if (__system_property_area_init()) &#123; return; &#125; pa_workspace.size = 0; pa_workspace.fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC); if (pa_workspace.fd == -1) &#123; ERROR(\"Failed to open %s: %s\\n\", PROP_FILENAME, strerror(errno)); return; &#125;&#125; 5.3 初始化属性系统的值通过从以下文件中读取值进行初始化 /system/build.prop：定了系统初始和永久的一些属性/data/local.prop：这个则需要和ro.debuggable配合使用，如果这个值为1，那么从该文件中读取值覆盖系统缺省的属性值，之所有有这个设计是为了方便开发人员调试，因为/system/build.prop 是在根目录下的。/data/property：该目录下的文件读取出来写入到属性值中。/default.prop: Init进程初始化过程中调用property_load_boot_defaults函数读取的 源码地址 本文源码基于android6.0system\\core\\init\\init.cppsystem\\core\\init\\init_parser.cppsystem\\core\\init\\signal_handler.cppsystem\\core\\init\\property_service.cpp","categories":[],"tags":[]},{"title":"开机应用扫描流程","slug":"android6.0/PKMS/开机应用扫描流程","date":"2018-05-30T15:38:00.000Z","updated":"2018-05-31T00:52:32.308Z","comments":true,"path":"2018/05/30/android6.0/PKMS/开机应用扫描流程/","link":"","permalink":"http://yoursite.com/2018/05/30/android6.0/PKMS/开机应用扫描流程/","excerpt":"","text":"","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"PackageManagerService","slug":"android6-0/PackageManagerService","permalink":"http://yoursite.com/categories/android6-0/PackageManagerService/"}],"tags":[]},{"title":"动态更改Launch应用","slug":"工作问题/rk/动态更改Launch应用","date":"2018-05-29T15:45:53.000Z","updated":"2018-05-30T01:43:46.249Z","comments":true,"path":"2018/05/29/工作问题/rk/动态更改Launch应用/","link":"","permalink":"http://yoursite.com/2018/05/29/工作问题/rk/动态更改Launch应用/","excerpt":"","text":"","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"源码导航","slug":"android6.0/总览","date":"2018-05-29T05:37:00.000Z","updated":"2018-06-04T00:47:18.851Z","comments":true,"path":"2018/05/29/android6.0/总览/","link":"","permalink":"http://yoursite.com/2018/05/29/android6.0/总览/","excerpt":"","text":"一.引言Android系统非常庞大、错综复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连通系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而融为一体。 限于本人目前的只是水平,本系列的源码分析基本限于framework层的java代码。目前，网上有大量的android系统源码分析的书籍和博客，其实很不多优秀的文章。那为什么要再写一个自己的blog呢？这是因为android源码分析是个工程量非常巨大的事，在学些的过程中很容易迷失在源码的森林中，经常会出现看完一个模块，过一段时间就忘记的情况，所以很有必要将自己看的过程记录下来，同时也加深自己的理解。 首先说明本系列的源码分析是基于android6.0的源码，主要以事件为驱动来分析源码，比如我们我们在分析PKMS（PackageManagerService）服务的时候我们会从开机扫描过程，应用的安装过程等事件的流程进行分析解读。 二.Init进程和Zygote进程 Init进程 Init进程 Zygote进程 三.SystemServer四.PackageManagerService 开机应用扫描流程 应用安装流程 五.ActivityManagerService 开机广播流程 Activity启动流程 Service启动流程 registerReceiver流程 sendBroadcast流程 六.WindowManagerService七.致谢在blog的编写过程中会大量的引用平时看的书籍和前辈优秀的blog,在这边会贴出引用的书籍和blog地址！","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"导读","slug":"android6-0/导读","permalink":"http://yoursite.com/categories/android6-0/导读/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"}]}]}