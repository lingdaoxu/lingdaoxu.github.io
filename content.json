{"meta":{"title":"道墟","subtitle":"初九，潜龙勿用","description":null,"author":"道墟","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-05-29T15:28:54.000Z","updated":"2018-05-30T01:43:46.253Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2018-05-29T15:29:50.000Z","updated":"2018-05-30T01:43:46.257Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-30T03:44:46.000Z","updated":"2018-05-30T03:45:39.389Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Init进程","slug":"Init进程","date":"2018-05-31T06:32:19.000Z","updated":"2018-06-01T03:47:12.969Z","comments":true,"path":"2018/05/31/Init进程/","link":"","permalink":"http://yoursite.com/2018/05/31/Init进程/","excerpt":"","text":"本文源码所在文件\\system\\core\\init\\init.cpp\\system\\core\\init\\init_parser.cpp\\system\\core\\init\\signal_handler.cpp 一.概述Init进程是内核启动后创建的第一个用户进程，地位非常的重要。在Init初始化的过程中会启动很多重要的守护进程，当然Init本身也是一个守护进程。 在介绍Init进程前先简单的介绍下Android的启动过程 1.1 bootloader引导1.1.1 什么是bootloader引导当我们按下手机的电源键时，最先运行的就是bootloader.bootloader主要作用就是初始化基本的硬件设备（CPU,内存，Flash等）并且通过建立内存空间的映射，为装载linux内核准备好适合的环境。内核装载完毕，bootloader将会从内存中清除。 1.1.2 Fastboot模式Fastboot是Android设计的一套通过usb来更新手机分区映像的协议。 1.1.3 Recovery模式Android特有的升级系统。利用该模式可以进行恢复出厂设置，执行ota、补丁和固件升级。进入到Recovery模式实际上就是进入了一个文字模式的Linux 1.2 装载和启动Linux内核Android的boot.img存放的就是Linux的内核和一个根文件系统。上面的bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成整个后装载整个根文件系统，最后启动Init进程 什么是根文件系统？根文件系统是Linux系统一种特殊的文件系统，Android是基于Linux的，当然也有根文件系统。android的根文件系统是基于busybox实现的。 1.3 启动android系统android系统的启动可以更加详细的分为以下几个阶段 1.3.1 启动Init进程Init进程是系统启动的第一个进程。在Init的启动过程中会解析Linux的配置脚本init.rc文件。解析init.rc文件，init进程会加载android的文件系统、创建系统目录、初始化属性系统、启动android系统重要的守护进程（USB守护进程、adb守护进程、vold守护进程、rild守护进程）。 Init作为守护进程的作用：修改属性请求、重启崩溃的进程等操作。 1.3.2 启动ServiceManager由init启动。管理binder服务，负责binder的注册和查找。 1.3.3 启动Zygote进程Init进程初始化结束时会启动Zygote进程。Zygote进程负责fork应用进程。是所有应用进程的父进程。 Zygote进程初始化时会创建Dalivik虚拟机、预装载系统的资源文件和Java类。从Zygote中fork的进程都会继承和共享这些预加载的资源。 启动结束后，转为守护进程来响应应用建立的请求。 1.3.4 启动SystemServiceSystemService是Zygote进程fork的第一个进程，也是android系统的核心进程。在SystemService中运行这android大部分的binder服务。 首先会启动SensorService,接着是ActivityManagerService（AMS）,WindowsManagerService（WMS）,PackagerManagerService(PKMS)等服务。 1.3.5 启动LauncherSystemServer加载完所有的服务后，最后会调用AMS中的systemReady()方法。在这个方法的执行过程中会发出Intent(android.intent.category.Home).凡是响应这个Intent的应用都会启动起来（这个流程我们到时候在AMS的分析部分会重点追踪整个过程），这边要跟开机广播区别开来。 二.Init进程的初始化过程Init进程的源码位于\\system\\core\\init\\下。程序的入口函数main()位于init.cpp中。 2.1 main函数的流程2.1.1 选择启动程序因为Init和ueventd和watchdogd守护进程的代码存在大量的代码重合，所以直接合并到一个文件中，通过参数来判断执行那个守护进程。 1234567if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125; 2.1.2 设置进程创建的文件的属性缺省情况下一个进程创建的文件属性是022，使用umask可以设置文件属性的掩码。参数为0表示掩码为0777。 12// Clear the umask.umask(0); 2.1.3 创建目录和挂载文件系统12345678910111213//确保只执行一次bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); mount(\"proc\", \"/proc\", \"proc\", 0, NULL); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; tmpfs是一种基于内存的文件系统，mount后就可以使用。tmpfs文件系统下的所有文件都存放在内存中，访问速度快，但是关机后会消失，适合用来存放临时性的文件。而且tmpfs文件系统的大小是动态变化的，一开始很小，随着文件的增多会随之变大。从上面的代码我们可以看到Android系统将tmpfs文件系统挂载到/dev目录下，而这个目录是用来保存系统创造的设备节点，正好符合tmpfs的特点。 devpts是虚拟终端文件系统，通常mount在目录/dev/pts下。 2.1.4 初始化log系统1234567891011//将标准输入、输出、错误重定向到空设备文件/dev/null下，这是守护进程常用的手段 open_devnull_stdio();//创建设备节点/dev/kmsg,这样init进程就可以使用kernel的log系统，之所以是用使用kernel的log系统是因为这时候android层的log系统还没有启动起来 klog_init();//设置log级别 klog_set_level(KLOG_NOTICE_LEVEL);//打印init进程开始启动的日志 NOTICE(\"init%s started!\\n\", is_first_stage ? \"\" : \" second stage\"); 日志输出级别的宏定义如下 KLOG_ERROR_LEVEL 3 KLOG_WARNING_LEVEL 4 KLOG_NOTICE_LEVEL 5 KLOG_INFO_LEVEL 6 KLOG_DEBUG_LEVEL 7 KLOG_DEFAULT_LEVEL 3 //默认为3当我们设置的级别低于5的时候会输出到 kernel log 中 2.1.5 初始化属性系统123456789101112131415161718 if (!is_first_stage) &#123;//在/dev下创建一个设备表示正在初始化中，当初始化完成则移除// Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));//创建一个共享区域来存储属性值 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt();//解析kernel的启动参数 process_kernel_cmdline(); // Propogate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; 2.1.6 初始化SELinux内核SELinux内核是android4.3开始引入的。在后面的解析系列中会重点解析这块。1234567891011121314151617181920212223242526272829303132// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.INFO(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; 2.1.7 初始化子进程退出的信号处理过程1signal_handler_init(); 2.1.8 设置系统属性的默认值1property_load_boot_defaults(); 上面的函数会从设备的根目录下的default.prop文件(路径:/default.prop)的属性值读取设置到属性系统中。 下面是截取的nexu5x 6.0系统模拟器下的文件值1234567891011121314151617181920## ADDITIONAL_DEFAULT_PROPERTIES#ro.secure=1ro.allow.mock.location=0ro.debuggable=1ro.zygote=zygote32dalvik.vm.image-dex2oat-Xms=64mdalvik.vm.image-dex2oat-Xmx=64mdalvik.vm.dex2oat-Xms=64mdalvik.vm.dex2oat-Xmx=512mro.dalvik.vm.native.bridge=0debug.atrace.tags.enableflags=0## BOOTIMAGE_BUILD_PROPERTIES#ro.bootimage.build.date=Wed Dec 13 00:51:01 UTC 2017ro.bootimage.build.date.utc=1513126261ro.bootimage.build.fingerprint=Android/sdk_google_phone_x86/generic_x86:6.0/MASTER/4499259:userdebug/test-keyspersist.sys.usb.config=adb 2.1.9 启动属性服务（sockect）1start_property_service(); 2.1.10 解析init.rc文件解析完成后的结果是将init文件中的Server项和Action项分别加入到内部Service列表:service_list 和Action列表:action_list解析的过程会在下面的详细的分析 1init_parse_config_file(\"/init.rc\"); 2.1.11 初始化执行列表action_queue1234567891011121314151617181920212223242526272829303132333435 //将rc文件中触发器为early-init的action添加到执行列表action_for_each_trigger(\"early-init\", action_add_queue_tail);//queue_builtin_action 作用就是将一个函数和一个名称生成action并插入到执行列表 // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...//等待冷插拔设备初始化完成 queue_builtin_action(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. //从硬件RNG的设备文件/dev/hw_randow中读取512字节并写到Linux RNGd的设备文件/dev/urandom中（这块因为水平有限，还未知道具体作用）queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//初始化组合键监听模块 queue_builtin_action(keychord_init_action, \"keychord_init\");//在屏幕上显示Android字样的Logo queue_builtin_action(console_init_action, \"console_init\"); //将rc文件中触发器为init的action添加到执行列表 // Trigger all the boot actions to get us started. action_for_each_trigger(\"init\", action_add_queue_tail); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done queue_builtin_action(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");//当处于充电模式，则charger加入执行队列；否则late-init加入队列。 // Don't mount filesystems or start core system services in charger mode. char bootmode[PROP_VALUE_MAX]; if (property_get(\"ro.bootmode\", bootmode) &gt; 0 &amp;&amp; strcmp(bootmode, \"charger\") == 0) &#123; action_for_each_trigger(\"charger\", action_add_queue_tail); &#125; else &#123; action_for_each_trigger(\"late-init\", action_add_queue_tail); &#125;//检查Action列表中通过修改属性来触发的Action，查看相关的属性是否已经设置了，如果已经设置则将该action加入到执行列表 // Run all property triggers based on current state of the properties. queue_builtin_action(queue_property_triggers_action, \"queue_property_triggers\"); 2.1.12 无限循环执行123456789101112131415161718192021222324252627while (true) &#123; if (!waiting_for_exec) &#123; execute_one_command(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (!action_queue_empty() || cur_action) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; 2.2 启动Service进程上面最后无限循环的过程中 restart_processes 函数会检查service_list中所有服务，对于带有SVC_RESTARTING标志的服务，将服务作为参数调用 restart_service_if_needed 1234567891011121314static void restart_service_if_needed(struct service *svc) &#123; time_t next_start_time = svc-&gt;time_started + 5; if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); service_start(svc, NULL); return; &#125; if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; 由上面代码可以看出最后调用了service_start方法，下面我们来分析这个方法。 2.2.1 重置Service结构中的标志和可执行判断12345678910111213141516171819202122232425262728293031323334353637 // Starting a service removes it from the disabled or reset state and // immediately takes it out of the restarting state if it was in there.//这四个表示都是有启动相关的所以直接去掉 svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START)); svc-&gt;time_started = 0;//如果已经在启动了则不需要再执行 // Running processes require no additional work --- if they're in the // process of exiting, we've ensured that they will immediately restart // on exit, unless they are ONESHOT. if (svc-&gt;flags &amp; SVC_RUNNING) &#123; return; &#125;//如果服务需要控制台，但是控制台没有启动则退出 bool needs_console = (svc-&gt;flags &amp; SVC_CONSOLE); if (needs_console &amp;&amp; !have_console) &#123; ERROR(\"service '%s' requires console\\n\", svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务的二进制文件是否存在 struct stat s; if (stat(svc-&gt;args[0], &amp;s) != 0) &#123; ERROR(\"cannot find '%s', disabling '%s'\\n\", svc-&gt;args[0], svc-&gt;name); svc-&gt;flags |= SVC_DISABLED; return; &#125;//检查服务是否有SVC_ONESHOT参数 if ((!(svc-&gt;flags &amp; SVC_ONESHOT)) &amp;&amp; dynamic_args) &#123; ERROR(\"service '%s' must be one-shot to use dynamic args, disabling\\n\", svc-&gt;args[0]); svc-&gt;flags |= SVC_DISABLED; return; &#125; 2.2.2 设置安全上下文关于安全机制在后续的文章中分析 12345678910111213141516171819202122232425262728293031323334353637char* scon = NULL;if (is_selinux_enabled() &gt; 0) &#123; if (svc-&gt;seclabel) &#123; scon = strdup(svc-&gt;seclabel); if (!scon) &#123; ERROR(\"Out of memory while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125; else &#123; char *mycon = NULL, *fcon = NULL; INFO(\"computing context for service '%s'\\n\", svc-&gt;args[0]); int rc = getcon(&amp;mycon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; rc = getfilecon(svc-&gt;args[0], &amp;fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); freecon(mycon); return; &#125; rc = security_compute_create(mycon, fcon, string_to_security_class(\"process\"), &amp;scon); if (rc == 0 &amp;&amp; !strcmp(scon, mycon)) &#123; ERROR(\"Warning! Service %s needs a SELinux domain defined; please fix!\\n\", svc-&gt;name); &#125; freecon(mycon); freecon(fcon); if (rc &lt; 0) &#123; ERROR(\"could not get context while starting '%s'\\n\", svc-&gt;name); return; &#125; &#125;&#125; 2.2.3 fork子进程,exec123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126 //首先打印 服务启动日志NOTICE(\"Starting service '%s'...\\n\", svc-&gt;name); //fork进程pid_t pid = fork();if (pid == 0) &#123; struct socketinfo *si; struct svcenvinfo *ei; char tmp[32]; int fd, sz; umask(077); //准备环境变量 if (properties_initialized()) &#123; get_property_workspace(&amp;fd, &amp;sz); snprintf(tmp, sizeof(tmp), \"%d,%d\", dup(fd), sz); add_environment(\"ANDROID_PROPERTY_WORKSPACE\", tmp); &#125; for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next) add_environment(ei-&gt;name, ei-&gt;value); //如果服务选项中有socket选项。这时候就开始创建参数中定义的socket。 for (si = svc-&gt;sockets; si; si = si-&gt;next) &#123; int socket_type = ( !strcmp(si-&gt;type, \"stream\") ? SOCK_STREAM : (!strcmp(si-&gt;type, \"dgram\") ? SOCK_DGRAM : SOCK_SEQPACKET)); int s = create_socket(si-&gt;name, socket_type, si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon); if (s &gt;= 0) &#123; publish_socket(si-&gt;name, s); &#125; &#125; freecon(scon); scon = NULL; if (svc-&gt;writepid_files_) &#123; std::string pid_str = android::base::StringPrintf(\"%d\", pid); for (auto&amp; file : *svc-&gt;writepid_files_) &#123; if (!android::base::WriteStringToFile(pid_str, file)) &#123; ERROR(\"couldn't write %s to %s: %s\\n\", pid_str.c_str(), file.c_str(), strerror(errno)); &#125; &#125; &#125; if (svc-&gt;ioprio_class != IoSchedClass_NONE) &#123; if (android_set_ioprio(getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri)) &#123; ERROR(\"Failed to set pid %d ioprio = %d,%d: %s\\n\", getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri, strerror(errno)); &#125; &#125; //处理标准输入 标准输出 标准错误3个文件描述符 if (needs_console) &#123; setsid(); open_console(); &#125; else &#123; zap_stdio(); &#125; //这边明显不执行 if (false) &#123; for (size_t n = 0; svc-&gt;args[n]; n++) &#123; INFO(\"args[%zu] = '%s'\\n\", n, svc-&gt;args[n]); &#125; for (size_t n = 0; ENV[n]; n++) &#123; INFO(\"env[%zu] = '%s'\\n\", n, ENV[n]); &#125; &#125; setpgid(0, getpid()); // As requested, set our gid, supplemental gids, and uid. if (svc-&gt;gid) &#123; if (setgid(svc-&gt;gid) != 0) &#123; ERROR(\"setgid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;nr_supp_gids) &#123; if (setgroups(svc-&gt;nr_supp_gids, svc-&gt;supp_gids) != 0) &#123; ERROR(\"setgroups failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;uid) &#123; if (setuid(svc-&gt;uid) != 0) &#123; ERROR(\"setuid failed: %s\\n\", strerror(errno)); _exit(127); &#125; &#125; if (svc-&gt;seclabel) &#123; if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) &#123; ERROR(\"cannot setexeccon('%s'): %s\\n\", svc-&gt;seclabel, strerror(errno)); _exit(127); &#125; &#125; //执行exec if (!dynamic_args) &#123; if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123; ERROR(\"cannot execve('%s'): %s\\n\", svc-&gt;args[0], strerror(errno)); &#125; &#125; else &#123; char *arg_ptrs[INIT_PARSER_MAXARGS+1]; int arg_idx = svc-&gt;nargs; char *tmp = strdup(dynamic_args); char *next = tmp; char *bword; /* Copy the static arguments */ memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *))); while((bword = strsep(&amp;next, \" \"))) &#123; arg_ptrs[arg_idx++] = bword; if (arg_idx == INIT_PARSER_MAXARGS) break; &#125; arg_ptrs[arg_idx] = NULL; execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV); &#125; _exit(127);&#125; 三. 解析启动脚本init.rc3.1 init.rc文件格式init.rc文件是以块为单位，主要分为两类：一是行为:action,以on开头;二是服务:service，以service开头。注释以#开头。无论是action还是service的执行顺序都不是以文件中的编排顺序执行的，执行与否和是否执行都是Init进程中决定的。 3.1.1 action在on后面紧跟的字符串是action的触发器，触发器后面的是命令列表，每一行都是一个命令。可以通过 trigger 触发器字符串（trigger late-init） 来触发。 触发器几种类别 on early-init; 在初始化早期阶段触发； on init; 在初始化阶段触发； on late-init; 在初始化晚期阶段触发； on boot/charger： 当系统启动/充电时触发，还包含其他情况，此处不一一列举； on property:=: 当属性值满足条件时触发； 123456789101112on property:sys.boot_from_charger_mode=1 class_stop charger trigger late-init# Load properties from /system/ + /factory after fs mount.on load_system_props_action load_system_propson load_persist_props_action load_persist_props start logd start logd-reinit 3.1.2 service在service后面是服务的名称，我们可以使用“start”命令加服务名称来启动一个服务（start logd）。名称后面的则是执行文件路径和执行参数。然后下面的行称为选项，每一行都是一个选项。例如class表示服务的类别，我们可以通过class_start来一次性启动一组服务。12345678910111213141516171819202122232425262728293031service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0service logd /system/bin/logd class core socket logd stream 0666 logd logd socket logdr seqpacket 0666 logd logd socket logdw dgram 0222 logd logd group root system writepid /dev/cpuset/system-background/tasksservice logd-reinit /system/bin/logd --reinit oneshot writepid /dev/cpuset/system-background/tasks disabledservice healthd /sbin/healthd class core critical seclabel u:r:healthd:s0 group root systemservice console /system/bin/sh class core console disabled user shell group shell log seclabel u:r:shell:s0 3.1.3 Options 选项选项是service的修订项，它决定了服务何时运行以及怎么运行。 disabled: 表示不能通过触发器来触发，只能根据start service名开启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket，并把文件描述符传递给要启动的进程。 critical:这是一个关键服务，如果在4分钟内重启启动4次，则系统会重启并进入Recovery模式。 3.1.4 Commands 命令 class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务； start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过； stop &lt;service_name&gt;： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink &lt;sym_link&gt;： 创建连接到的&lt;sym_link&gt;符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 commands的命令远不止上面这些，这里只是列出一些常用的命令。 3.2 脚本文件解析过程下面我们来追踪下脚本文件的解析过程 源码所在文件路径如下\\system\\core\\init\\init_parser.cpp 首先从入口函数开始 123456789101112131415int init_parse_config_file(const char* path) &#123; INFO(\"Parsing %s...\\n\", path); Timer t; std::string data; if (!read_file(path, &amp;data)) &#123; return -1; &#125; data.push_back('\\n'); // TODO: fix parse_config. parse_config(path, data); dump_parser_state(); NOTICE(\"(Parsing %s took %.2fs.)\\n\", path, t.duration()); return 0;&#125; 从上面的函数可以看出来，首先通过read_file将文件的内容读到内存中，然后再通过parse_config函数进行解析。下面我们继续来追踪parse_config的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void parse_config(const char *fn, const std::string&amp; data)&#123; struct listnode import_list; struct listnode *node; char *args[INIT_PARSER_MAXARGS]; int nargs = 0; parse_state state; state.filename = fn; state.line = 0; state.ptr = strdup(data.c_str()); // TODO: fix this code! state.nexttoken = 0; state.parse_line = parse_line_no_op; list_init(&amp;import_list); state.priv = &amp;import_list; for (;;) &#123; switch (next_token(&amp;state)) &#123; //如果是结束标识符，则跳转到下面的parser_done位置 case T_EOF: state.parse_line(&amp;state, 0, 0); goto parser_done; //行结束符 case T_NEWLINE: state.line++; if (nargs) &#123; int kw = lookup_keyword(args[0]); //判断是否是section：关键字 on service import if (kw_is(kw, SECTION)) &#123; state.parse_line(&amp;state, 0, 0); //具体处理见 3.2.1 parse_new_section(&amp;state, kw, nargs, args); &#125; else &#123; //当作当前section所属行处理 state.parse_line(&amp;state, nargs, args); &#125; nargs = 0; &#125; break; //单词结束符 则先放入到数组中 case T_TEXT: if (nargs &lt; INIT_PARSER_MAXARGS) &#123; args[nargs++] = state.text; &#125; break; &#125; &#125;parser_done: list_for_each(node, &amp;import_list) &#123; struct import *import = node_to_item(node, struct import, list); int ret; ret = init_parse_config_file(import-&gt;filename); if (ret) ERROR(\"could not import file '%s' from '%s'\\n\", import-&gt;filename, fn); &#125;&#125; parse_new_section方法追踪 1234567891011121314151617181920212223242526static void parse_new_section(struct parse_state *state, int kw, int nargs, char **args)&#123; printf(\"[ %s %s ]\\n\", args[0], nargs &gt; 1 ? args[1] : \"\"); switch(kw) &#123; case K_service: state-&gt;context = parse_service(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_service; return; &#125; break; case K_on: state-&gt;context = parse_action(state, nargs, args); if (state-&gt;context) &#123; state-&gt;parse_line = parse_line_action; return; &#125; break; case K_import: parse_import(state, nargs, args); break; &#125; state-&gt;parse_line = parse_line_no_op;&#125; 由上面的函数可以看出，该方法通过传入的参数kw来决定用什么方法来处理： on关键字：parse_action service关键字：parse_service import关键字：parse_action 然后我们可以看出上面对结构体state的parse_line字段分别进行赋值了方法地址,该方法用来解析命令行。 on关键字：parse_line_action service关键字：parse_line_service 3.3 执行action3.2的解析过程只是将init.rc中的action和service添加到各自的列表中。真正将它们添加到执行列表的还是在init进程中处理的。上文2.1.11 中在init的初始化过程通过action_for_each_trigger将action添加到action_queue中。 1234567891011121314151617void action_for_each_trigger(const char *trigger, void (*func)(struct action *act))&#123; struct listnode *node, *node2; struct action *act; struct trigger *cur_trigger; list_for_each(node, &amp;action_list) &#123; act = node_to_item(node, struct action, alist); list_for_each(node2, &amp;act-&gt;triggers) &#123; cur_trigger = node_to_item(node2, struct trigger, nlist); if (!strcmp(cur_trigger-&gt;name, trigger)) &#123; func(act); &#125; &#125; &#125;&#125; 四.Init进程对信号的处理4.1 僵尸进程当一个进程退出exit()时，会向它的父进程发送一个SIGCHLD信号。父进程收到该信号后，会释放分配给该子进程的系统资源；并且父进程需要调用wait()或waitpid()等待子进程结束。 如果父进程没有做这种处理，且父进程初始化时也没有调用signal(SIGCHLD, SIG_IGN)来显示忽略对SIGCHLD的处理，这时子进程将一直保持当前的退出状态，不会完全退出。这样的子进程不能被调度，所做的只是在进程列表中占据一个位置，保存了该进程的PID、终止状态、CPU使用时间等信息；我们将这种进程称为“Zombie”进程，即僵尸进程。 android中查看僵尸进程的方法是通过 adb shell ps来查看的，僵尸进程的的进程状态为“Z”。 由于僵尸进程仍会在进程列表中占据一个位置，而Linux所支持的最大进程数量是有限的；超过这个界限值后，我们就无法创建进程。所以，我们有必要清理那些僵尸进程，以保证系统的正常运作。","categories":[],"tags":[]},{"title":"开机应用扫描流程","slug":"android6.0/PKMS/开机应用扫描流程","date":"2018-05-30T15:38:00.000Z","updated":"2018-05-31T00:52:32.308Z","comments":true,"path":"2018/05/30/android6.0/PKMS/开机应用扫描流程/","link":"","permalink":"http://yoursite.com/2018/05/30/android6.0/PKMS/开机应用扫描流程/","excerpt":"","text":"","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"PackageManagerService","slug":"android6-0/PackageManagerService","permalink":"http://yoursite.com/categories/android6-0/PackageManagerService/"}],"tags":[]},{"title":"动态更改Launch应用","slug":"工作问题/rk/动态更改Launch应用","date":"2018-05-29T15:45:53.000Z","updated":"2018-05-30T01:43:46.249Z","comments":true,"path":"2018/05/29/工作问题/rk/动态更改Launch应用/","link":"","permalink":"http://yoursite.com/2018/05/29/工作问题/rk/动态更改Launch应用/","excerpt":"","text":"","categories":[{"name":"工作问题","slug":"工作问题","permalink":"http://yoursite.com/categories/工作问题/"},{"name":"rk3228&rk3399","slug":"工作问题/rk3228-rk3399","permalink":"http://yoursite.com/categories/工作问题/rk3228-rk3399/"}],"tags":[]},{"title":"源码导航","slug":"android6.0/总览","date":"2018-05-29T05:37:00.000Z","updated":"2018-05-31T00:54:07.158Z","comments":true,"path":"2018/05/29/android6.0/总览/","link":"","permalink":"http://yoursite.com/2018/05/29/android6.0/总览/","excerpt":"","text":"一.引言Android系统非常庞大、错综复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连通系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而融为一体。 限于本人目前的只是水平,本系列的源码分析基本限于framework层的java代码。目前，网上有大量的android系统源码分析的书籍和博客，其实很不多优秀的文章。那为什么要再写一个自己的blog呢？这是因为android源码分析是个工程量非常巨大的事，在学些的过程中很容易迷失在源码的森林中，经常会出现看完一个模块，过一段时间就忘记的情况，所以很有必要将自己看的过程记录下来，同时也加深自己的理解。 首先说明本系列的源码分析是基于android6.0的源码，主要以事件为驱动来分析源码，比如我们我们在分析PKMS（PackageManagerService）服务的时候我们会从开机扫描过程，应用的安装过程等事件的流程进行分析解读。 二.Init进程和Zygote进程三.SystemServer四.PackageManagerService 开机应用扫描流程 应用安装流程 五.ActivityManagerService 开机广播流程 Activity启动流程 Service启动流程 registerReceiver流程 sendBroadcast流程 六.WindowManagerService七.致谢在blog的编写过程中会大量的引用平时看的书籍和前辈优秀的blog,在这边会贴出引用的书籍和blog地址！","categories":[{"name":"android6.0","slug":"android6-0","permalink":"http://yoursite.com/categories/android6-0/"},{"name":"导读","slug":"android6-0/导读","permalink":"http://yoursite.com/categories/android6-0/导读/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"}]}]}